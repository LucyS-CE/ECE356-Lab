001c671a	f24	p0	2024-09-18 15:45:02	Field.h	1	1	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 15:45:02	Field.h	10	10	constructor
001c671a	f24	p0	2024-09-18 15:45:02	Field.h	13	13	deconstructor which deletes the array created by create_field
001c671a	f24	p0	2024-09-18 15:45:02	Field.h	16	16	variables
001c671a	f24	p0	2024-09-18 15:45:02	Field.h	22	22	functions
001c671a	f24	p0	2024-09-18 15:45:02	Field.h	32	32	only ever called when k is updated or object is added - encapsulated within other functions. no need to be public.
001c671a	f24	p0	2024-09-18 15:45:02	FieldElement.h	4	4	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 15:45:02	FieldElement.h	11	11	constructor
001c671a	f24	p0	2024-09-18 15:45:02	FieldElement.h	14	14	potential: getter and setter
001c671a	f24	p0	2024-09-18 15:45:02	FieldElement.h	18	18	object: getter and setter
001c671a	f24	p0	2024-09-18 15:45:02	FieldElement.h	23	24	private because users should not be able to edit this directly. it is computed from other values.\nprivate because it should not be set to anything at any time. - only to certain values
001c671a	f24	p0	2024-09-18 15:45:02	FieldElement.h	29	29	FIELDELEMENT_H
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	9	9	constructor definition for creating the grid
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	11	11	set_K(1);
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	30	30	constructor definition for creating the elements of the grid - initializes variables
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	43	44	must compute and set for all cells\ninitializes potential of all cells to 0
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	47	47	Reset potential for each cell
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	54	54	if obstacle is present, add potential to all cells that do not have a goal or obstacle.
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	69	69	if goal is present, subtract potential from the specified location
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	87	87	function to add an obstacle at a user-inputted postition
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	93	93	function called when the grid should be cleared
001c671a	f24	p0	2024-09-18 15:45:02	robotNav.cpp	95	95	checks through every object of the array - sets all goals and obstacles to false
001c671a	f24	p0	2024-09-18 15:45:02	testing.cpp	18	18	create new Field object
001c671a	f24	p0	2024-09-18 15:45:02	testing.cpp	43	43	value of potential field if (x,y) is within the map MAYBE GET POTENTIAL FUNCTION
001c671a	f24	p0	2024-09-18 15:45:02	testing.cpp	45	45	(x,y) are outside of map
001c671a	f24	p0	2024-09-18 15:45:02	testing.cpp	55	55	map as not been created yet
001c671a	f24	p0	2024-09-18 19:38:10	Field.h	1	1	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 19:38:10	Field.h	10	10	constructor
001c671a	f24	p0	2024-09-18 19:38:10	Field.h	13	13	deconstructor which deletes the array created by create_field
001c671a	f24	p0	2024-09-18 19:38:10	Field.h	16	16	grid dimension variables - only ever accessed by functions of this class
001c671a	f24	p0	2024-09-18 19:38:10	Field.h	22	22	functions
001c671a	f24	p0	2024-09-18 19:38:10	Field.h	30	30	only ever called when k is updated or object is added - encapsulated within other functions. no need to be public.
001c671a	f24	p0	2024-09-18 19:38:10	Field.h	34	34	K is private to ensure that set_K checks for valid value
001c671a	f24	p0	2024-09-18 19:38:10	FieldElement.h	1	1	ensures the header is only compiled once
001c671a	f24	p0	2024-09-18 19:38:10	FieldElement.h	4	4	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 19:38:10	FieldElement.h	11	11	constructor
001c671a	f24	p0	2024-09-18 19:38:10	FieldElement.h	14	14	potential: getter and setter
001c671a	f24	p0	2024-09-18 19:38:10	FieldElement.h	22	23	only one var for potential since acccording to the formula, potential x and potential y are always the same.\nprivate because users should not be able to edit this directly. it is computed from other values.
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	9	9	constructor definition for creating the grid
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	37	37	constructor definition for creating the elements of the grid - initializes variables
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	50	51	must compute and set for all cells\ninitializes potential of all cells to 0
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	54	54	Reset potential for each cell
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	61	61	if obstacle is present, add potential to all cells that do not have a goal or obstacle.
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	76	76	if goal is present, subtract potential from the specified location
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	94	94	function to add an obstacle at a user-inputted postition
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	100	100	function called when the grid should be cleared
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	102	102	checks through every object of the array - sets all goals and obstacles to false
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	108	108	grid[row][col].set_potential(0);
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	111	111	or set to 0 this may be faster.
001c671a	f24	p0	2024-09-18 19:38:10	robotNav.cpp	123	129	char FieldElement::get_object(){\nreturn object;\n}\nvoid FieldElement::set_object(char obj){\nobject = obj;\n//compute_potential();\n}
001c671a	f24	p0	2024-09-18 19:38:10	testing.cpp	20	20	create new Field object
001c671a	f24	p0	2024-09-18 19:38:10	testing.cpp	43	43	value of potential field if (x,y) is within the map MAYBE GET POTENTIAL FUNCTION
001c671a	f24	p0	2024-09-18 19:38:10	testing.cpp	45	45	(x,y) are outside of map
001c671a	f24	p0	2024-09-18 19:38:10	testing.cpp	55	55	map as not been created yet
001c671a	f24	p0	2024-09-18 20:26:38	Field.h	1	1	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 20:26:38	Field.h	10	10	constructor
001c671a	f24	p0	2024-09-18 20:26:38	Field.h	13	13	deconstructor which deletes the array created by create_field
001c671a	f24	p0	2024-09-18 20:26:38	Field.h	16	16	grid dimension variables - only ever accessed by functions of this class
001c671a	f24	p0	2024-09-18 20:26:38	Field.h	22	22	functions
001c671a	f24	p0	2024-09-18 20:26:38	Field.h	30	30	only ever called when k is updated or object is added - encapsulated within other functions. no need to be public.
001c671a	f24	p0	2024-09-18 20:26:38	Field.h	34	34	K is private to ensure that set_K checks for valid value
001c671a	f24	p0	2024-09-18 20:26:38	FieldElement.h	1	1	ensures the header is only compiled once
001c671a	f24	p0	2024-09-18 20:26:38	FieldElement.h	4	4	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 20:26:38	FieldElement.h	11	11	constructor
001c671a	f24	p0	2024-09-18 20:26:38	FieldElement.h	14	14	potential: getter and setter
001c671a	f24	p0	2024-09-18 20:26:38	FieldElement.h	22	23	only one var for potential since acccording to the formula, potential x and potential y are always the same.\nprivate because users should not be able to edit this directly. it is computed from other values.
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	9	9	constructor definition for creating the grid
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	30	30	constructor definition for creating the elements of the grid - initializes variables
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	43	44	must compute and set for all cells\ninitializes potential of all cells to 0
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	47	47	Reset potential for each cell
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	54	54	if obstacle is present, add potential to all cells that do not have a goal or obstacle.
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	69	69	if goal is present, subtract potential from the specified location
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	87	87	function to add an obstacle at a user-inputted postition
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	93	93	function called when the grid should be cleared
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	95	95	checks through every object of the array - sets all goals and obstacles to false
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	101	101	grid[row][col].set_potential(0);
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	104	104	or set to 0 this may be faster.
001c671a	f24	p0	2024-09-18 20:26:38	robotNav.cpp	116	122	char FieldElement::get_object(){\nreturn object;\n}\nvoid FieldElement::set_object(char obj){\nobject = obj;\n//compute_potential();\n}
001c671a	f24	p0	2024-09-18 20:26:38	testing.cpp	26	26	create new Field object
001c671a	f24	p0	2024-09-18 20:26:38	testing.cpp	49	49	value of potential field if (x,y) is within the map MAYBE GET POTENTIAL FUNCTION
001c671a	f24	p0	2024-09-18 20:26:38	testing.cpp	51	51	(x,y) are outside of map
001c671a	f24	p0	2024-09-18 20:26:38	testing.cpp	61	61	map as not been created yet
001c671a	f24	p0	2024-09-18 20:28:15	Field.h	1	1	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 20:28:15	Field.h	10	10	constructor
001c671a	f24	p0	2024-09-18 20:28:15	Field.h	13	13	deconstructor which deletes the array created by create_field
001c671a	f24	p0	2024-09-18 20:28:15	Field.h	16	16	grid dimension variables - only ever accessed by functions of this class
001c671a	f24	p0	2024-09-18 20:28:15	Field.h	22	22	functions
001c671a	f24	p0	2024-09-18 20:28:15	Field.h	30	30	only ever called when k is updated or object is added - encapsulated within other functions. no need to be public.
001c671a	f24	p0	2024-09-18 20:28:15	Field.h	34	34	K is private to ensure that set_K checks for valid value
001c671a	f24	p0	2024-09-18 20:28:15	FieldElement.h	1	1	ensures the header is only compiled once
001c671a	f24	p0	2024-09-18 20:28:15	FieldElement.h	4	4	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 20:28:15	FieldElement.h	11	11	constructor
001c671a	f24	p0	2024-09-18 20:28:15	FieldElement.h	14	14	potential: getter and setter
001c671a	f24	p0	2024-09-18 20:28:15	FieldElement.h	22	23	only one var for potential since acccording to the formula, potential x and potential y are always the same.\nprivate because users should not be able to edit this directly. it is computed from other values.
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	9	9	constructor definition for creating the grid
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	30	30	constructor definition for creating the elements of the grid - initializes variables
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	43	44	must compute and set for all cells\ninitializes potential of all cells to 0
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	47	47	Reset potential for each cell
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	54	54	if obstacle is present, add potential to all cells that do not have a goal or obstacle.
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	69	69	if goal is present, subtract potential from the specified location
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	87	87	function to add an obstacle at a user-inputted postition
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	93	93	function called when the grid should be cleared
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	95	95	checks through every object of the array - sets all goals and obstacles to false
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	101	101	grid[row][col].set_potential(0);
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	104	104	or set to 0 this may be faster.
001c671a	f24	p0	2024-09-18 20:28:15	robotNav.cpp	116	122	char FieldElement::get_object(){\nreturn object;\n}\nvoid FieldElement::set_object(char obj){\nobject = obj;\n//compute_potential();\n}
001c671a	f24	p0	2024-09-18 20:28:15	testing.cpp	26	26	create new Field object
001c671a	f24	p0	2024-09-18 20:28:15	testing.cpp	49	49	value of potential field if (x,y) is within the map MAYBE GET POTENTIAL FUNCTION
001c671a	f24	p0	2024-09-18 20:28:15	testing.cpp	51	51	(x,y) are outside of map
001c671a	f24	p0	2024-09-18 20:28:15	testing.cpp	61	61	map as not been created yet
001c671a	f24	p0	2024-09-18 20:28:49	Field.h	1	1	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 20:28:49	Field.h	10	10	constructor
001c671a	f24	p0	2024-09-18 20:28:49	Field.h	13	13	deconstructor which deletes the array created by create_field
001c671a	f24	p0	2024-09-18 20:28:49	Field.h	16	16	grid dimension variables - only ever accessed by functions of this class
001c671a	f24	p0	2024-09-18 20:28:49	Field.h	22	22	functions
001c671a	f24	p0	2024-09-18 20:28:49	Field.h	30	30	only ever called when k is updated or object is added - encapsulated within other functions. no need to be public.
001c671a	f24	p0	2024-09-18 20:28:49	Field.h	34	34	K is private to ensure that set_K checks for valid value
001c671a	f24	p0	2024-09-18 20:28:49	FieldElement.h	1	1	ensures the header is only compiled once
001c671a	f24	p0	2024-09-18 20:28:49	FieldElement.h	4	4	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 20:28:49	FieldElement.h	11	11	constructor
001c671a	f24	p0	2024-09-18 20:28:49	FieldElement.h	14	14	potential: getter and setter
001c671a	f24	p0	2024-09-18 20:28:49	FieldElement.h	22	23	only one var for potential since acccording to the formula, potential x and potential y are always the same.\nprivate because users should not be able to edit this directly. it is computed from other values.
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	9	9	constructor definition for creating the grid
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	30	30	constructor definition for creating the elements of the grid - initializes variables
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	43	44	must compute and set for all cells\ninitializes potential of all cells to 0
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	47	47	Reset potential for each cell
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	54	54	if obstacle is present, add potential to all cells that do not have a goal or obstacle.
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	69	69	if goal is present, subtract potential from the specified location
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	87	87	function to add an obstacle at a user-inputted postition
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	93	93	function called when the grid should be cleared
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	95	95	checks through every object of the array - sets all goals and obstacles to false
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	101	101	grid[row][col].set_potential(0);
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	104	104	or set to 0 this may be faster.
001c671a	f24	p0	2024-09-18 20:28:49	robotNav.cpp	116	122	char FieldElement::get_object(){\nreturn object;\n}\nvoid FieldElement::set_object(char obj){\nobject = obj;\n//compute_potential();\n}
001c671a	f24	p0	2024-09-18 20:28:49	testing.cpp	26	26	create new Field object
001c671a	f24	p0	2024-09-18 20:28:49	testing.cpp	49	49	value of potential field if (x,y) is within the map MAYBE GET POTENTIAL FUNCTION
001c671a	f24	p0	2024-09-18 20:28:49	testing.cpp	51	51	(x,y) are outside of map
001c671a	f24	p0	2024-09-18 20:28:49	testing.cpp	61	61	map as not been created yet
001c671a	f24	p0	2024-09-18 20:32:01	Field.h	1	1	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 20:32:01	Field.h	10	10	constructor
001c671a	f24	p0	2024-09-18 20:32:01	Field.h	13	13	deconstructor which deletes the array created by create_field
001c671a	f24	p0	2024-09-18 20:32:01	Field.h	16	16	grid dimension variables - only ever accessed by functions of this class
001c671a	f24	p0	2024-09-18 20:32:01	Field.h	22	22	functions
001c671a	f24	p0	2024-09-18 20:32:01	Field.h	30	30	only ever called when k is updated or object is added - encapsulated within other functions. no need to be public.
001c671a	f24	p0	2024-09-18 20:32:01	Field.h	34	34	K is private to ensure that set_K checks for valid value
001c671a	f24	p0	2024-09-18 20:32:01	FieldElement.h	1	1	ensures the header is only compiled once
001c671a	f24	p0	2024-09-18 20:32:01	FieldElement.h	4	4	definitions for the potentialField class
001c671a	f24	p0	2024-09-18 20:32:01	FieldElement.h	11	11	constructor
001c671a	f24	p0	2024-09-18 20:32:01	FieldElement.h	14	14	potential: getter and setter
001c671a	f24	p0	2024-09-18 20:32:01	FieldElement.h	22	23	only one var for potential since acccording to the formula, potential x and potential y are always the same.\nprivate because users should not be able to edit this directly. it is computed from other values.
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	9	9	constructor definition for creating the grid
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	30	30	constructor definition for creating the elements of the grid - initializes variables
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	43	44	must compute and set for all cells\ninitializes potential of all cells to 0
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	47	47	Reset potential for each cell
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	54	54	if obstacle is present, add potential to all cells that do not have a goal or obstacle.
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	69	69	if goal is present, subtract potential from the specified location
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	87	87	function to add an obstacle at a user-inputted postition
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	93	93	function called when the grid should be cleared
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	95	95	checks through every object of the array - sets all goals and obstacles to false
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	101	101	grid[row][col].set_potential(0);
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	104	104	or set to 0 this may be faster.
001c671a	f24	p0	2024-09-18 20:32:01	robotNav.cpp	116	122	char FieldElement::get_object(){\nreturn object;\n}\nvoid FieldElement::set_object(char obj){\nobject = obj;\n//compute_potential();\n}
001c671a	f24	p0	2024-09-18 20:32:01	testing.cpp	26	26	create new Field object
001c671a	f24	p0	2024-09-18 20:32:01	testing.cpp	49	49	value of potential field if (x,y) is within the map MAYBE GET POTENTIAL FUNCTION
001c671a	f24	p0	2024-09-18 20:32:01	testing.cpp	51	51	(x,y) are outside of map
001c671a	f24	p0	2024-09-18 20:32:01	testing.cpp	61	61	map as not been created yet
001c671a	f24	p0	2024-09-19 22:45:41	Field.h	1	1	definitions for the potentialField class
001c671a	f24	p0	2024-09-19 22:45:41	Field.h	10	10	constructor
001c671a	f24	p0	2024-09-19 22:45:41	Field.h	13	13	deconstructor which deletes the array created by create_field
001c671a	f24	p0	2024-09-19 22:45:41	Field.h	16	16	grid dimension variables - only ever accessed by functions of this class
001c671a	f24	p0	2024-09-19 22:45:41	Field.h	22	22	functions
001c671a	f24	p0	2024-09-19 22:45:41	Field.h	30	30	only ever called when k is updated or object is added - encapsulated within other functions. no need to be public.
001c671a	f24	p0	2024-09-19 22:45:41	Field.h	34	34	K is private to ensure that set_K checks for valid value
001c671a	f24	p0	2024-09-19 22:45:41	FieldElement.h	1	1	ensures the header is only compiled once
001c671a	f24	p0	2024-09-19 22:45:41	FieldElement.h	4	4	definitions for the potentialField class
001c671a	f24	p0	2024-09-19 22:45:41	FieldElement.h	11	11	constructor
001c671a	f24	p0	2024-09-19 22:45:41	FieldElement.h	14	14	potential: getter and setter
001c671a	f24	p0	2024-09-19 22:45:41	FieldElement.h	22	23	only one var for potential since acccording to the formula, potential x and potential y are always the same.\nprivate because users should not be able to edit this directly. it is computed from other values.
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	9	9	constructor definition for creating the grid
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	30	30	constructor definition for creating the elements of the grid - initializes variables
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	44	45	must compute and set for all cells\ninitializes potential of all cells to 0
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	48	48	Reset potential for each cell
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	55	55	if obstacle is present, add potential to all cells that do not have a goal or obstacle.
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	70	70	if goal is present, subtract potential from the specified location
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	88	88	function to add an obstacle at a user-inputted postition
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	94	94	function called when the grid should be cleared
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	96	96	checks through every object of the array - sets all goals and obstacles to false
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	102	102	grid[row][col].set_potential(0);
001c671a	f24	p0	2024-09-19 22:45:41	robotNav.cpp	105	105	or set to 0 this may be faster.
001c671a	f24	p0	2024-09-19 22:45:41	testing.cpp	26	26	create new Field object
001c671a	f24	p0	2024-09-19 22:45:41	testing.cpp	49	49	value of potential field if (x,y) is within the map MAYBE GET POTENTIAL FUNCTION
001c671a	f24	p0	2024-09-19 22:45:41	testing.cpp	51	51	(x,y) are outside of map
001c671a	f24	p0	2024-09-19 22:45:41	testing.cpp	61	61	map as not been created yet
001c671a	f24	p0	2024-09-23 17:41:03	Field.h	1	1	definitions for the potentialField class
001c671a	f24	p0	2024-09-23 17:41:03	Field.h	10	10	constructor
001c671a	f24	p0	2024-09-23 17:41:03	Field.h	13	13	deconstructor which deletes the array created by create_field
001c671a	f24	p0	2024-09-23 17:41:03	Field.h	16	16	grid dimension variables - only ever accessed by functions of this class
001c671a	f24	p0	2024-09-23 17:41:03	Field.h	22	22	functions
001c671a	f24	p0	2024-09-23 17:41:03	Field.h	30	30	only ever called when k is updated or object is added - encapsulated within other functions. no need to be public.
001c671a	f24	p0	2024-09-23 17:41:03	Field.h	34	34	K is private to ensure that set_K checks for valid value
001c671a	f24	p0	2024-09-23 17:41:03	FieldElement.h	1	1	ensures the header is only compiled once
001c671a	f24	p0	2024-09-23 17:41:03	FieldElement.h	4	4	definitions for the potentialField class
001c671a	f24	p0	2024-09-23 17:41:03	FieldElement.h	11	11	constructor
001c671a	f24	p0	2024-09-23 17:41:03	FieldElement.h	14	14	potential: getter and setter
001c671a	f24	p0	2024-09-23 17:41:03	FieldElement.h	22	23	only one var for potential since acccording to the formula, potential x and potential y are always the same.\nprivate because users should not be able to edit this directly. it is computed from other values.
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	9	9	constructor definition for creating the grid
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	30	30	constructor definition for creating the elements of the grid - initializes variables
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	44	45	must compute and set for all cells\ninitializes potential of all cells to 0
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	48	48	Reset potential for each cell
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	55	55	if obstacle is present, add potential to all cells that do not have a goal or obstacle.
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	70	70	if goal is present, subtract potential from the specified location
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	88	88	function to add an obstacle at a user-inputted postition
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	94	94	function called when the grid should be cleared
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	96	96	checks through every object of the array - sets all goals and obstacles to false
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	102	102	grid[row][col].set_potential(0);
001c671a	f24	p0	2024-09-23 17:41:03	robotNav.cpp	105	105	or set to 0 this may be faster.
001c671a	f24	p0	2024-09-23 17:41:03	testing.cpp	26	26	create new Field object
001c671a	f24	p0	2024-09-23 17:41:03	testing.cpp	49	49	value of potential field if (x,y) is within the map MAYBE GET POTENTIAL FUNCTION
001c671a	f24	p0	2024-09-23 17:41:03	testing.cpp	51	51	(x,y) are outside of map
001c671a	f24	p0	2024-09-23 17:41:03	testing.cpp	61	61	map as not been created yet
001c671a	f24	p0	2024-09-23 19:07:01	Field.h	1	1	definitions for the potentialField class
001c671a	f24	p0	2024-09-23 19:07:01	Field.h	10	10	constructor
001c671a	f24	p0	2024-09-23 19:07:01	Field.h	13	13	deconstructor which deletes the array created by create_field
001c671a	f24	p0	2024-09-23 19:07:01	Field.h	16	16	grid dimension variables - only ever accessed by functions of this class
001c671a	f24	p0	2024-09-23 19:07:01	Field.h	22	22	functions
001c671a	f24	p0	2024-09-23 19:07:01	Field.h	30	30	only ever called when k is updated or object is added - encapsulated within other functions. no need to be public.
001c671a	f24	p0	2024-09-23 19:07:01	Field.h	34	34	K is private to ensure that set_K checks for valid value
001c671a	f24	p0	2024-09-23 19:07:01	FieldElement.h	1	1	ensures the header is only compiled once
001c671a	f24	p0	2024-09-23 19:07:01	FieldElement.h	4	4	definitions for the potentialField class
001c671a	f24	p0	2024-09-23 19:07:01	FieldElement.h	11	11	constructor
001c671a	f24	p0	2024-09-23 19:07:01	FieldElement.h	14	14	potential: getter and setter
001c671a	f24	p0	2024-09-23 19:07:01	FieldElement.h	22	23	only one var for potential since acccording to the formula, potential x and potential y are always the same.\nprivate because users should not be able to edit this directly. it is computed from other values.
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	9	9	constructor definition for creating the grid
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	30	30	constructor definition for creating the elements of the grid - initializes variables
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	44	45	must compute and set for all cells\ninitializes potential of all cells to 0
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	48	48	Reset potential for each cell
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	55	55	if obstacle is present, add potential to all cells that do not have a goal or obstacle.
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	70	70	if goal is present, subtract potential from the specified location
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	88	88	function to add an obstacle at a user-inputted postition
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	94	94	function called when the grid should be cleared
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	96	96	checks through every object of the array - sets all goals and obstacles to false
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	102	102	grid[row][col].set_potential(0);
001c671a	f24	p0	2024-09-23 19:07:01	robotNav.cpp	105	105	or set to 0 this may be faster.
001c671a	f24	p0	2024-09-23 19:07:01	testing.cpp	26	26	create new Field object
001c671a	f24	p0	2024-09-23 19:07:01	testing.cpp	49	49	value of potential field if (x,y) is within the map MAYBE GET POTENTIAL FUNCTION
001c671a	f24	p0	2024-09-23 19:07:01	testing.cpp	51	51	(x,y) are outside of map
001c671a	f24	p0	2024-09-23 19:07:01	testing.cpp	61	61	map as not been created yet
006d3144	f24	p0	2024-09-13 12:27:22	Dynamic2DArray.hpp	18	18	Setters and Getters
006d3144	f24	p0	2024-09-13 12:27:22	Dynamic2DArray.hpp	25	25	DYNAMIC_2D_ARRAY_HPP
006d3144	f24	p0	2024-09-13 12:27:22	PotentialFieldMap.cpp	70	70	Return 0 if we're exactly on the point
006d3144	f24	p0	2024-09-13 12:27:22	PotentialFieldMap.cpp	76	76	Obstacles have positive potential
006d3144	f24	p0	2024-09-13 12:27:22	PotentialFieldMap.cpp	83	83	Clear the potential field
006d3144	f24	p0	2024-09-13 12:27:22	PotentialFieldMap.hpp	26	26	POTENTIAL_FIELD_MAP_HPP
006d3144	f24	p0	2024-09-13 13:28:08	Dynamic2DArray.hpp	18	18	Setters and Getters
006d3144	f24	p0	2024-09-13 13:28:08	Dynamic2DArray.hpp	25	25	DYNAMIC_2D_ARRAY_HPP
006d3144	f24	p0	2024-09-13 13:28:08	PotentialFieldMap.cpp	70	70	Return 0 if we're exactly on the point
006d3144	f24	p0	2024-09-13 13:28:08	PotentialFieldMap.cpp	76	76	Obstacles have positive potential
006d3144	f24	p0	2024-09-13 13:28:08	PotentialFieldMap.cpp	83	83	Clear the potential field
006d3144	f24	p0	2024-09-13 13:28:08	PotentialFieldMap.hpp	26	26	POTENTIAL_FIELD_MAP_HPP
006d3144	f24	p0	2024-09-13 13:46:45	Dynamic2DArray.hpp	18	18	Setters and Getters
006d3144	f24	p0	2024-09-13 13:46:45	Dynamic2DArray.hpp	25	25	DYNAMIC_2D_ARRAY_HPP
006d3144	f24	p0	2024-09-13 13:46:45	PotentialFieldMap.cpp	70	70	Return 0 if we're exactly on the point
006d3144	f24	p0	2024-09-13 13:46:45	PotentialFieldMap.cpp	76	76	Obstacles have positive potential
006d3144	f24	p0	2024-09-13 13:46:45	PotentialFieldMap.cpp	83	83	Clear the potential field
006d3144	f24	p0	2024-09-13 13:46:45	PotentialFieldMap.hpp	26	26	POTENTIAL_FIELD_MAP_HPP
006d3144	f24	p0	2024-09-21 03:05:18	Dynamic2DArray.hpp	18	18	Setters and Getters
006d3144	f24	p0	2024-09-21 03:05:18	Dynamic2DArray.hpp	25	25	DYNAMIC_2D_ARRAY_HPP
006d3144	f24	p0	2024-09-21 03:05:18	PotentialFieldMap.cpp	26	26	If the point type is changing or it's a new point, update the potential
006d3144	f24	p0	2024-09-21 03:05:18	PotentialFieldMap.cpp	28	28	If there was an existing point, remove its potential first
006d3144	f24	p0	2024-09-21 03:05:18	PotentialFieldMap.cpp	33	33	Add the potential for the new point
006d3144	f24	p0	2024-09-21 03:05:18	PotentialFieldMap.cpp	37	37	If it's the same type, do nothing (this handles duplicates)
006d3144	f24	p0	2024-09-21 03:05:18	PotentialFieldMap.cpp	47	47	Subtract if removing
006d3144	f24	p0	2024-09-21 03:05:18	PotentialFieldMap.cpp	99	99	Potential is zero at the point itself
006d3144	f24	p0	2024-09-21 03:05:18	PotentialFieldMap.cpp	108	108	Obstacles have positive potential
006d3144	f24	p0	2024-09-21 03:05:18	PotentialFieldMap.hpp	26	26	POTENTIAL_FIELD_MAP_HPP
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.cpp	3	3	Constructor
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.cpp	7	7	Destructor
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.cpp	14	14	Clear the array and free memory
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.cpp	28	28	Create a new 2D array of size rows x cols
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.cpp	40	40	Get the value at position (row, col)
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.cpp	50	50	Set the value at position (row, col)
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.cpp	60	60	Explicit template instantiations
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.hpp	7	9	Pointer to the 2D array\nNumber of rows\nNumber of columns
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.hpp	12	12	Constructor and destructor
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.hpp	16	16	Create a new 2D array of size rows x cols
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.hpp	19	19	Clear the array and free memory
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.hpp	22	26	Setters and Getters\nGet value at (row, col)\nSet value at (row, col)\nGet number of rows\nGet number of columns
006d3144	f24	p0	2024-09-22 09:48:57	Dynamic2DArray.hpp	29	29	DYNAMIC_2D_ARRAY_HPP
006d3144	f24	p0	2024-09-22 09:48:57	main.cpp	17	17	Main loop to process commands
006d3144	f24	p0	2024-09-22 09:48:57	main.cpp	20	20	Create a new map of size N x M
006d3144	f24	p0	2024-09-22 09:48:57	main.cpp	27	27	Add a new goal or obstacle at position (X,Y)
006d3144	f24	p0	2024-09-22 09:48:57	main.cpp	37	37	Get the potential at position (X,Y)
006d3144	f24	p0	2024-09-22 09:48:57	main.cpp	47	47	Clear the map if it exists
006d3144	f24	p0	2024-09-22 09:48:57	main.cpp	57	57	Update the K value
006d3144	f24	p0	2024-09-22 09:48:57	main.cpp	66	66	Exit the program
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	6	6	Constructor
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	9	9	Destructor
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	12	12	Create a new potential field map of size N x M
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	21	21	Add or update a point (goal or obstacle) in the map
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	30	30	If the point type is changing or it's a new point, update the potential
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	32	32	If there was an existing point, remove its potential first
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	37	37	Add the potential for the new point
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	41	41	If it's the same type, do nothing (this handles duplicates)
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	46	46	Update the potential field for a single point
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	52	52	Subtract if removing
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	65	65	Get the potential at a specific position
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	74	74	Clear the entire map
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	85	85	Update the K value and recalculate potentials
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	105	105	Compute the potential for a single point
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	108	108	Potential is zero at the point itself
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.cpp	117	117	Obstacles have positive potential
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	8	11	X component of the potential field\nY component of the potential field\nMap of points (goals and obstacles)\nConstant for potential field calculation
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	13	13	Compute potential for a single point
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	16	16	Update potential field for a single point
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	20	20	Constructor and destructor
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	24	24	Create a new map of size N x M
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	27	27	Add or update a point (goal or obstacle) in the map
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	30	30	Get the potential at a specific position
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	33	33	Clear the entire map
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	36	36	Update the K value
006d3144	f24	p0	2024-09-22 09:48:57	PotentialFieldMap.hpp	40	40	POTENTIAL_FIELD_MAP_HPP
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	7	7	Change to store double values
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	13	13	Clear previous map memory (if any) before reallocating
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	22	22	Free inner-most arrays
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	24	24	Free middle arrays
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	26	26	Free outer array
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	32	32	Free previous memory if map exists
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	35	35	Set new dimensions
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	40	41	Allocate memory for the new 3D map array\nNow a 3D array of doubles
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	47	47	Initialize potentials to ⟨0.0, 0.0⟩
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	55	55	Add a goal (G) or obstacle (O) at position (xG, yG)
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	64	64	Store the type of point
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	94	94	Output the potentials at position (x, y)
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	136	136	Skip goals and obstacles
0088d789	f24	p0	2024-09-23 15:33:58	main3.cpp	146	146	Destructor to automatically clear memory when the Map object is destroyed
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	4	4	Including Libraries
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	14	14	Used To store the map, and its properties
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	21	21	Will be used to redo the whole map with the updated K value.
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	27	27	This function clears the allocated memory for the map.
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	30	30	This creates a map of size N x M.
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	33	33	This adds a Goal or Obstacle at position (xG, yG). (Note T tells if Goal or Obstacle).
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	36	36	This gives back the potential at (x, y).
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	39	39	This sets all the map potetials to 0.
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	42	42	This updates the value of K used in potential calculations.
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	45	45	This is a Destructor to automatically clear memory when the Map object is destroyed
0088d789	f24	p0	2024-09-23 15:33:58	main3.hpp	51	51	MAIN_H
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	3	3	Clears the allocated memory for the map.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	8	8	Loop through each row.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	11	11	Loop through each column in the current row.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	14	14	Delete the innermost array for potentials and point type.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	16	16	Delete the array of pointers for columns.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	18	19	Delete the array of pointers for rows.\nSet map pointer to nullptr to avoid dangling pointer.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	23	23	Destructor to automatically clear memory when the Map object is destroyed.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	29	29	Creates a new map of size N x M.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	32	32	Validate the dimensions.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	35	35	Return failure if dimensions are invalid.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	38	38	Clear any existing map data.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	41	44	Set the map dimensions.\nNumber of rows (height).\nNumber of columns (width).\nInitialize K to 1.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	46	47	Allocate memory for the map.\nAllocate array of pointers for rows.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	50	50	Allocate array of pointers for columns in each row.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	53	54	Allocate array to store potentials and point type.\nInitialize potentials and point type to 0.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	59	59	Return success.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	62	62	Adds a Goal ('G') or Obstacle ('O') at position (xG, yG).
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	65	65	Check if the map exists and the coordinates are within bounds.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	68	68	Return failure if map doesn't exist or coordinates are out of bounds.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	71	72	Set the point type at the specified position.\n-1 for goal, 1 for obstacle.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	74	74	Recompute the potentials across the map due to the new point.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	77	77	Return success.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	80	80	Recomputes the potentials across the entire map.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	83	83	Reset all potentials to zero before recomputing.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	88	89	Reset potential value.\nDuplicate potential value (since potential is scalar here).
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	93	93	Loop through all positions to calculate potentials due to goals and obstacles.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	98	98	Get the point type at (xG, yG).
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	102	102	Skip if there's no goal or obstacle at this position.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	105	105	Compute potentials due to this point at all other positions.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	112	112	Skip the source point itself.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	115	115	Calculate the distance from the source point to the current position.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	122	122	Avoid division by zero.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	125	125	Calculate the potential contribution.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	128	128	Add the potential to the total potential at the current position.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	130	130	Duplicate value for consistency.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	137	137	Outputs the potentials at position (x, y).
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	140	140	Check if the map exists and the coordinates are within bounds.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	143	143	Return failure if map doesn't exist or coordinates are out of bounds.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	146	146	Output the potentials at the specified position.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	148	148	Return success.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	151	151	Clears all potentials and point types in the map.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	156	156	Return failure if map doesn't exist.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	159	159	Reset potentials and point types to zero.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	164	166	Reset potential value.\nDuplicate potential value.\nReset point type.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	170	170	Return success.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	173	173	Updates the value of K and recomputes potentials.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	176	176	Check if the map exists and the new K value is positive.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	179	179	Return failure if map doesn't exist or newK is invalid.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	182	182	Update K to the new value.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	184	184	Recompute potentials with the updated K value.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	187	187	Return success.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	192	193	Variable to store user input.\nCreate a Map object.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	195	195	Read commands until the end of input.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	201	202	Read dimensions.\nCreate the map.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	205	205	Output success.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	209	209	Output failure.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	216	217	Read point type and coordinates.\nAdd the point to the map.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	220	220	Output success.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	224	224	Output failure.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	230	231	Read coordinates.\nOutput potentials at the position.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	234	234	Output failure if invalid.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	236	236	Potentials are printed inside MOVE when successful.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	240	240	Clear the map.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	243	243	Output success.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	247	247	Output failure.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	253	254	Read new K value.\nUpdate K and recompute potentials.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	257	257	Output success.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	261	261	Output failure.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	266	266	Exit the loop if "EXIT" command is received.
0088d789	f24	p0	2024-09-23 17:12:27	main3.cpp	270	270	End of the program.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	7	7	The Map class represents the 2D grid environment for potential field navigation.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	11	14	3D array to store potentials and point types.\nmap[y][x][0]: Potential at position (x, y) due to goals and obstacles.\nmap[y][x][1]: Duplicate of the potential (since potential is scalar in this context).\nmap[y][x][2]: Point type at position (x, y): -1 for goal, 1 for obstacle, 0 for empty.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	17	19	Number of rows (height of the map).\nNumber of columns (width of the map).\nConstant used in potential calculations.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	21	21	Helper function to clear allocated memory for the map.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	24	24	Recomputes the potentials across the entire map after any update.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	28	28	Default constructor.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	31	31	Destructor to clean up allocated memory.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	34	34	Creates a new map of size N x M.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	37	37	Adds a Goal ('G') or Obstacle ('O') at position (xG, yG).
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	40	40	Outputs the potentials at position (x, y).
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	43	43	Clears all potentials and point types in the map.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	46	46	Updates the value of K and recomputes potentials.
0088d789	f24	p0	2024-09-23 17:12:27	main3.hpp	50	50	MAIN3_HPP
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	3	3	Clears the allocated memory for the map.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	8	8	Loop through each row.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	11	11	Loop through each column in the current row.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	14	14	Delete the innermost array for potentials and point type.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	16	16	Delete the array of pointers for columns.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	18	19	Delete the array of pointers for rows.\nSet map pointer to nullptr to avoid dangling pointer.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	23	23	Destructor to automatically clear memory when the Map object is destroyed.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	29	29	Creates a new map of size N x M.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	32	32	Validate the dimensions.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	35	35	Return failure if dimensions are invalid.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	38	38	Clear any existing map data.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	41	44	Set the map dimensions.\nNumber of rows (height).\nNumber of columns (width).\nInitialize K to 1.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	46	47	Allocate memory for the map.\nAllocate array of pointers for rows.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	50	50	Allocate array of pointers for columns in each row.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	53	54	Allocate array to store potentials and point type.\nInitialize potentials and point type to 0.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	59	59	Return success.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	62	62	Adds a Goal ('G') or Obstacle ('O') at position (xG, yG).
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	65	65	Check if the map exists and the coordinates are within bounds.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	68	68	Return failure if map doesn't exist or coordinates are out of bounds.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	71	72	Set the point type at the specified position.\n-1 for goal, 1 for obstacle.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	74	74	Recompute the potentials across the map due to the new point.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	77	77	Return success.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	80	80	Recomputes the potentials across the entire map.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	83	83	Reset all potentials to zero before recomputing.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	88	89	Reset potential value.\nDuplicate potential value (since potential is scalar here).
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	93	93	Loop through all positions to calculate potentials due to goals and obstacles.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	98	98	Get the point type at (xG, yG).
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	102	102	Skip if there's no goal or obstacle at this position.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	105	105	Compute potentials due to this point at all other positions.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	112	112	Skip the source point itself.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	115	115	Calculate the distance from the source point to the current position.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	122	122	Avoid division by zero.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	125	125	Calculate the potential contribution.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	128	128	Add the potential to the total potential at the current position.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	130	130	Duplicate value for consistency.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	137	137	Outputs the potentials at position (x, y).
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	140	140	Check if the map exists and the coordinates are within bounds.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	143	143	Return failure if map doesn't exist or coordinates are out of bounds.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	146	146	Output the potentials at the specified position.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	148	148	Return success.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	151	151	Clears all potentials and point types in the map.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	156	156	Return failure if map doesn't exist.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	159	159	Reset potentials and point types to zero.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	164	166	Reset potential value.\nDuplicate potential value.\nReset point type.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	170	170	Return success.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	173	173	Updates the value of K and recomputes potentials.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	176	176	Check if the map exists and the new K value is positive.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	179	179	Return failure if map doesn't exist or newK is invalid.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	182	182	Update K to the new value.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	184	184	Recompute potentials with the updated K value.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	187	187	Return success.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	192	193	Variable to store user input.\nCreate a Map object.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	195	195	Read commands until the end of input.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	201	202	Read dimensions.\nCreate the map.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	205	205	Output success.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	209	209	Output failure.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	216	217	Read point type and coordinates.\nAdd the point to the map.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	220	220	Output success.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	224	224	Output failure.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	230	231	Read coordinates.\nOutput potentials at the position.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	234	234	Output failure if invalid.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	236	236	Potentials are printed inside MOVE when successful.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	240	240	Clear the map.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	243	243	Output success.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	247	247	Output failure.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	253	254	Read new K value.\nUpdate K and recompute potentials.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	257	257	Output success.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	261	261	Output failure.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	266	266	Exit the loop if "EXIT" command is received.
0088d789	f24	p0	2024-09-23 21:33:46	main3.cpp	270	270	End of the program.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	7	7	The Map class represents the 2D grid environment for potential field navigation.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	11	14	3D array to store potentials and point types.\nmap[y][x][0]: Potential at position (x, y) due to goals and obstacles.\nmap[y][x][1]: Duplicate of the potential (since potential is scalar in this context).\nmap[y][x][2]: Point type at position (x, y): -1 for goal, 1 for obstacle, 0 for empty.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	17	19	Number of rows (height of the map).\nNumber of columns (width of the map).\nConstant used in potential calculations.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	21	21	Helper function to clear allocated memory for the map.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	24	24	Recomputes the potentials across the entire map after any update.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	28	28	Default constructor.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	31	31	Destructor to clean up allocated memory.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	34	34	Creates a new map of size N x M.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	37	37	Adds a Goal ('G') or Obstacle ('O') at position (xG, yG).
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	40	40	Outputs the potentials at position (x, y).
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	43	43	Clears all potentials and point types in the map.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	46	46	Updates the value of K and recomputes potentials.
0088d789	f24	p0	2024-09-23 21:33:46	main3.hpp	50	50	MAIN3_HPP
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	3	3	Clears the allocated memory for the map.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	8	8	Loop through each row.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	11	11	Loop through each column in the current row.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	14	14	Delete the innermost array for potentials and point type.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	16	16	Delete the array of pointers for columns.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	18	19	Delete the array of pointers for rows.\nSet map pointer to nullptr to avoid dangling pointer.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	23	23	Destructor to automatically clear memory when the Map object is destroyed.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	29	29	Creates a new map of size N x M.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	32	32	Validate the dimensions.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	35	35	Return failure if dimensions are invalid.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	38	38	Clear any existing map data.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	41	44	Set the map dimensions.\nNumber of rows (height).\nNumber of columns (width).\nInitialize K to 1.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	46	47	Allocate memory for the map.\nAllocate array of pointers for rows.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	50	50	Allocate array of pointers for columns in each row.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	53	54	Allocate array to store potentials and point type.\nInitialize potentials and point type to 0.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	59	59	Return success.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	62	62	Adds a Goal ('G') or Obstacle ('O') at position (xG, yG).
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	65	65	Check if the map exists and the coordinates are within bounds.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	68	68	Return failure if map doesn't exist or coordinates are out of bounds.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	71	72	Set the point type at the specified position.\n-1 for goal, 1 for obstacle.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	74	74	Recompute the potentials across the map due to the new point.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	77	77	Return success.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	80	80	Recomputes the potentials across the entire map.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	83	83	Reset all potentials to zero before recomputing.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	88	89	Reset potential value.\nDuplicate potential value (since potential is scalar here).
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	93	93	Loop through all positions to calculate potentials due to goals and obstacles.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	98	98	Get the point type at (xG, yG).
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	102	102	Skip if there's no goal or obstacle at this position.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	105	105	Compute potentials due to this point at all other positions.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	112	112	Skip the source point itself.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	115	115	Calculate the distance from the source point to the current position.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	122	122	Avoid division by zero.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	125	125	Calculate the potential contribution.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	128	128	Add the potential to the total potential at the current position.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	130	130	Duplicate value for consistency.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	137	137	Outputs the potentials at position (x, y).
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	140	140	Check if the map exists and the coordinates are within bounds.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	143	143	Return failure if map doesn't exist or coordinates are out of bounds.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	146	146	Output the potentials at the specified position.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	148	148	Return success.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	151	151	Clears all potentials and point types in the map.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	156	156	Return failure if map doesn't exist.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	159	159	Reset potentials and point types to zero.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	164	166	Reset potential value.\nDuplicate potential value.\nReset point type.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	170	170	Return success.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	173	173	Updates the value of K and recomputes potentials.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	176	176	Check if the map exists and the new K value is positive.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	179	179	Return failure if map doesn't exist or newK is invalid.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	182	182	Update K to the new value.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	184	184	Recompute potentials with the updated K value.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	187	187	Return success.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	192	193	Variable to store user input.\nCreate a Map object.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	195	195	Read commands until the end of input.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	201	202	Read dimensions.\nCreate the map.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	205	205	Output success.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	209	209	Output failure.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	216	217	Read point type and coordinates.\nAdd the point to the map.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	220	220	Output success.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	224	224	Output failure.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	230	231	Read coordinates.\nOutput potentials at the position.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	234	234	Output failure if invalid.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	236	236	Potentials are printed inside MOVE when successful.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	240	240	Clear the map.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	243	243	Output success.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	247	247	Output failure.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	253	254	Read new K value.\nUpdate K and recompute potentials.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	257	257	Output success.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	261	261	Output failure.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	266	266	Exit the loop if "EXIT" command is received.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.cpp	270	270	End of the program.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	7	7	The Map class represents the 2D grid environment for potential field navigation.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	11	14	3D array to store potentials and point types.\nmap[y][x][0]: Potential at position (x, y) due to goals and obstacles.\nmap[y][x][1]: Duplicate of the potential (since potential is scalar in this context).\nmap[y][x][2]: Point type at position (x, y): -1 for goal, 1 for obstacle, 0 for empty.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	17	19	Number of rows (height of the map).\nNumber of columns (width of the map).\nConstant used in potential calculations.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	21	21	Helper function to clear allocated memory for the map.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	24	24	Recomputes the potentials across the entire map after any update.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	28	28	Default constructor.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	31	31	Destructor to clean up allocated memory.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	34	34	Creates a new map of size N x M.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	37	37	Adds a Goal ('G') or Obstacle ('O') at position (xG, yG).
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	40	40	Outputs the potentials at position (x, y).
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	43	43	Clears all potentials and point types in the map.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	46	46	Updates the value of K and recomputes potentials.
0088d789	f24	p0	2024-09-23 21:43:26	bd3e9ec3805fef546cd08eef747ace50.hpp	50	50	MAIN3_HPP
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	3	3	Clears the allocated memory for the map.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	8	8	Loop through each row.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	11	11	Loop through each column in the current row.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	14	14	Delete the innermost array for potentials and point type.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	16	16	Delete the array of pointers for columns.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	18	19	Delete the array of pointers for rows.\nSet map pointer to nullptr to avoid dangling pointer.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	23	23	Destructor to automatically clear memory when the Map object is destroyed.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	29	29	Creates a new map of size N x M.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	32	32	Validate the dimensions.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	35	35	Return failure if dimensions are invalid.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	38	38	Clear any existing map data.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	41	44	Set the map dimensions.\nNumber of rows (height).\nNumber of columns (width).\nInitialize K to 1.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	46	47	Allocate memory for the map.\nAllocate array of pointers for rows.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	50	50	Allocate array of pointers for columns in each row.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	53	54	Allocate array to store potentials and point type.\nInitialize potentials and point type to 0.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	59	59	Return success.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	62	62	Adds a Goal ('G') or Obstacle ('O') at position (xG, yG).
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	65	65	Check if the map exists and the coordinates are within bounds.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	68	68	Return failure if map doesn't exist or coordinates are out of bounds.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	71	72	Set the point type at the specified position.\n-1 for goal, 1 for obstacle.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	74	74	Recompute the potentials across the map due to the new point.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	77	77	Return success.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	80	80	Recomputes the potentials across the entire map.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	83	83	Reset all potentials to zero before recomputing.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	88	89	Reset potential value.\nDuplicate potential value (since potential is scalar here).
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	93	93	Loop through all positions to calculate potentials due to goals and obstacles.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	98	98	Get the point type at (xG, yG).
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	102	102	Skip if there's no goal or obstacle at this position.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	105	105	Compute potentials due to this point at all other positions.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	112	112	Skip the source point itself.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	115	115	Calculate the distance from the source point to the current position.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	122	122	Avoid division by zero.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	125	125	Calculate the potential contribution.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	128	128	Add the potential to the total potential at the current position.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	130	130	Duplicate value for consistency.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	137	137	Outputs the potentials at position (x, y).
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	140	140	Check if the map exists and the coordinates are within bounds.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	143	143	Return failure if map doesn't exist or coordinates are out of bounds.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	146	146	Output the potentials at the specified position.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	148	148	Return success.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	151	151	Clears all potentials and point types in the map.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	156	156	Return failure if map doesn't exist.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	159	159	Reset potentials and point types to zero.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	164	166	Reset potential value.\nDuplicate potential value.\nReset point type.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	170	170	Return success.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	173	173	Updates the value of K and recomputes potentials.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	176	176	Check if the map exists and the new K value is positive.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	179	179	Return failure if map doesn't exist or newK is invalid.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	182	182	Update K to the new value.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	184	184	Recompute potentials with the updated K value.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	187	187	Return success.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	192	193	Variable to store user input.\nCreate a Map object.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	195	195	Read commands until the end of input.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	201	202	Read dimensions.\nCreate the map.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	205	205	Output success.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	209	209	Output failure.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	216	217	Read point type and coordinates.\nAdd the point to the map.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	220	220	Output success.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	224	224	Output failure.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	230	231	Read coordinates.\nOutput potentials at the position.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	234	234	Output failure if invalid.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	236	236	Potentials are printed inside MOVE when successful.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	240	240	Clear the map.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	243	243	Output success.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	247	247	Output failure.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	253	254	Read new K value.\nUpdate K and recompute potentials.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	257	257	Output success.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	261	261	Output failure.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	266	266	Exit the loop if "EXIT" command is received.
0088d789	f24	p0	2024-09-23 22:02:26	main3.cpp	270	270	End of the program.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	7	7	The Map class represents the 2D grid environment for potential field navigation.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	11	14	3D array to store potentials and point types.\nmap[y][x][0]: Potential at position (x, y) due to goals and obstacles.\nmap[y][x][1]: Duplicate of the potential (since potential is scalar in this context).\nmap[y][x][2]: Point type at position (x, y): -1 for goal, 1 for obstacle, 0 for empty.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	17	19	Number of rows (height of the map).\nNumber of columns (width of the map).\nConstant used in potential calculations.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	21	21	Helper function to clear allocated memory for the map.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	24	24	Recomputes the potentials across the entire map after any update.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	28	28	Default constructor.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	31	31	Destructor to clean up allocated memory.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	34	34	Creates a new map of size N x M.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	37	37	Adds a Goal ('G') or Obstacle ('O') at position (xG, yG).
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	40	40	Outputs the potentials at position (x, y).
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	43	43	Clears all potentials and point types in the map.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	46	46	Updates the value of K and recomputes potentials.
0088d789	f24	p0	2024-09-23 22:02:26	main3.hpp	50	50	MAIN3_HPP
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	1	5	ECE 250 PROJECT 0\nAuthor: Erik Tsai\nDate: Sep 12, 2024\n\ngrid class logic
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	12	12	constructor
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	32	32	destructor
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	42	42	newGoal method
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	75	75	newObstacle method
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	107	107	move method
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	116	116	clearGrid method
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	127	127	deleteGoal method
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	143	143	deleteObstacle method
00c6b719	f24	p0	2024-09-20 19:31:19	grid.cpp	159	159	updateGrid method
00c6b719	f24	p0	2024-09-20 19:31:19	grid.h	1	5	ECE 250 PROJECT 0\nAuthor: Erik Tsai\nDate: Sep 12, 2024\n\ngrid class headerfile
00c6b719	f24	p0	2024-09-20 19:31:19	grid.h	21	21	constructor
00c6b719	f24	p0	2024-09-20 19:31:19	grid.h	24	24	destructor
00c6b719	f24	p0	2024-09-20 19:31:19	grid.h	27	27	member functions
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	1	5	ECE 250 PROJECT 0\nAuthor: Erik Tsai\nDate: Sep 12, 2024\n\nmain
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	14	14	declared pointer so the program knows if a grid has been created or not
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	18	18	while loop runs until exit is called
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	23	23	CREATE CALL
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	34	34	POINT CALL
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	47	47	MOVE CALL
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	54	54	CLEAR CALL
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	64	64	UPDATE CALL
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	72	72	EXIT CALL
00c6b719	f24	p0	2024-09-20 19:31:19	main.cpp	75	75	DEALLOCATE LAST GRID
01396cb7	f24	p0	2024-09-22 22:40:53	Grid.hpp	3	3	constructor
01396cb7	f24	p0	2024-09-22 22:40:53	Grid.hpp	6	6	destructor
01396cb7	f24	p0	2024-09-22 22:40:53	Grid.hpp	9	9	access
01396cb7	f24	p0	2024-09-22 22:40:53	Grid.hpp	12	12	REMOVE LATER
01396cb7	f24	p0	2024-09-22 22:40:53	Grid.hpp	15	15	calc field
01396cb7	f24	p0	2024-09-22 22:40:53	Grid.hpp	18	18	change k
01396cb7	f24	p0	2024-09-22 22:40:53	Grid.hpp	21	21	clear grid
01396cb7	f24	p0	2024-09-22 22:40:53	Grid.hpp	24	24	getters
01396cb7	f24	p0	2024-09-22 22:40:53	Grid.hpp	29	29	k value
01396cb7	f24	p0	2024-09-22 22:42:26	Grid.hpp	3	3	constructor
01396cb7	f24	p0	2024-09-22 22:42:26	Grid.hpp	6	6	destructor
01396cb7	f24	p0	2024-09-22 22:42:26	Grid.hpp	9	9	access
01396cb7	f24	p0	2024-09-22 22:42:26	Grid.hpp	12	12	REMOVE LATER
01396cb7	f24	p0	2024-09-22 22:42:26	Grid.hpp	15	15	calc field
01396cb7	f24	p0	2024-09-22 22:42:26	Grid.hpp	18	18	change k
01396cb7	f24	p0	2024-09-22 22:42:26	Grid.hpp	21	21	clear grid
01396cb7	f24	p0	2024-09-22 22:42:26	Grid.hpp	24	24	getters
01396cb7	f24	p0	2024-09-22 22:42:26	Grid.hpp	29	29	k value
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	6	9	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nNumber of points added so far
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	21	21	Initialize all potentials to 0
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	34	34	Reset all potentials to 0 before recalculating
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	37	37	Reset potentials before recalculating
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	39	39	For each grid cell (i, j), we need to consider the impact of all points (goals and obstacles)
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	42	42	Traverse through all the points (goals and obstacles)
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	49	49	Determine whether it's a goal or an obstacle and set the factor
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	51	51	Goal exerts an attractive force (negative potential)
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	53	53	Obstacle exerts a repulsive force (positive potential)
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	55	55	Calculate the Euclidean distance between (i, j) and the point (x, y)
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	58	58	If the distance is non-zero, update the potential
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	63	70	After calculating potentials for all other points, set the fixed potentials for the goals and obstacles themselves\nfor (int k = 0; k < pointCount; ++k)\n{\nif (pointType[k] == 'G')\npotentials[pointX[k]][pointY[k]] = -1000;  // Set the goal's potential\nelse\npotentials[pointX[k]][pointY[k]] = 1000;   // Set the obstacle's potential\n}
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	75	75	Check if the point is within the grid
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	82	82	Add the new point (goal or obstacle) to the list
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	88	88	Recalculate the potential grid after adding the new goal/obstacle
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	96	96	Check if the robot is within the grid
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	103	103	Movement direction arrays
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	107	107	Start by assuming the current position is the best position
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	111	111	Check the four neighboring cells (up, down, left, right)
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	117	117	Check if the new cell is within the grid
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	119	119	Check if the new cell has a lower potential
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	128	128	Output the potential at the new best position with 6 decimal places
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	134	134	Clear the potential grid and remove all goals/obstacles
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	138	138	Reset the count of points (goals/obstacles)
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.cpp	149	149	Recalculate potentials with the new K
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	4	4	Maximum number of points (goals/obstacles) that can be added
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	9	11	Grid dimensions (N x M)\n2D array for storing potential values\nScaling factor for potential calculation
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	13	16	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nCount of added points (goals/obstacles)
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	18	18	Helper function to recalculate the potentials for the entire grid
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	22	22	Constructor: initializes the grid with given dimensions N x M
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	25	25	Destructor: frees up dynamically allocated memory
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	28	28	Function to add a goal ('G') or obstacle ('O') at a specific point
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	31	31	Function to move the robot based on potential field
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	34	34	Function to clear the grid and reset all potentials and points
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	37	37	Function to update the value of K and apply it to the potential calculation
02913a7c	f24	p0	2024-09-21 19:23:12	Grid.h	40	40	Function to print the current state of the grid (for debugging/testing)
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	6	9	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nNumber of points added so far
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	21	21	Initialize all potentials to 0
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	40	40	check if potential is null before deleting
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	47	47	Reset all potentials to 0 before recalculating
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	50	50	Reset potentials before recalculating
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	52	52	For each grid cell (i, j), we need to consider the impact of all points (goals and obstacles)
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	55	55	Traverse through all the points (goals and obstacles)
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	62	62	Determine whether it's a goal or an obstacle and set the factor
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	64	64	Goal exerts an attractive force (negative potential)
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	66	66	Obstacle exerts a repulsive force (positive potential)
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	68	68	Calculate the Euclidean distance between (i, j) and the point (x, y)
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	71	71	If the distance is non-zero, update the potential
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	76	83	After calculating potentials for all other points, set the fixed potentials for the goals and obstacles themselves\nfor (int k = 0; k < pointCount; ++k)\n{\nif (pointType[k] == 'G')\npotentials[pointX[k]][pointY[k]] = -1000;  // Set the goal's potential\nelse\npotentials[pointX[k]][pointY[k]] = 1000;   // Set the obstacle's potential\n}
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	88	88	Check if the point is within the grid
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	95	95	Add the new point (goal or obstacle) to the list
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	101	101	Recalculate the potential grid after adding the new goal/obstacle
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	109	109	Check if the robot is within the grid
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	116	116	Movement direction arrays
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	120	120	Start by assuming the current position is the best position
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	124	124	Check the four neighboring cells (up, down, left, right)
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	130	130	Check if the new cell is within the grid
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	132	132	Check if the new cell has a lower potential
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	141	141	Output the potential at the new best position with 6 decimal places
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	147	147	Clear the potential grid and remove all goals/obstacles
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	151	151	Reset the count of points (goals/obstacles)
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.cpp	181	181	Recalculate potentials with the new K
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	4	4	Maximum number of points (goals/obstacles) that can be added
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	9	11	Grid dimensions (N x M)\n2D array for storing potential values\nScaling factor for potential calculation
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	13	16	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nCount of added points (goals/obstacles)
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	18	18	Helper function to recalculate the potentials for the entire grid
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	22	22	Constructor: initializes the grid with given dimensions N x M
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	25	25	Destructor: frees up dynamically allocated memory
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	28	28	Function to add a goal ('G') or obstacle ('O') at a specific point
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	31	31	Function to move the robot based on potential field
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	34	34	Function to clear the grid and reset all potentials and points
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	37	37	Function to update the value of K and apply it to the potential calculation
02913a7c	f24	p0	2024-09-21 21:51:52	Grid.h	40	40	Function to print the current state of the grid (for debugging/testing)
02913a7c	f24	p0	2024-09-21 21:51:52	main.cpp	61	61	if (grid != nullptr)
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	6	9	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nNumber of points added so far
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	21	21	Initialize all potentials to 0
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	41	41	check if potential is null before deleting
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	48	48	Reset all potentials to 0 before recalculating
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	51	51	Reset potentials before recalculating
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	53	53	For each grid cell (i, j), we need to consider the impact of all points (goals and obstacles)
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	56	56	Traverse through all the points (goals and obstacles)
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	63	63	Determine whether it's a goal or an obstacle and set the factor
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	65	65	Goal exerts an attractive force (negative potential)
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	67	67	Obstacle exerts a repulsive force (positive potential)
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	69	69	Calculate the Euclidean distance between (i, j) and the point (x, y)
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	72	72	If the distance is non-zero, update the potential
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	77	84	After calculating potentials for all other points, set the fixed potentials for the goals and obstacles themselves\nfor (int k = 0; k < pointCount; ++k)\n{\nif (pointType[k] == 'G')\npotentials[pointX[k]][pointY[k]] = -1000;  // Set the goal's potential\nelse\npotentials[pointX[k]][pointY[k]] = 1000;   // Set the obstacle's potential\n}
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	89	89	Check if the point is within the grid
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	96	96	Add the new point (goal or obstacle) to the list
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	102	102	Recalculate the potential grid after adding the new goal/obstacle
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	110	110	Check if the robot is within the grid
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	117	117	Movement direction arrays
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	121	121	Start by assuming the current position is the best position
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	125	125	Check the four neighboring cells (up, down, left, right)
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	131	131	Check if the new cell is within the grid
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	133	133	Check if the new cell has a lower potential
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	142	142	Output the potential at the new best position with 6 decimal places
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	148	148	Clear the potential grid and remove all goals/obstacles
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	152	152	Reset the count of points (goals/obstacles)
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.cpp	182	182	Recalculate potentials with the new K
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	4	4	Maximum number of points (goals/obstacles) that can be added
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	9	11	Grid dimensions (N x M)\n2D array for storing potential values\nScaling factor for potential calculation
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	13	16	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nCount of added points (goals/obstacles)
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	18	18	Helper function to recalculate the potentials for the entire grid
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	22	22	Constructor: initializes the grid with given dimensions N x M
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	25	25	Destructor: frees up dynamically allocated memory
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	28	28	Function to add a goal ('G') or obstacle ('O') at a specific point
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	31	31	Function to move the robot based on potential field
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	34	34	Function to clear the grid and reset all potentials and points
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	37	37	Function to update the value of K and apply it to the potential calculation
02913a7c	f24	p0	2024-09-21 22:02:18	Grid.h	40	40	Function to print the current state of the grid (for debugging/testing)
02913a7c	f24	p0	2024-09-21 22:02:18	main.cpp	61	61	if (grid != nullptr)
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	6	9	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nNumber of points added so far
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	21	21	Initialize all potentials to 0
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	41	41	check if potential is null before deleting
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	48	48	Reset all potentials to 0 before recalculating
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	51	51	Reset potentials before recalculating
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	53	53	For each grid cell (i, j), we need to consider the impact of all points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	56	56	Traverse through all the points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	63	63	Determine whether it's a goal or an obstacle and set the factor
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	65	65	Goal exerts an attractive force (negative potential)
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	67	67	Obstacle exerts a repulsive force (positive potential)
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	69	69	Calculate the Euclidean distance between (i, j) and the point (x, y)
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	72	72	If the distance is non-zero, update the potential
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	77	84	After calculating potentials for all other points, set the fixed potentials for the goals and obstacles themselves\nfor (int k = 0; k < pointCount; ++k)\n{\nif (pointType[k] == 'G')\npotentials[pointX[k]][pointY[k]] = -1000;  // Set the goal's potential\nelse\npotentials[pointX[k]][pointY[k]] = 1000;   // Set the obstacle's potential\n}
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	89	89	Check if the point is within the grid
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	96	96	Add the new point (goal or obstacle) to the list
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	102	102	Recalculate the potential grid after adding the new goal/obstacle
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	110	110	Check if the robot is within the grid
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	117	117	Movement direction arrays
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	121	121	Start by assuming the current position is the best position
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	125	125	Check the four neighboring cells (up, down, left, right)
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	131	131	Check if the new cell is within the grid
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	133	133	Check if the new cell has a lower potential
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	142	142	Output the potential at the new best position with 6 decimal places
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	148	148	Clear the potential grid and remove all goals/obstacles
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	152	152	Reset the count of points (goals/obstacles)
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.cpp	182	182	Recalculate potentials with the new K
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	4	4	Maximum number of points (goals/obstacles) that can be added
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	9	11	Grid dimensions (N x M)\n2D array for storing potential values\nScaling factor for potential calculation
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	13	16	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nCount of added points (goals/obstacles)
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	18	18	Helper function to recalculate the potentials for the entire grid
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	22	22	Constructor: initializes the grid with given dimensions N x M
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	25	25	Destructor: frees up dynamically allocated memory
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	28	28	Function to add a goal ('G') or obstacle ('O') at a specific point
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	31	31	Function to move the robot based on potential field
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	34	34	Function to clear the grid and reset all potentials and points
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	37	37	Function to update the value of K and apply it to the potential calculation
02913a7c	f24	p0	2024-09-22 00:54:14	Grid.h	40	40	Function to print the current state of the grid (for debugging/testing)
02913a7c	f24	p0	2024-09-22 00:54:14	main.cpp	61	61	if (grid != nullptr)
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	6	9	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nNumber of points added so far
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	21	21	Initialize all potentials to 0
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	40	40	Subtract the old influence
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	48	48	Reset all potentials to 0 before recalculating
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	51	51	Reset potentials before recalculating
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	53	53	For each grid cell (i, j), we need to consider the impact of all points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	56	56	Traverse through all the points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	63	63	Determine whether it's a goal or an obstacle and set the factor
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	65	65	Goal exerts an attractive force (negative potential)
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	67	67	Obstacle exerts a repulsive force (positive potential)
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	69	69	Calculate the Euclidean distance between (i, j) and the point (x, y)
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	72	72	If the distance is non-zero, update the potential
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	80	80	Check if the point is within the grid
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	87	87	Check if a point already exists at this location
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	90	90	A point already exists at (x, y), remove its influence first
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	92	92	Overwrite the point
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	100	100	If no point exists, add the new point (goal or obstacle) to the list
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	106	106	Recalculate the potential grid after adding the new goal/obstacle
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	114	114	Check if the robot is within the grid
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	121	121	Movement direction arrays
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	125	125	Start by assuming the current position is the best position
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	129	129	Check the four neighboring cells (up, down, left, right)
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	135	135	Check if the new cell is within the grid
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	137	137	Check if the new cell has a lower potential
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	146	146	Output the potential at the new best position with 6 decimal places
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	152	152	Clear the potential grid and remove all goals/obstacles
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	156	156	Reset the count of points (goals/obstacles)
02913a7c	f24	p0	2024-09-22 01:00:29	Grid.cpp	167	167	Recalculate potentials with the new K
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	6	9	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nNumber of points added so far*/
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	21	21	Initialize all potentials to 0
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	57	57	Subtract the old influence
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	118	118	Reset all potentials to 0 before recalculating
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	121	121	Reset potentials before recalculating
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	123	123	For each grid cell (i, j), we need to consider the impact of all points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	126	126	Traverse through all the points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	129	129	double factor;
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	134	134	Determine whether it's a goal or an obstacle and set the factor
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	136	136	Goal exerts an attractive force (negative potential)
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	138	138	Obstacle exerts a repulsive force (positive potential)
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	140	140	Calculate the Euclidean distance between (i, j) and the point (x, y)
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	143	143	If the distance is non-zero, update the potential
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	151	151	Check if the point is within the grid
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	153	153	if (x < 0 || x >= N || y < 0 || y >= M)
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	159	159	Check if a point already exists at this location
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	162	162	A point already exists at (x, y), remove its influence first
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	164	164	Overwrite the point
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	172	172	If no point exists, add the new point (goal or obstacle) to the list
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	178	178	Recalculate the potential grid after adding the new goal/obstacle
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	188	188	expand grid
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	194	194	check if a pt. already exists at this location
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	199	199	overwrite if pts. exists
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	207	207	if no pt. exists, add new pt.(G/T)
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	218	218	recalculate potential grid after adding new G/T
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	248	248	Check if the robot is within the grid
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	255	255	Movement direction arrays
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	259	259	Start by assuming the current position is the best position
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	263	263	Check the four neighboring cells (up, down, left, right)
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	269	269	Check if the new cell is within the grid
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	271	271	Check if the new cell has a lower potential
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	280	280	Output the potential at the new best position with 6 decimal places
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	296	296	Clear the potential grid and remove all goals/obstacles
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	300	300	Reset the count of points (goals/obstacles)
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.cpp	321	321	std::cout << "failure\\n";
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.h	4	4	const int MAX_POINTS = 5000000;
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.h	9	11	change to pointer --> dynamic array\nconstructor --> create new arrary\npintX, ptY, pointType在constructor里面声明
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.h	19	19	const int MAX_POINTS;
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.h	21	23	int pointX[MAX_POINTS];\nint pointY[MAX_POINTS];\nchar pointType[MAX_POINTS];
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.h	29	29	void removePointInfluence(int x, int y, char type);
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.h	36	36	void recalculatePotentials();
02913a7c	f24	p0	2024-09-22 18:51:50	Grid.h	40	40	void printGrid();
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	6	9	Array to store x-coordinates of goals and obstacles\nArray to store y-coordinates of goals and obstacles\nArray to store the type ('G' for goal, 'O' for obstacle)\nNumber of points added so far*/
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	21	21	Initialize all potentials to 0
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	57	57	Subtract the old influence
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	118	118	Reset all potentials to 0 before recalculating
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	121	121	Reset potentials before recalculating
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	123	123	For each grid cell (i, j), we need to consider the impact of all points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	126	126	Traverse through all the points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	129	129	double factor;
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	134	134	Determine whether it's a goal or an obstacle and set the factor
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	136	136	Goal exerts an attractive force (negative potential)
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	138	138	Obstacle exerts a repulsive force (positive potential)
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	140	140	Calculate the Euclidean distance between (i, j) and the point (x, y)
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	143	143	If the distance is non-zero, update the potential
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	151	151	Check if the point is within the grid
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	153	153	if (x < 0 || x >= N || y < 0 || y >= M)
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	159	159	Check if a point already exists at this location
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	162	162	A point already exists at (x, y), remove its influence first
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	164	164	Overwrite the point
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	172	172	If no point exists, add the new point (goal or obstacle) to the list
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	178	178	Recalculate the potential grid after adding the new goal/obstacle
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	191	191	expand grid
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	197	197	check if a pt. already exists at this location
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	202	202	remove previous pt/'s influence
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	205	205	overwrite if pts. exists
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	210	210	recalculatePotentials();
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	216	216	if no pt. exists, add new pt.(G/T)
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	256	256	Check if the robot is within the grid
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	263	263	Movement direction arrays
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	267	267	Start by assuming the current position is the best position
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	271	271	Check the four neighboring cells (up, down, left, right)
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	277	277	Check if the new cell is within the grid
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	279	279	Check if the new cell has a lower potential
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	288	288	Output the potential at the new best position with 6 decimal places
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	307	307	Clear the potential grid and remove all goals/obstacles
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	311	311	Reset the count of points (goals/obstacles)
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.cpp	369	369	std::cout << "failure\\n";
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.h	4	4	const int MAX_POINTS = 5000000;
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.h	9	11	change to pointer --> dynamic array\nconstructor --> create new arrary\npintX, ptY, pointType在constructor里面声明
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.h	19	19	const int MAX_POINTS;
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.h	23	25	int pointX[MAX_POINTS];\nint pointY[MAX_POINTS];\nchar pointType[MAX_POINTS];
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.h	31	31	void removePointInfluence(int x, int y, char type);
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.h	38	38	void recalculatePotentials();
02913a7c	f24	p0	2024-09-22 19:17:17	Grid.h	42	42	void printGrid();
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	6	6	Constructor initializing grid with dimensions N x M, and setting initial values for K, point arrays, and potentials
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	19	19	Destructor to clean up allocated memory
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	31	31	Function to expand the point arrays (doubling their capacity)
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	39	39	Copy old data into new, larger arrays
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	46	46	Delete old arrays and assign new ones
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	57	57	Function to remove the potential influence of an old point
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	66	66	Remove old influence
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	72	72	Recalculates the potential grid based on current points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	92	92	Adds a goal or obstacle point to the grid, recalculating potentials
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	95	95	If point is out of bounds, print failure and exit
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	101	101	Check if a point already exists at this location
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	104	104	First, remove the old influence
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	107	107	Now, update the point type with the new one (G or O)
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	110	110	Recalculate potentials after updating the point
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	117	117	If pointCount exceeds current capacity, expand the capacity of the point arrays
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	122	122	Add new point
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	128	128	Recalculate the potential grid
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	133	133	Moves the robot and outputs the potential at the specified coordinates
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	143	143	Clears the grid by resetting all potentials and point arrays
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	146	146	Reset point count
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.cpp	155	155	Updates the value of K and recalculates potentials
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.h	4	4	const int MAX_POINTS = 5000000;
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.h	9	11	change to pointer --> dynamic array\nconstructor --> create new arrary\npintX, ptY, pointType在constructor里面声明
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.h	19	19	const int MAX_POINTS;
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.h	21	23	int pointX[MAX_POINTS];\nint pointY[MAX_POINTS];\nchar pointType[MAX_POINTS];
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.h	29	29	void removePointInfluence(int x, int y, char type);
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.h	36	36	void recalculatePotentials();
02913a7c	f24	p0	2024-09-22 22:09:22	Grid.h	41	41	void printGrid();
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	6	6	Constructor initializing grid with dimensions N x M, and setting initial values for K, point arrays, and potentials
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	19	19	Destructor to clean up allocated memory
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	31	31	Function to expand the point arrays (doubling their capacity)
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	39	39	Copy old data into new, larger arrays
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	46	46	Delete old arrays and assign new ones
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	57	57	Function to remove the potential influence of an old point
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	66	66	Remove old influence
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	72	72	Recalculates the potential grid based on current points (goals and obstacles)
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	92	92	Adds a goal or obstacle point to the grid, recalculating potentials
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	95	95	If point is out of bounds, print failure and exit
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	101	101	Check if a point already exists at this location
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	104	104	First, remove the old influence
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	107	107	Now, update the point type with the new one (G or O)
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	110	110	Recalculate potentials after updating the point
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	117	117	If pointCount exceeds current capacity, expand the capacity of the point arrays
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	122	122	Add new point
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	128	128	Recalculate the potential grid
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	133	133	Moves the robot and outputs the potential at the specified coordinates
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	143	143	Clears the grid by resetting all potentials and point arrays
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	146	146	Reset point count
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.cpp	155	155	Updates the value of K and recalculates potentials
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.h	4	4	const int MAX_POINTS = 5000000;
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.h	9	11	change to pointer --> dynamic array\nconstructor --> create new arrary\npintX, ptY, pointType在constructor里面声明
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.h	19	19	const int MAX_POINTS;
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.h	21	23	int pointX[MAX_POINTS];\nint pointY[MAX_POINTS];\nchar pointType[MAX_POINTS];
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.h	29	29	void removePointInfluence(int x, int y, char type);
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.h	36	36	void recalculatePotentials();
02913a7c	f24	p0	2024-09-22 22:46:29	Grid.h	41	41	void printGrid();
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	3	3	For sqrt and pow
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	6	6	Constructor initializing grid with dimensions N x M, and setting initial values for K, point arrays, and potentials
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	19	19	Destructor to clean up allocated memory
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	31	31	Function to expand the point arrays (doubling their capacity)
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	39	39	Copy old data into new, larger arrays
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	46	46	Delete old arrays and assign new ones
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	57	57	Function to remove the potential influence of an old point
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	66	66	Remove old influence
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	72	72	Recalculates the potential grid based on current points (goals and obstacles)
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	92	92	Adds a goal or obstacle point to the grid, recalculating potentials
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	95	95	If point is out of bounds, print failure and exit
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	101	101	Check if a point already exists at this location
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	104	104	First, remove the old influence
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	107	107	Now, update the point type with the new one (G or O)
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	110	110	Recalculate potentials after updating the point
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	117	117	If pointCount exceeds current capacity, expand the capacity of the point arrays
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	122	122	Add new point
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	128	128	Recalculate the potential grid
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	133	133	Moves the robot and outputs the potential at the specified coordinates
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	143	143	Clears the grid by resetting all potentials and point arrays
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	146	146	Reset point count
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.cpp	155	155	Updates the value of K and recalculates potentials
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.h	4	4	const int MAX_POINTS = 5000000;
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.h	9	11	change to pointer --> dynamic array\nconstructor --> create new arrary\npintX, ptY, pointType在constructor里面声明
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.h	19	19	const int MAX_POINTS;
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.h	21	23	int pointX[MAX_POINTS];\nint pointY[MAX_POINTS];\nchar pointType[MAX_POINTS];
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.h	29	29	void removePointInfluence(int x, int y, char type);
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.h	36	36	void recalculatePotentials();
02913a7c	f24	p0	2024-09-23 08:23:18	Grid.h	41	41	void printGrid();
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	3	3	Constructor
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	13	13	CREATE function: initializes the grid
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	16	16	Delete the old grid if it exists
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	40	40	Empty by default
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	49	49	Function to calculate the total potential at a given point
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	54	54	Iterate through the entire grid
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	61	61	Skip if on the same point
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	65	65	Attractive potential
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	69	69	Repulsive potential
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	77	77	Function to add goals or obstacles
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	99	99	MOVE function
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	112	112	CLEAR function
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	126	126	Reset to empty
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	133	133	UPDATE function
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.cpp	155	155	Destructor to free the dynamically allocated memory
0334d2a3	f24	p0	2024-09-18 16:22:16	PotentialField.h	11	12	To store potential values\nTo store goals and obstacles
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	3	3	Constructor
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	13	13	CREATE function: initializes the grid
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	16	16	Delete the old grid if it exists
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	40	40	Empty by default
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	49	49	Function to calculate the total potential at a given point
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	54	54	Iterate through the entire grid
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	61	61	Skip if on the same point
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	65	65	Attractive potential
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	69	69	Repulsive potential
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	77	77	Function to add goals or obstacles
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	99	99	MOVE function
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	112	112	CLEAR function
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	126	126	Reset to empty
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	133	133	UPDATE function
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.cpp	155	155	Destructor to free the dynamically allocated memory
0334d2a3	f24	p0	2024-09-18 16:43:06	PotentialField.h	11	12	To store potential values\nTo store goals and obstacles
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	3	3	Constructor
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	13	13	CREATE function: initializes the grid
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	16	16	Delete the old grid if it exists
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	40	40	Empty by default
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	49	49	Function to calculate the total potential at a given point
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	54	54	Iterate through the entire grid
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	61	61	Skip if on the same point
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	65	65	Attractive potential
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	69	69	Repulsive potential
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	77	77	Function to add goals or obstacles
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	99	99	MOVE function
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	112	112	CLEAR function
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	126	126	Reset to empty
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	133	133	UPDATE function
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.cpp	155	155	Destructor to free the dynamically allocated memory
0334d2a3	f24	p0	2024-09-19 16:21:12	PotentialField.h	11	12	To store potential values\nTo store goals and obstacles
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	3	3	Constructor
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	13	13	CREATE function: initializes the grid
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	16	16	Delete the old grid if it exists
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	40	40	Empty by default
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	49	49	Function to calculate the total potential at a given point
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	54	54	Iterate through the entire grid
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	61	61	Skip if on the same point
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	65	65	Attractive potential
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	69	69	Repulsive potential
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	77	77	Function to add goals or obstacles
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	99	99	MOVE function
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	112	112	CLEAR function
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	126	126	Reset to empty
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	133	133	UPDATE function
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.cpp	155	155	Destructor to free the dynamically allocated memory
0334d2a3	f24	p0	2024-09-23 10:44:34	PotentialField.h	11	12	To store potential values\nTo store goals and obstacles
0743f839	f24	p0	2024-09-19 13:45:36	grid.cpp	40	40	calculate potentials effects from other points
0743f839	f24	p0	2024-09-19 13:45:36	grid.cpp	46	46	Skip the point itself
0743f839	f24	p0	2024-09-19 13:45:36	grid.cpp	125	126	Set precision for the output\nIterate over each cell in the grid
0743f839	f24	p0	2024-09-19 13:45:36	grid.cpp	129	129	Print the potentials and the type of each point
0743f839	f24	p0	2024-09-19 13:45:36	grid.cpp	136	136	Newline at the end of each row
0743f839	f24	p0	2024-09-19 13:45:36	main.cpp	7	7	Create an instance of Grid
0743f839	f24	p0	2024-09-19 13:45:36	main.cpp	42	42	grid.printGrid();
0743f839	f24	p0	2024-09-19 14:02:25	grid.cpp	40	40	calculate potentials effects from other points
0743f839	f24	p0	2024-09-19 14:02:25	grid.cpp	46	46	Skip the point itself
0743f839	f24	p0	2024-09-19 14:02:25	grid.cpp	125	126	Set precision for the output\nIterate over each cell in the grid
0743f839	f24	p0	2024-09-19 14:02:25	grid.cpp	129	129	Print the potentials and the type of each point
0743f839	f24	p0	2024-09-19 14:02:25	grid.cpp	136	136	Newline at the end of each row
0743f839	f24	p0	2024-09-19 14:02:25	main.cpp	7	7	Create an instance of Grid
0743f839	f24	p0	2024-09-19 14:02:25	main.cpp	42	42	grid.printGrid();
0743f839	f24	p0	2024-09-19 14:02:59	grid.cpp	40	40	calculate potentials effects from other points
0743f839	f24	p0	2024-09-19 14:02:59	grid.cpp	46	46	Skip the point itself
0743f839	f24	p0	2024-09-19 14:02:59	grid.cpp	125	126	Set precision for the output\nIterate over each cell in the grid
0743f839	f24	p0	2024-09-19 14:02:59	grid.cpp	129	129	Print the potentials and the type of each point
0743f839	f24	p0	2024-09-19 14:02:59	grid.cpp	136	136	Newline at the end of each row
0743f839	f24	p0	2024-09-19 14:02:59	main.cpp	7	7	Create an instance of Grid
0743f839	f24	p0	2024-09-19 14:02:59	main.cpp	42	42	grid.printGrid();
0743f839	f24	p0	2024-09-19 14:14:46	grid.cpp	40	40	calculate potentials effects from other points
0743f839	f24	p0	2024-09-19 14:14:46	grid.cpp	46	46	Skip the point itself
0743f839	f24	p0	2024-09-19 14:14:46	grid.cpp	125	126	Set precision for the output\nIterate over each cell in the grid
0743f839	f24	p0	2024-09-19 14:14:46	grid.cpp	129	129	Print the potentials and the type of each point
0743f839	f24	p0	2024-09-19 14:14:46	grid.cpp	136	136	Newline at the end of each row
0743f839	f24	p0	2024-09-19 14:14:46	main.cpp	7	7	Create an instance of Grid
0743f839	f24	p0	2024-09-19 14:14:46	main.cpp	42	42	grid.printGrid();
0743f839	f24	p0	2024-09-19 14:19:54	grid.cpp	40	40	calculate potentials effects from other points
0743f839	f24	p0	2024-09-19 14:19:54	grid.cpp	46	46	Skip the point itself
0743f839	f24	p0	2024-09-19 14:19:54	grid.cpp	125	126	Set precision for the output\nIterate over each cell in the grid
0743f839	f24	p0	2024-09-19 14:19:54	grid.cpp	129	129	Print the potentials and the type of each point
0743f839	f24	p0	2024-09-19 14:19:54	grid.cpp	136	136	Newline at the end of each row
0743f839	f24	p0	2024-09-19 14:19:54	main.cpp	7	7	Create an instance of Grid
0743f839	f24	p0	2024-09-19 14:19:54	main.cpp	42	42	grid.printGrid();
0743f839	f24	p0	2024-09-19 14:21:04	grid.cpp	40	40	calculate potentials effects from other points
0743f839	f24	p0	2024-09-19 14:21:04	grid.cpp	46	46	Skip the point itself
0743f839	f24	p0	2024-09-19 14:21:04	grid.cpp	125	126	Set precision for the output\nIterate over each cell in the grid
0743f839	f24	p0	2024-09-19 14:21:04	grid.cpp	129	129	Print the potentials and the type of each point
0743f839	f24	p0	2024-09-19 14:21:04	grid.cpp	136	136	Newline at the end of each row
0743f839	f24	p0	2024-09-19 14:21:04	main.cpp	7	7	Create an instance of Grid
0743f839	f24	p0	2024-09-19 14:21:04	main.cpp	42	42	grid.printGrid();
0743f839	f24	p0	2024-09-19 14:51:18	grid.cpp	40	40	calculate potentials effects from other points
0743f839	f24	p0	2024-09-19 14:51:18	grid.cpp	46	46	Skip the point itself
0743f839	f24	p0	2024-09-19 14:51:18	grid.cpp	125	126	Set precision for the output\nIterate over each cell in the grid
0743f839	f24	p0	2024-09-19 14:51:18	grid.cpp	129	129	Print the potentials and the type of each point
0743f839	f24	p0	2024-09-19 14:51:18	grid.cpp	136	136	Newline at the end of each row
0743f839	f24	p0	2024-09-19 14:51:18	main.cpp	7	7	Create an instance of Grid
0743f839	f24	p0	2024-09-19 14:51:18	main.cpp	42	42	grid.printGrid();
0743f839	f24	p0	2024-09-20 12:27:12	grid.cpp	40	40	calculate potentials effects from other points
0743f839	f24	p0	2024-09-20 12:27:12	grid.cpp	46	46	Skip the point itself
0743f839	f24	p0	2024-09-20 12:27:12	grid.cpp	125	126	Set precision for the output\nIterate over each cell in the grid
0743f839	f24	p0	2024-09-20 12:27:12	grid.cpp	129	129	Print the potentials and the type of each point
0743f839	f24	p0	2024-09-20 12:27:12	grid.cpp	136	136	Newline at the end of each row
0743f839	f24	p0	2024-09-20 12:27:12	main.cpp	9	9	Read commands from standard input
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	19	19	Delete each row
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	21	21	Delete the grid
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	30	31	Initialize the grid\nCreate an array of pointers to cell arrays
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	34	34	For each row, allocate m cells
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	44	44	we need to calculate a cell's potential due to every goal/obstalce in the grid.
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	47	47	So we need to do another nested for loop.
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	50	50	Factor will be 1 if cell is obstacle, and -1 if is goal.
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	54	54	if the current cell is a goal or obstalce
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	57	57	if the cell is an obstalce then make 1.
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	60	60	if it's a goal then make it -1.
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	63	63	calculate potential
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	93	93	first check if x and y are valid
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	95	95	the target cell should not be an obstacle/goal
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	143	143	Properly reading T, X, Y for POINT
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	148	148	Properly reading X, Y for MOVE
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.cpp	157	157	Properly reading K for UPDATE
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.hpp	11	11	0 for nothing, 1 for obstacle, 2 for goal
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.hpp	26	27	Constructor\nDestructor
08189ff6	f24	p0	2024-09-19 23:48:26	Project_0.hpp	29	29	Functions
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	19	19	Delete each row
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	21	21	Delete the grid
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	30	31	Initialize the grid\nCreate an array of pointers to cell arrays
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	34	34	For each row, allocate m cells
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	44	44	we need to calculate a cell's potential due to every goal/obstalce in the grid.
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	47	47	So we need to do another nested for loop.
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	50	50	Factor will be 1 if cell is obstacle, and -1 if is goal.
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	54	54	if the current cell is a goal or obstalce
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	57	57	if the cell is an obstalce then make 1.
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	60	60	if it's a goal then make it -1.
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	63	63	calculate potential
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	93	93	first check if x and y are valid
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	95	95	the target cell should not be an obstacle/goal
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	143	143	Properly reading T, X, Y for POINT
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	148	148	Properly reading X, Y for MOVE
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.cpp	157	157	Properly reading K for UPDATE
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.hpp	11	11	0 for nothing, 1 for obstacle, 2 for goal
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.hpp	26	27	Constructor\nDestructor
08189ff6	f24	p0	2024-09-19 23:54:51	Project_0.hpp	29	29	Functions
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	19	19	Delete each row
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	21	21	Delete the grid
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	31	32	Initialize the grid\nCreate an array of pointers to cell arrays
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	35	35	For each row, allocate m cells
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	48	48	we need to calculate a cell's potential due to every goal/obstalce in the grid.
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	51	51	So we need to do another nested for loop.
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	57	57	Factor will be 1 if cell is obstacle, and -1 if is goal.
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	61	61	if the current cell is a goal or obstalce
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	64	64	if the cell is an obstalce then make 1.
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	67	67	if it's a goal then make it -1.
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	70	70	calculate potential
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	100	100	first check if x and y are valid
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	102	102	the target cell should not be an obstacle/goal
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	152	152	Properly reading T, X, Y for POINT
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	157	157	Properly reading X, Y for MOVE
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	166	166	Properly reading K for UPDATE
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.cpp	181	212	Following the provided pseudocode for test case 007621\nCREATE 48 40\nCLEAR\nCLEAR\nUPDATE 4.080733749417421\nPOINT O 26 20\nUPDATE -6.554415580636053\nPOINT G -3 2\nUPDATE -15.089765189381751\nPOINT G 17 15\nCLEAR\nUPDATE -3.458377431250531\nPOINT O 44 0\nMOVE 3 43\nUPDATE -20.5228169898302\nMOVE 48 13\nMOVE 40 1\nCLEAR\nPOINT G 15 -10\nUPDATE 2.5358380285476456\nPOINT O 15 36\nMOVE 41 -2\nUPDATE -2.925316812230332\nMOVE 15 36\nPOINT G 32 38\nMOVE 38 -4\nUPDATE 3.237040522995823\nMOVE 49 16\nMOVE 17 38\nPOINT O 27 21\nMOVE -10 3\nEXIT
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.hpp	11	11	0 for nothing, 1 for obstacle, 2 for goal
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.hpp	26	27	Constructor\nDestructor
08189ff6	f24	p0	2024-09-20 13:04:22	Project_0.hpp	29	29	Functions
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	19	19	Delete each row
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	21	21	Delete the grid
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	27	27	Free previously allocated grid if it exists - same as destructor
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	30	30	Delete each row
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	32	32	Delete the grid array
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	41	42	Initialize the grid\nCreate an array of pointers to cell arrays
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	45	45	For each row, allocate m cells
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	58	58	we need to calculate a cell's potential due to every goal/obstalce in the grid.
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	61	61	So we need to do another nested for loop.
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	67	67	Factor will be 1 if cell is obstacle, and -1 if is goal.
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	71	71	if the current cell is a goal or obstalce
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	74	74	if the cell is an obstalce then make 1.
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	77	77	if it's a goal then make it -1.
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	80	80	calculate potential
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	110	110	first check if x and y are valid
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	112	112	the target cell should not be an obstacle/goal
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	162	162	Properly reading T, X, Y for POINT
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	167	167	Properly reading X, Y for MOVE
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	176	176	Properly reading K for UPDATE
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.cpp	191	222	Following the provided pseudocode for test case 007621\nCREATE 48 40\nCLEAR\nCLEAR\nUPDATE 4.080733749417421\nPOINT O 26 20\nUPDATE -6.554415580636053\nPOINT G -3 2\nUPDATE -15.089765189381751\nPOINT G 17 15\nCLEAR\nUPDATE -3.458377431250531\nPOINT O 44 0\nMOVE 3 43\nUPDATE -20.5228169898302\nMOVE 48 13\nMOVE 40 1\nCLEAR\nPOINT G 15 -10\nUPDATE 2.5358380285476456\nPOINT O 15 36\nMOVE 41 -2\nUPDATE -2.925316812230332\nMOVE 15 36\nPOINT G 32 38\nMOVE 38 -4\nUPDATE 3.237040522995823\nMOVE 49 16\nMOVE 17 38\nPOINT O 27 21\nMOVE -10 3\nEXIT
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.hpp	11	11	0 for nothing, 1 for obstacle, 2 for goal
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.hpp	26	27	Constructor\nDestructor
08189ff6	f24	p0	2024-09-20 13:14:53	Project_0.hpp	29	29	Functions
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	4	4	Default constructor for the Cell class
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	6	7	Initialize potential to 0\nDefault cell type (0 for empty, 1 for obstacle, 2 for goal)
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	10	10	Constructor for the Map class
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	12	15	Default constant for potential calculation\nNumber of rows in the grid\nNumber of columns in the grid\nInitialize grid to nullptr (no memory allocated yet)
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	18	18	Destructor for the Map class
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	22	22	Delete each row within the grid
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	24	24	Delete the grid itself (array of pointers)
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	29	29	Creates the grid with given dimensions (input_n x input_m)
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	31	31	Free previously allocated grid if it exists - same as the destructor
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	40	41	Set the number of rows\nSet the number of columns
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	43	44	Allocate memory for the grid\nCreate an array of pointers to Cell arrays
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	47	47	For each row, allocate m cells (columns)
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	53	53	Calculate the potential of each cell in the grid
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	55	55	Iterate over every cell in the grid (by row and column)
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	59	59	This will store the total potential for each cell.
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	61	61	Nested loop to calculate the effect of every other cell on the current cell's potential
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	65	65	Skip the current cell itself
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	68	68	Multiplication factor will be +1 if the cell is an obstacle, and -1 if it's a goal.
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	71	72	Access the current cell being considered\nOnly proceed if the cell is a goal or an obstacle
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	75	75	If the cell is an obstacle, set factor to +1
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	78	78	If it's a goal, set factor to -1
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	81	84	Calculate the potential contribution\nDenominator\nApply k\nMultiply by factor (goal or obstacle)
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	86	86	Add to the total potential for current cell
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	91	91	Set the calculated potential for the current cell
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	96	96	Sets a point in the grid as either a goal (G) or an obstacle (O)
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	98	100	Ensure the coordinates are valid\nSet cell as goal\nSet cell as obstacle
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	102	102	Recalculate the potentials after changing the cell
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	108	108	Prints the potential value of a specific cell
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	110	111	Ensure the coordinates are valid\nPrint the potential value twice as per project requirements
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	116	116	Resets the grid by clearing all cells and setting potentials to zero
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	120	120	Iterate over all cells and reset their types and potentials
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	123	124	Set cell type to 0 (empty)\nReset potential to 0
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	131	131	Updates the value of the constant k and recalculates the potentials
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	136	136	Recalculate potentials based on the new k value
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	141	141	Placeholder for exit function
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	146	146	Main function to handle user commands
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	148	152	Stores user commands\nCreate a Map object\nCoordinates or dimensions\nConstant\nType (either 'G' for goal or 'O' for obstacle)
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	154	154	Command loop to handle user input
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	160	160	Create the grid with dimensions X by Y
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	164	165	Read the point type (G/O) and coordinates\nSet the point
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	169	170	Read the coordinates\nPrint the potential at the given coordinates
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	174	174	Clear the grid
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	178	179	Read the new value of k\nUpdate k and recalculate potentials
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.cpp	183	183	Exit the program
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.hpp	11	11	0 for nothing, 1 for obstacle, 2 for goal
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.hpp	26	27	Constructor\nDestructor
08189ff6	f24	p0	2024-09-20 20:50:29	Project_0.hpp	29	29	Functions
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	4	4	Default constructor for the Cell class
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	6	7	Initialize potential to 0\nDefault cell type (0 for empty, 1 for obstacle, 2 for goal)
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	10	10	Constructor for the Map class
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	12	15	Default constant for potential calculation\nNumber of rows in the grid\nNumber of columns in the grid\nInitialize grid to nullptr (no memory allocated yet)
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	18	18	Destructor for the Map class
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	22	22	Delete each row within the grid
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	24	24	Delete the grid itself (array of pointers)
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	29	29	Creates the grid with given dimensions (input_n x input_m)
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	31	31	Free previously allocated grid if it exists - same as the destructor
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	40	41	Set the number of rows\nSet the number of columns
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	43	44	Allocate memory for the grid\nCreate an array of pointers to Cell arrays
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	47	47	For each row, allocate m cells (columns)
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	53	53	Calculate the potential of each cell in the grid
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	55	55	Iterate over every cell in the grid (by row and column)
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	59	59	This will store the total potential for each cell.
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	61	61	Nested loop to calculate the effect of every other cell on the current cell's potential
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	65	65	Skip the current cell itself
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	68	68	Multiplication factor will be +1 if the cell is an obstacle, and -1 if it's a goal.
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	71	72	Access the current cell being considered\nOnly proceed if the cell is a goal or an obstacle
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	75	75	If the cell is an obstacle, set factor to +1
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	78	78	If it's a goal, set factor to -1
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	81	84	Calculate the potential contribution\nDenominator\nApply k\nMultiply by factor (goal or obstacle)
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	86	86	Add to the total potential for current cell
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	91	91	Set the calculated potential for the current cell
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	96	96	Sets a point in the grid as either a goal (G) or an obstacle (O)
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	98	100	Ensure the coordinates are valid\nSet cell as goal\nSet cell as obstacle
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	102	102	Recalculate the potentials after changing the cell
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	108	108	Prints the potential value of a specific cell
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	110	111	Ensure the coordinates are valid\nPrint the potential value twice as per project requirements
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	116	116	Resets the grid by clearing all cells and setting potentials to zero
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	120	120	Iterate over all cells and reset their types and potentials
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	123	124	Set cell type to 0 (empty)\nReset potential to 0
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	131	131	Updates the value of the constant k and recalculates the potentials
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	136	136	Recalculate potentials based on the new k value
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	141	141	Placeholder for exit function
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	146	146	Main function to handle user commands
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	148	152	Stores user commands\nCreate a Map object\nCoordinates or dimensions\nConstant\nType (either 'G' for goal or 'O' for obstacle)
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	154	154	Command loop to handle user input
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	160	160	Create the grid with dimensions X by Y
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	164	165	Read the point type (G/O) and coordinates\nSet the point
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	169	170	Read the coordinates\nPrint the potential at the given coordinates
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	174	174	Clear the grid
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	178	179	Read the new value of k\nUpdate k and recalculate potentials
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.cpp	183	183	Exit the program
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.hpp	11	11	0 for nothing, 1 for obstacle, 2 for goal
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.hpp	24	25	Constructor\nDestructor
08189ff6	f24	p0	2024-09-20 21:51:04	Project_0.hpp	27	27	Functions
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	4	4	Default constructor for the Cell class
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	6	7	Initialize potential to 0\nDefault cell type (0 for empty, 1 for obstacle, 2 for goal)
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	10	10	Constructor for the Map class
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	12	15	Default constant for potential calculation\nNumber of rows in the grid\nNumber of columns in the grid\nInitialize grid to nullptr (no memory allocated yet)
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	18	18	Destructor for the Map class
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	22	22	Delete each row within the grid
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	24	24	Delete the grid itself (array of pointers)
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	29	29	Creates the grid with given dimensions (input_n x input_m)
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	31	31	Free previously allocated grid if it exists - same as the destructor
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	40	41	Set the number of rows\nSet the number of columns
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	43	44	Allocate memory for the grid\nCreate an array of pointers to Cell arrays
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	47	47	For each row, allocate m cells (columns)
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	53	53	Calculate the potential of each cell in the grid
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	55	55	Iterate over every cell in the grid (by row and column)
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	59	59	This will store the total potential for each cell.
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	61	61	Nested loop to calculate the effect of every other cell on the current cell's potential
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	65	65	Skip the current cell itself
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	68	68	Multiplication factor will be +1 if the cell is an obstacle, and -1 if it's a goal.
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	71	72	Access the current cell being considered\nOnly proceed if the cell is a goal or an obstacle
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	75	75	If the cell is an obstacle, set factor to +1
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	78	78	If it's a goal, set factor to -1
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	81	84	Calculate the potential contribution\nDenominator\nApply k\nMultiply by factor (goal or obstacle)
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	86	86	Add to the total potential for current cell
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	91	91	Set the calculated potential for the current cell
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	96	96	Sets a point in the grid as either a goal (G) or an obstacle (O)
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	98	100	Ensure the coordinates are valid\nSet cell as goal\nSet cell as obstacle
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	102	102	Recalculate the potentials after changing the cell
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	108	108	Prints the potential value of a specific cell
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	110	111	Ensure the coordinates are valid\nPrint the potential value twice as per project requirements
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	116	116	Resets the grid by clearing all cells and setting potentials to zero
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	120	120	Iterate over all cells and reset their types and potentials
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	123	124	Set cell type to 0 (empty)\nReset potential to 0
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	131	131	Updates the value of the constant k and recalculates the potentials
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	136	136	Recalculate potentials based on the new k value
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	141	141	Placeholder for exit function
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	146	146	Main function to handle user commands
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	148	152	Stores user commands\nCreate a Map object\nCoordinates or dimensions\nConstant\nType (either 'G' for goal or 'O' for obstacle)
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	154	154	Command loop to handle user input
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	160	160	Create the grid with dimensions X by Y
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	164	165	Read the point type (G/O) and coordinates\nSet the point
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	169	170	Read the coordinates\nPrint the potential at the given coordinates
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	174	174	Clear the grid
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	178	179	Read the new value of k\nUpdate k and recalculate potentials
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.cpp	183	183	Exit the program
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.hpp	11	11	0 for nothing, 1 for obstacle, 2 for goal
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.hpp	24	25	Constructor\nDestructor
08189ff6	f24	p0	2024-09-23 13:17:05	Project_0.hpp	27	27	Functions
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	43	43	initializes integer values
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	46	46	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	49	49	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	52	52	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	55	55	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	69	69	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	75	75	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	79	79	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	91	91	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	97	97	outputs movement direction
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	108	108	returns if array not created
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	113	113	iterates through 2D array
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	116	116	zeroes potential values
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	120	120	if cell is an obstacle or goal, clears it
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	133	133	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	139	139	updates k value
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	159	159	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	161	161	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	167	167	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	183	183	cell class functions
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	190	190	initializes basic values
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	227	227	test 01
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.cpp	237	237	test 09
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.hpp	26	28	array representing actual grid (will be 2D array when executing constructor)\n2D array, with each element of the array containing another 2-element array\n(x and y potential values) ---- NOTE TO CONSIDER: IS THIS A 3D ARRAY?
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-20 03:23:19	grid.hpp	38	38	required functions
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	43	43	initializes integer values
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	46	46	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	49	49	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	52	52	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	55	55	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	69	69	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	75	75	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	79	79	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	91	91	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	97	97	outputs movement direction
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	108	108	returns if array not created
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	113	113	iterates through 2D array
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	116	116	zeroes potential values
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	120	120	if cell is an obstacle or goal, clears it
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	133	133	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	139	139	updates k value
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	159	159	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	161	161	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	167	167	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	183	183	cell class functions
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	190	190	initializes basic values
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	227	227	test 01
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.cpp	237	237	test 09
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.hpp	26	28	array representing actual grid (will be 2D array when executing constructor)\n2D array, with each element of the array containing another 2-element array\n(x and y potential values) ---- NOTE TO CONSIDER: IS THIS A 3D ARRAY?
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-20 03:24:51	grid.hpp	38	38	required functions
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	44	44	initializes integer values
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	47	47	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	50	50	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	53	53	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	56	56	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	70	70	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	76	76	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	80	80	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	92	92	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	98	98	outputs movement direction
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	109	109	returns if array not created
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	114	114	iterates through 2D array
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	117	117	zeroes potential values
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	121	121	if cell is an obstacle or goal, clears it
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	134	134	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	140	140	updates k value
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	160	160	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	162	162	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	168	168	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	184	184	cell class functions
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	191	191	initializes basic values
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	228	228	test 01
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.cpp	238	238	test 09
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.hpp	26	28	array representing actual grid (will be 2D array when executing constructor)\n2D array, with each element of the array containing another 2-element array\n(x and y potential values) ---- NOTE TO CONSIDER: IS THIS A 3D ARRAY?
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-20 03:35:38	grid.hpp	38	38	required functions
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	29	29	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	31	31	deletes columns
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	45	45	initializes integer values
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	48	48	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	51	51	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	54	54	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	57	57	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	71	71	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	77	77	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	81	81	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	93	93	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	99	99	outputs movement direction
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	110	110	returns if array not created
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	116	116	iterates through 2D array
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	119	119	zeroes potential values
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	123	123	if cell is an obstacle or goal, clears it
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	136	136	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	142	142	updates k value
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	162	162	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	164	164	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	170	170	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	186	186	cell class functions
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	193	193	initializes basic values
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	238	238	test 01
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.cpp	248	248	test 09
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.hpp	27	29	array representing actual grid (will be 2D array when executing constructor)\n2D array, with each element of the array containing another 2-element array\n(x and y potential values) ---- NOTE TO CONSIDER: IS THIS A 3D ARRAY?
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.hpp	35	35	constructor and destructor
09c5ce2a	f24	p0	2024-09-20 04:34:57	grid.hpp	40	40	required functions
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	29	29	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	31	31	deletes columns
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	45	45	initializes integer values
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	48	48	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	51	51	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	54	54	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	57	57	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	71	71	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	77	77	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	81	81	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	93	93	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	99	99	outputs movement direction
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	110	110	returns if array not created
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	116	116	iterates through 2D array
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	119	119	zeroes potential values
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	123	123	if cell is an obstacle or goal, clears it
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	136	136	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	142	142	updates k value
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	162	162	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	164	164	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	170	170	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	185	185	cell class functions
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.cpp	192	192	initializes basic values
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.hpp	27	29	array representing actual grid (will be 2D array when executing constructor)\n2D array, with each element of the array containing another 2-element array\n(x and y potential values) ---- NOTE TO CONSIDER: IS THIS A 3D ARRAY?
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.hpp	35	35	constructor and destructor
09c5ce2a	f24	p0	2024-09-20 04:58:22	grid.hpp	40	40	required functions
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	29	29	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	31	31	deletes columns
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	46	46	initializes integer values
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	49	49	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	52	52	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	55	55	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	57	57	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	71	71	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	77	77	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	81	81	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	93	93	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	99	99	outputs movement direction
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	110	110	returns if array not created
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	116	116	iterates through 2D array
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	119	119	zeroes potential values
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	123	123	if cell is an obstacle or goal, clears it
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	136	136	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	142	142	updates k value
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	162	162	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	164	164	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	170	170	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	185	185	cell class functions
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.cpp	192	192	initializes basic values
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.hpp	27	27	array representing actual grid
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-21 03:07:54	grid.hpp	38	38	required functions
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	29	29	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	31	31	deletes columns
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	47	47	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	57	57	initializes integer values
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	60	60	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	63	63	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	65	65	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	79	79	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	85	85	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	89	89	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	101	101	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	107	107	outputs movement direction
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	118	118	returns if array not created
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	124	124	iterates through 2D array
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	127	127	zeroes potential values
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	131	131	if cell is an obstacle or goal, clears it
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	144	144	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	150	150	updates k value
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	161	161	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	163	163	deletes columns
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	180	180	checks if grid has been created
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	185	185	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	187	187	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	193	193	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	208	208	cell class functions
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.cpp	215	215	initializes basic values
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.hpp	27	27	array representing actual grid
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-21 03:24:07	grid.hpp	38	38	required functions
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	31	31	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	33	33	deletes columns
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	48	48	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	58	58	initializes integer values
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	63	63	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	66	66	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	68	68	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	82	82	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	88	88	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	92	92	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	104	104	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	110	110	outputs movement direction
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	121	121	returns if array not created
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	127	127	iterates through 2D array
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	130	130	zeroes potential values
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	145	145	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	151	151	updates k value
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	162	162	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	164	164	deletes columns
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	181	181	checks if grid has been created
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	186	186	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	188	188	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	194	194	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	209	209	cell class functions
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.cpp	216	216	initializes basic values
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.hpp	27	27	array representing actual grid
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-21 04:38:15	grid.hpp	38	38	required functions
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	31	31	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	33	33	deletes columns
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	48	48	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	58	58	initializes integer values
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	63	63	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	66	66	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	68	68	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	82	82	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	88	88	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	92	92	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	104	104	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	110	110	outputs movement direction
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	121	121	returns if array not created
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	127	127	iterates through 2D array
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	130	130	zeroes potential values
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	145	145	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	151	151	updates k value
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	162	162	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	164	164	deletes columns
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	181	181	checks if grid has been created
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	186	186	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	188	188	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	194	194	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	209	209	cell class functions
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.cpp	216	216	initializes basic values
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.hpp	27	27	array representing actual grid
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-21 04:41:28	grid.hpp	38	38	required functions
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	31	31	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	33	33	deletes columns
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	48	48	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	58	58	initializes integer values
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	63	63	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	66	66	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	68	68	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	82	82	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	88	88	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	92	92	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	104	104	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	110	110	outputs movement direction
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	121	121	returns if array not created
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	127	127	iterates through 2D array
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	130	130	zeroes potential values
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	145	145	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	151	151	updates k value
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	162	162	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	164	164	deletes columns
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	181	181	checks if grid has been created
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	186	186	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	188	188	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	194	194	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	209	209	cell class functions
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.cpp	216	216	initializes basic values
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.hpp	27	27	array representing actual grid
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-21 13:03:44	grid.hpp	38	38	required functions
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	31	31	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	33	33	deletes columns
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	48	48	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	58	58	initializes integer values
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	63	63	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	66	66	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	68	68	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	82	82	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	88	88	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	92	92	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	104	104	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	110	110	outputs movement direction
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	121	121	returns if array not created
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	127	127	iterates through 2D array
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	130	130	zeroes potential values
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	145	145	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	151	151	updates k value
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	162	162	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	164	164	deletes columns
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	181	181	checks if grid has been created
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	186	186	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	188	188	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	194	194	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	209	209	cell class functions
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.cpp	216	216	initializes basic values
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.hpp	27	27	array representing actual grid
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-23 12:25:26	grid.hpp	38	38	required functions
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	12	12	grid class functions
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	19	19	initializes basic values
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	31	31	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	33	33	deletes columns
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	48	48	if grid already exists, run destructor
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	58	58	initializes integer values
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	63	63	declares grid_array to poin to array of pointers
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	66	66	iterates through each column element and instantiates cell array rows
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	68	68	defines each array to contain a secondary array of cell objects
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	82	82	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	88	88	specifies whether grid cell is obstacle or goal
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	92	92	iterates through grid and updates potential values
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	104	104	checks if specified index is beyond array bounds
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	110	110	outputs movement direction
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	121	121	returns if array not created
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	127	127	iterates through 2D array
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	130	130	zeroes potential values
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	145	145	if k value is invalid, indicate and return
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	151	151	updates k value
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	162	162	as long as grid was allocated, executes
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	164	164	deletes columns
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	181	181	checks if grid has been created
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	186	186	iterates through columns to calculate grid point potential
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	188	188	iterates through row to calculate grid point potential
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	194	194	iterates through all elements and looks for obstacles and goals
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	209	209	cell class functions
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.cpp	216	216	initializes basic values
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.hpp	12	14	x-potential value\ny-potential value\n0 for nothing, 1 for obstacle, 2 for goal
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.hpp	16	16	constructor
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.hpp	27	27	array representing actual grid
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.hpp	33	33	constructor and destructor
09c5ce2a	f24	p0	2024-09-23 12:46:12	grid.hpp	38	38	required functions
115d18bb	f24	p0	2024-09-19 22:22:46	block.cpp	3	3	constructor
115d18bb	f24	p0	2024-09-19 22:22:46	block.cpp	7	7	E = empty
115d18bb	f24	p0	2024-09-19 22:22:46	block.cpp	10	10	nothing to deallocate
115d18bb	f24	p0	2024-09-19 22:22:46	block.h	1	1	class map;
115d18bb	f24	p0	2024-09-19 22:22:46	block.h	12	12	no need to make private since assume valid inputs. always need access and manipulation access from map class.
115d18bb	f24	p0	2024-09-19 22:22:46	block.h	18	20	should assign valid value to both ? no return always assume valid.\nall potentials should update together, cannot change one potential only at a time. restrict manipulation access\nshouldnt be able to set state without updateding the whole grid. restrict manipuation access.
115d18bb	f24	p0	2024-09-19 22:22:46	block.h	24	29	friend void map::computePotential();\nfriend class map;\nget position\nset position\nset pot\nget state();
115d18bb	f24	p0	2024-09-19 22:22:46	main.cpp	28	28	DC this
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	3	3	#include "block.h" //?
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	10	10	make map ptr
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	12	13	array of array of blocks\narray of blocks
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	15	15	for each block give coords
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	22	22	deallocates all block arrays
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	27	27	deallocates array of block arrays
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	34	35	for all block, recalculate\nreinit potential
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	37	38	checks all blocks again\nif there is something causing potential and is not block itself
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	65	67	if (X < 0 || Y < 0 || X >= n || Y >= m){ // if coords out of bounds\nreturn false;\n> .>>> check in main
115d18bb	f24	p0	2024-09-19 22:22:46	map.cpp	72	73	checks for map existance in main\notherwise, for each block
115d18bb	f24	p0	2024-09-19 22:22:46	map.h	16	19	if out of bounds ,return false, triggers false\nchecks if map is created --> check in main\ncheck if k is non neg\nget functions dont, want these to randomly change.
115d18bb	f24	p0	2024-09-20 01:43:48	block.cpp	3	3	constructor
115d18bb	f24	p0	2024-09-20 01:43:48	block.cpp	7	7	E = empty
115d18bb	f24	p0	2024-09-20 01:43:48	block.cpp	10	10	nothing to deallocate
115d18bb	f24	p0	2024-09-20 01:43:48	block.h	1	1	class map;
115d18bb	f24	p0	2024-09-20 01:43:48	block.h	12	12	no need to make private since assume valid inputs. always need access and manipulation access from map class.
115d18bb	f24	p0	2024-09-20 01:43:48	block.h	18	20	should assign valid value to both ? no return always assume valid.\nall potentials should update together, cannot change one potential only at a time. restrict manipulation access\nshouldnt be able to set state without updateding the whole grid. restrict manipuation access.
115d18bb	f24	p0	2024-09-20 01:43:48	block.h	24	29	friend void map::computePotential();\nfriend class map;\nget position\nset position\nset pot\nget state();
115d18bb	f24	p0	2024-09-20 01:43:48	main.cpp	28	28	DC this
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	3	3	#include "block.h" //?
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	10	10	make map ptr
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	12	13	array of array of blocks\narray of blocks
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	15	15	for each block give coords
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	22	22	deallocates all block arrays
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	27	27	deallocates array of block arrays
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	34	35	for all block, recalculate\nreinit potential
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	37	38	checks all blocks again\nif there is something causing potential and is not block itself
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	65	67	if (X < 0 || Y < 0 || X >= n || Y >= m){ // if coords out of bounds\nreturn false;\n> .>>> check in main
115d18bb	f24	p0	2024-09-20 01:43:48	map.cpp	72	73	checks for map existance in main\notherwise, for each block
115d18bb	f24	p0	2024-09-20 01:43:48	map.h	16	19	if out of bounds ,return false, triggers false\nchecks if map is created --> check in main\ncheck if k is non neg\nget functions dont, want these to randomly change.
115d18bb	f24	p0	2024-09-20 01:44:28	block.cpp	3	3	constructor
115d18bb	f24	p0	2024-09-20 01:44:28	block.cpp	7	7	E = empty
115d18bb	f24	p0	2024-09-20 01:44:28	block.cpp	10	10	nothing to deallocate
115d18bb	f24	p0	2024-09-20 01:44:28	block.h	1	1	class map;
115d18bb	f24	p0	2024-09-20 01:44:28	block.h	12	12	no need to make private since assume valid inputs. always need access and manipulation access from map class.
115d18bb	f24	p0	2024-09-20 01:44:28	block.h	18	20	should assign valid value to both ? no return always assume valid.\nall potentials should update together, cannot change one potential only at a time. restrict manipulation access\nshouldnt be able to set state without updateding the whole grid. restrict manipuation access.
115d18bb	f24	p0	2024-09-20 01:44:28	block.h	24	29	friend void map::computePotential();\nfriend class map;\nget position\nset position\nset pot\nget state();
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	3	3	#include "block.h" //?
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	10	10	make map ptr
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	12	13	array of array of blocks\narray of blocks
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	15	15	for each block give coords
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	22	22	deallocates all block arrays
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	27	27	deallocates array of block arrays
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	34	35	for all block, recalculate\nreinit potential
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	37	38	checks all blocks again\nif there is something causing potential and is not block itself
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	65	67	if (X < 0 || Y < 0 || X >= n || Y >= m){ // if coords out of bounds\nreturn false;\n> .>>> check in main
115d18bb	f24	p0	2024-09-20 01:44:28	map.cpp	72	73	checks for map existance in main\notherwise, for each block
115d18bb	f24	p0	2024-09-20 01:44:28	map.h	16	19	if out of bounds ,return false, triggers false\nchecks if map is created --> check in main\ncheck if k is non neg\nget functions dont, want these to randomly change.
115d18bb	f24	p0	2024-09-20 01:50:50	block.cpp	3	3	constructor
115d18bb	f24	p0	2024-09-20 01:50:50	block.cpp	7	7	E = empty
115d18bb	f24	p0	2024-09-20 01:50:50	block.cpp	10	10	nothing to deallocate
115d18bb	f24	p0	2024-09-20 01:50:50	block.h	1	1	class map;
115d18bb	f24	p0	2024-09-20 01:50:50	block.h	12	12	no need to make private since assume valid inputs. always need access and manipulation access from map class.
115d18bb	f24	p0	2024-09-20 01:50:50	block.h	18	20	should assign valid value to both ? no return always assume valid.\nall potentials should update together, cannot change one potential only at a time. restrict manipulation access\nshouldnt be able to set state without updateding the whole grid. restrict manipuation access.
115d18bb	f24	p0	2024-09-20 01:50:50	block.h	24	29	friend void map::computePotential();\nfriend class map;\nget position\nset position\nset pot\nget state();
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	3	3	#include "block.h" //?
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	10	10	make map ptr
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	12	13	array of array of blocks\narray of blocks
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	15	15	for each block give coords
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	22	22	deallocates all block arrays
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	27	27	deallocates array of block arrays
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	34	35	for all block, recalculate\nreinit potential
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	37	38	checks all blocks again\nif there is something causing potential and is not block itself
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	64	66	if (X < 0 || Y < 0 || X >= n || Y >= m){ // if coords out of bounds\nreturn false;\n> .>>> check in main
115d18bb	f24	p0	2024-09-20 01:50:50	map.cpp	71	72	checks for map existance in main\notherwise, for each block
115d18bb	f24	p0	2024-09-20 01:50:50	map.h	16	19	if out of bounds ,return false, triggers false\nchecks if map is created --> check in main\ncheck if k is non neg\nget functions dont, want these to randomly change.
115d18bb	f24	p0	2024-09-20 02:09:50	block.cpp	3	3	constructor
115d18bb	f24	p0	2024-09-20 02:09:50	block.cpp	7	7	E = empty G = Goal O = Obstacle
115d18bb	f24	p0	2024-09-20 02:09:50	block.cpp	10	10	nothing to deallocate
115d18bb	f24	p0	2024-09-20 02:09:50	block.h	18	19	double get_potential();\nchar get_state();
115d18bb	f24	p0	2024-09-20 02:09:50	main.cpp	14	14	Check if an 2d array already exists, if so deallocate.
115d18bb	f24	p0	2024-09-20 02:09:50	map.cpp	9	9	make map ptr
115d18bb	f24	p0	2024-09-20 02:09:50	map.cpp	11	12	array of array of blocks\narray of blocks
115d18bb	f24	p0	2024-09-20 02:09:50	map.cpp	14	14	for each block give coords
115d18bb	f24	p0	2024-09-20 02:09:50	map.cpp	21	21	deallocates all block arrays
115d18bb	f24	p0	2024-09-20 02:09:50	map.cpp	26	26	deallocates array of block arrays
115d18bb	f24	p0	2024-09-20 02:09:50	map.cpp	33	34	for all block, recalculate\nreinit potential
115d18bb	f24	p0	2024-09-20 02:09:50	map.cpp	36	37	checks all blocks again\nif there is something causing potential and is not block itself
115d18bb	f24	p0	2024-09-20 02:09:50	map.cpp	66	67	checks for map existance in main\notherwise, for each block
115d18bb	f24	p0	2024-09-22 22:31:50	block.cpp	3	5	constructor\nx_pos = 0;\ny_pos = 0;
115d18bb	f24	p0	2024-09-22 22:31:50	block.cpp	7	7	E = empty G = Goal O = Obstacle
115d18bb	f24	p0	2024-09-22 22:31:50	block.cpp	10	10	nothing to deallocate
115d18bb	f24	p0	2024-09-22 22:31:50	block.cpp	12	15	void block::setCoords(int X, int Y){\nx_pos = X;\ny_pos = Y;\n}
115d18bb	f24	p0	2024-09-22 22:31:50	block.h	5	6	int x_pos;\nint y_pos;
115d18bb	f24	p0	2024-09-22 22:31:50	block.h	9	9	void setCoords(int X, int Y);
115d18bb	f24	p0	2024-09-22 22:31:50	main.cpp	14	14	Check if an 2d array already exists, if so deallocate.
115d18bb	f24	p0	2024-09-22 22:31:50	map.cpp	9	9	make map ptr
115d18bb	f24	p0	2024-09-22 22:31:50	map.cpp	11	12	array of array of blocks\narray of blocks
115d18bb	f24	p0	2024-09-22 22:31:50	map.cpp	14	16	for (int y= 0; y<m; y++){  // for each block give coords\nmyMap[x][y].setCoords(x,y);\n}
115d18bb	f24	p0	2024-09-22 22:31:50	map.cpp	21	21	deallocates all block arrays
115d18bb	f24	p0	2024-09-22 22:31:50	map.cpp	26	26	deallocates array of block arrays
115d18bb	f24	p0	2024-09-22 22:31:50	map.cpp	33	34	for all block, recalculate\nreinit potential
115d18bb	f24	p0	2024-09-22 22:31:50	map.cpp	36	37	checks all blocks again\nif there is something causing potential and is not block itself
115d18bb	f24	p0	2024-09-22 22:31:50	map.cpp	66	67	checks for map existance in main\notherwise, for each block
115d18bb	f24	p0	2024-09-23 19:11:01	block.cpp	3	5	constructor\nx_pos = 0;\ny_pos = 0;
115d18bb	f24	p0	2024-09-23 19:11:01	block.cpp	7	7	E = empty G = Goal O = Obstacle
115d18bb	f24	p0	2024-09-23 19:11:01	block.cpp	10	10	nothing to deallocate
115d18bb	f24	p0	2024-09-23 19:11:01	block.cpp	12	15	void block::setCoords(int X, int Y){\nx_pos = X;\ny_pos = Y;\n}
115d18bb	f24	p0	2024-09-23 19:11:01	block.h	5	6	int x_pos;\nint y_pos;
115d18bb	f24	p0	2024-09-23 19:11:01	block.h	9	9	void setCoords(int X, int Y);
115d18bb	f24	p0	2024-09-23 19:11:01	main.cpp	14	14	Check if an 2d array already exists, if so deallocate.
115d18bb	f24	p0	2024-09-23 19:11:01	map.cpp	9	9	make map ptr
115d18bb	f24	p0	2024-09-23 19:11:01	map.cpp	11	12	array of array of blocks\narray of blocks
115d18bb	f24	p0	2024-09-23 19:11:01	map.cpp	14	16	for (int y= 0; y<m; y++){  // for each block give coords\nmyMap[x][y].setCoords(x,y);\n}
115d18bb	f24	p0	2024-09-23 19:11:01	map.cpp	21	21	deallocates all block arrays
115d18bb	f24	p0	2024-09-23 19:11:01	map.cpp	26	26	deallocates array of block arrays
115d18bb	f24	p0	2024-09-23 19:11:01	map.cpp	33	34	for all block, recalculate\nreinit potential
115d18bb	f24	p0	2024-09-23 19:11:01	map.cpp	36	37	checks all blocks again\nif there is something causing potential and is not block itself
115d18bb	f24	p0	2024-09-23 19:11:01	map.cpp	66	67	checks for map existance in main\notherwise, for each block
1354d72c	f24	p0	2024-09-23 22:57:28	cell.cpp	4	4	default constructor
1354d72c	f24	p0	2024-09-23 22:57:28	cell.hpp	9	9	stores x and y component
1354d72c	f24	p0	2024-09-23 22:57:28	cell.hpp	11	11	constructors (parameterized and default)
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	5	5	TODO: if map already exists, delete first then allocate new one
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	9	9	constant K = 1 by default
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	18	19	dynamically allocate memory for a new 2D array\nstd::cout << "creating new" << std::endl;
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	25	25	Initialize each cell with its x and y coordinates
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	39	39	TODO: recompute potential at every cell after updating k value
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	42	42	update k to the new value
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	44	44	Recompute potential at every cell in grid
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	47	47	Reset the potential at the current cell before recomputation
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	51	51	Skip if the current cell is a goal or an obstacle
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	56	56	Recompute the potential vector due to goals
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	69	69	Recompute the potential vector due to obstacles
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	92	92	std::cout << "cells[][]: " << cells << std::endl;
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	101	101	Recompute potential at every cell in grid
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	104	105	Update the potential vector at the current cell\npotential is zero for a goal cell, and handles division by 0
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	125	125	override in case cell is already a goal
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	129	129	Recompute potential at every cell in grid
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	132	133	Update the potential vector at the current cell\npotential is zero for an obstacle cell, and handles division by 0
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	139	139	increase in potential, no negative sign
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	177	177	DEBUGGING FUNCTIONS
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	179	179	DEBUGGING print the board
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	186	186	std::cout << "Row " << i << std::endl;
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	198	199	temporary inclusion for debugging potential values with rounding\n#include <iomanip>
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	201	201	DEBUGGING print the board
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	204	204	std::cout << std::fixed << std::setprecision(5);
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	216	216	DEBUGGING print the board
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	223	223	std::cout << "Row " << i << std::endl;
1354d72c	f24	p0	2024-09-23 22:57:28	grid.cpp	236	236	std::cout << " (" << x << ", " << y << ") |";
1354d72c	f24	p0	2024-09-23 22:57:28	grid.hpp	7	7	member functions
1354d72c	f24	p0	2024-09-23 22:57:28	grid.hpp	15	15	debugging functions
1354d72c	f24	p0	2024-09-23 22:57:28	grid.hpp	20	20	destructor
1354d72c	f24	p0	2024-09-23 22:57:28	grid.hpp	26	26	constant
1354d72c	f24	p0	2024-09-23 22:57:28	main.cpp	7	11	DEBUGGING\ngrid grid(5, 5);\ngrid.add_goal(2,2);\ngrid.print_obs_goals();\ngrid.print_potential();
1354d72c	f24	p0	2024-09-23 22:57:28	main.cpp	29	29	matrix.print_obs_goals(); // debugging
1354d72c	f24	p0	2024-09-23 22:57:28	main.cpp	40	40	matrix.print_obs_goals();   // debugging
17a06620	f24	p0	2024-09-23 03:37:32	main.cpp	6	7	2D array for potential in x direction\n2D array for potential in y direction
17a06620	f24	p0	2024-09-23 03:37:32	main.cpp	11	11	function to calculate potential at one point
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	6	7	Grid for x-component of potential\nGrid for y-component of potential
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	11	11	Private method to calculate potential
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	14	15	No potential at the goal/obstacle position itself\nNegative for goals, positive for obstacles
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	19	19	Constructor
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	22	22	Destructor to free memory
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	27	27	Create a new map with N rows and M columns
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	29	29	Clear old data if any
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	35	36	Initialize with 0\nInitialize with 0
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	41	41	Add a goal (G) or obstacle (O) at position (X, Y)
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	48	48	Update potentials based on this new goal or obstacle
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	59	59	Move command to print the potential at (X, Y)
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	64	64	Simply print the raw potential values without formatting
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	69	70	Clear the entire grid\nClear the entire grid
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	73	74	Output failure if there is no map\nExit the function if there's nothing to clear
17a06620	f24	p0	2024-09-23 03:37:32	test.cpp	89	89	Update the constant K and recompute potentials
17a06620	f24	p0	2024-09-23 03:40:29	main.cpp	6	7	2D array for potential in x direction\n2D array for potential in y direction
17a06620	f24	p0	2024-09-23 03:40:29	main.cpp	11	11	function to calculate potential at one point
17a06620	f24	p0	2024-09-23 14:47:47	main.cpp	6	7	2D array for potential in x direction\n2D array for potential in y direction
17a06620	f24	p0	2024-09-23 14:47:47	main.cpp	11	11	function to calculate potential at one point
17a06620	f24	p0	2024-09-23 15:23:51	main.cpp	6	7	2D array for potential in x direction\n2D array for potential in y direction
17a06620	f24	p0	2024-09-23 15:23:51	main.cpp	11	11	function to calculate potential at one point
17a06620	f24	p0	2024-09-23 17:09:00	main.cpp	6	7	2D array for potential in x direction\n2D array for potential in y direction
17a06620	f24	p0	2024-09-23 17:09:00	main.cpp	11	11	function to calculate potential at one point
17a06620	f24	p0	2024-09-23 17:47:04	main.cpp	6	7	2D array for potential in x direction\n2D array for potential in y direction
17a06620	f24	p0	2024-09-23 17:47:04	main.cpp	11	11	function to calculate potential at one point
19ec2936	f24	p0	2024-09-21 22:54:06	Map.cpp	74	77	if(grid[y][x].getPx() == 0 && grid[y][x].getPy() == 0){\ndouble potential = calculatePotential(x, y);\ngrid[y][x].updatePotential(potential);\n}
19ec2936	f24	p0	2024-09-21 23:05:58	Map.cpp	74	77	if(grid[y][x].getPx() == 0 && grid[y][x].getPy() == 0){\ndouble potential = calculatePotential(x, y);\ngrid[y][x].updatePotential(potential);\n}
19ec2936	f24	p0	2024-09-23 10:59:47	Coordinate.cpp	4	4	Initializes the coordinate with no obstacle, no goal, and potential values (px, py) set to 0.
19ec2936	f24	p0	2024-09-23 10:59:47	Coordinate.cpp	7	7	getter for all private values
19ec2936	f24	p0	2024-09-23 10:59:47	Coordinate.cpp	13	13	If set to obstacle, it cannot be a goal at the same time, so isGoal is set to false.
19ec2936	f24	p0	2024-09-23 10:59:47	Coordinate.cpp	19	19	If set to goal, it cannot be an obstacle at the same time, so isObstacle is set to false.
19ec2936	f24	p0	2024-09-23 10:59:47	Coordinate.cpp	25	25	Sets both x-direction and y-direction potentials (px, py) to the given potential value.
19ec2936	f24	p0	2024-09-23 10:59:47	Coordinate.cpp	31	31	Resets the potential values (px, py) to 0 and marks the coordinate as neither a goal nor an obstacle.
19ec2936	f24	p0	2024-09-23 12:35:46	Coordinate.cpp	4	4	Initializes the coordinate with no obstacle, no goal, and potential values (px, py) set to 0.
19ec2936	f24	p0	2024-09-23 12:35:46	Coordinate.cpp	7	7	getter for all private values
19ec2936	f24	p0	2024-09-23 12:35:46	Coordinate.cpp	13	13	If set to obstacle, it cannot be a goal at the same time, so isGoal is set to false.
19ec2936	f24	p0	2024-09-23 12:35:46	Coordinate.cpp	19	19	If set to goal, it cannot be an obstacle at the same time, so isObstacle is set to false.
19ec2936	f24	p0	2024-09-23 12:35:46	Coordinate.cpp	25	25	Sets both x-direction and y-direction potentials (px, py) to the given potential value.
19ec2936	f24	p0	2024-09-23 12:35:46	Coordinate.cpp	31	31	Resets the potential values (px, py) to 0 and marks the coordinate as neither a goal nor an obstacle.
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	4	4	supporting files
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	7	7	using namespace std;
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	12	12	creating objects
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	15	15	string for input commands
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	18	18	grid dimensions
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	21	21	G or O
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	28	28	setting initial k value
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	33	33	calling constructor
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	38	38	recalculating potential for each new point added
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	46	46	clearing the grid
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	51	51	updating k value
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	55	55	exiting loop
1bba64f3	f24	p0	2024-09-23 17:32:21	project0_main.cpp	63	63	catching and cleaning memory
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	5	5	using namespace std;
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	9	9	constructor - must do return in the main loop
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	12	12	clear any existing grids
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	15	15	input variable assignment
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	19	20	allocate memory for the new grid\ninstantiate new pointer to row N
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	23	23	instantiate new element on a row (column) M
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	26	26	initialize each cell with an empty space
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	30	30	same thing but with the potential map
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	34	34	Two doubles for ⟨Px, Py⟩ for each cell
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	37	38	Initialize Px\nInitialize Py
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	43	43	destructor
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	47	47	moved from prior clear function
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	65	65	note: no create function since the grid creation is done in the constructor
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	67	68	inserts a point (goal or object)\n??????? ok
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	70	70	if the coordinates are in-bounds
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	74	75	goal = G, obstacle = O\nrecalculate after placing a P or O
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	82	82	clears the relevant maps
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	87	87	no grid to call clear on
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	95	95	reset grid cell values
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	97	99	resetting potential map values\npx\npy
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	106	106	updates the value of K in potential calculations
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	116	116	if k is a negative value
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	119	119	calculates potential values
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	122	122	resetting potentials for every grip space
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	127	128	resetting px\nresetting py
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	132	132	calculate potentials based on goals and obstacles
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	141	141	for calculation of proximity for a goal
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	145	145	avoiding division by zero
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	147	149	check equation for correctness on paper again,\n-Px\n-Py
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	157	158	+Px\n-Py
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	167	167	outputting potential coordinates
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	170	170	if the coordinates are in-bounds
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.cpp	177	177	note: no actual movement of the robot
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	1	2	Instantiating classes and variables\nProject0.hpp
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	10	10	Grid Class Definition
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	14	14	member variables
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	20	22	public variables\nneed to be accessed by Robot class\nsame situation as above
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	24	24	constructor
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	27	27	creates a new grid and potential map
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	30	30	inserts a point (goal or object)
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	33	33	clears the maps
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	36	36	updates the value of K in potential calculations
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	39	39	destructor
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	42	42	calculates potential values
1bba64f3	f24	p0	2024-09-23 17:32:21	project0.h	45	45	returns potential coordinates
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	4	4	supporting files
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	7	7	using namespace std;
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	12	12	creating objects
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	15	15	string for input commands
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	18	18	grid dimensions
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	21	21	G or O
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	28	28	setting initial k value
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	33	33	calling constructor
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	38	38	recalculating potential for each new point added
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	46	46	clearing the grid
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	51	51	updating k value
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	55	55	exiting loop
1bba64f3	f24	p0	2024-09-23 19:05:10	project0_main.cpp	63	63	catching and cleaning memory
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	5	5	using namespace std;
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	9	9	constructor - must do return in the main loop
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	12	12	clear any existing grids
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	15	15	input variable assignment
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	19	20	allocate memory for the new grid\ninstantiate new pointer to row N
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	23	23	instantiate new element on a row (column) M
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	26	26	initialize each cell with an empty space
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	30	30	same thing but with the potential map
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	34	34	Two doubles for ⟨Px, Py⟩ for each cell
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	37	38	Initialize Px\nInitialize Py
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	43	43	destructor
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	47	47	moved from prior clear function
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	65	65	note: no create function since the grid creation is done in the constructor
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	67	68	inserts a point (goal or object)\n??????? ok
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	70	70	if the coordinates are in-bounds
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	74	75	goal = G, obstacle = O\nrecalculate after placing a P or O
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	82	82	clears the relevant maps
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	87	87	no grid to call clear on
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	95	95	reset grid cell values
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	97	99	resetting potential map values\npx\npy
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	106	106	updates the value of K in potential calculations
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	116	116	if k is a negative value
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	119	119	calculates potential values
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	122	122	resetting potentials for every grip space
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	127	128	resetting px\nresetting py
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	132	132	calculate potentials based on goals and obstacles
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	141	141	for calculation of proximity for a goal
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	145	145	avoiding division by zero
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	147	149	check equation for correctness on paper again,\n-Px\n-Py
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	157	158	+Px\n-Py
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	167	167	outputting potential coordinates
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	170	170	if the coordinates are in-bounds
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.cpp	177	177	note: no actual movement of the robot
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	1	2	Instantiating classes and variables\nProject0.hpp
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	10	10	Grid Class Definition
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	14	14	member variables
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	20	22	public variables\nneed to be accessed by Robot class\nsame situation as above
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	24	24	constructor
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	27	27	creates a new grid and potential map
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	30	30	inserts a point (goal or object)
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	33	33	clears the maps
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	36	36	updates the value of K in potential calculations
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	39	39	destructor
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	42	42	calculates potential values
1bba64f3	f24	p0	2024-09-23 19:05:10	project0.h	45	45	returns potential coordinates
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	4	4	supporting files
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	7	7	using namespace std;
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	12	12	creating objects
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	15	15	string for input commands
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	18	18	grid dimensions
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	21	21	G or O
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	23	23	potential array of size 2
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	31	31	setting initial k value
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	36	36	calling constructor
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	41	41	add a point
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	50	50	clearing the grid
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	55	55	updating k value
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	59	59	exiting loop
1bba64f3	f24	p0	2024-09-23 19:37:18	project0_main.cpp	67	67	catching and cleaning memory
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	5	5	using namespace std;
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	9	9	constructor - must do return in the main loop
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	12	12	clear any existing grids
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	15	15	input variable assignment
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	24	25	allocate memory for the new grid\ninstantiate new pointer to row N
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	28	28	instantiate new element on a row (column) M
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	31	31	initialize each cell with an empty space
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	35	35	same thing but with the potential map
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	39	39	Two doubles for ⟨Px, Py⟩ for each cell
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	42	43	Initialize Px\nInitialize Py
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	50	50	destructor
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	54	54	moved from prior clear function
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	72	72	note: no create function since the grid creation is done in the constructor
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	74	75	inserts a point (goal or object)\n??????? ok
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	77	77	if the coordinates are in-bounds
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	81	82	goal = G, obstacle = O\nrecalculate after placing a P or O
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	89	89	clears the relevant maps
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	94	94	no grid to call clear on
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	102	102	reset grid cell values
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	104	106	resetting potential map values\npx\npy
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	113	113	updates the value of K in potential calculations
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	123	123	if k is a negative value
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	126	126	calculates potential values
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	129	129	resetting potentials for every grip space
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	134	135	resetting px\nresetting py
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	139	139	calculate potentials based on goals and obstacles
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	148	148	for calculation of proximity for a goal
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	152	152	avoiding division by zero
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	154	156	check equation for correctness on paper again,\n-Px\n-Py
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	164	165	+Px\n-Py
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	174	174	outputting potential coordinates
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	177	177	if the coordinates are in-bounds
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.cpp	184	184	note: no actual movement of the robot
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	1	2	Instantiating classes and variables\nProject0.hpp
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	10	10	Grid Class Definition
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	14	14	member variables
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	21	23	public variables\nneed to be accessed by Robot class\nsame situation as above
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	25	25	constructor
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	28	28	inserts a point (goal or object)
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	31	31	clears the maps
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	34	34	updates the value of K in potential calculations
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	37	37	destructor
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	40	40	calculates potential values
1bba64f3	f24	p0	2024-09-23 19:37:18	project0.h	43	43	returns potential coordinates
1db9dd36	f24	p0	2024-09-18 22:17:38	main.cpp	16	16	string to store commands
1db9dd36	f24	p0	2024-09-18 22:17:38	main.cpp	20	20	instantiate PotentialField object
1db9dd36	f24	p0	2024-09-18 22:17:38	main.cpp	26	26	get inputs
1db9dd36	f24	p0	2024-09-18 22:17:38	main.cpp	30	30	create the grid
1db9dd36	f24	p0	2024-09-18 22:17:38	main.cpp	35	35	get inputs
1db9dd36	f24	p0	2024-09-18 22:17:38	main.cpp	46	46	get inputs
1db9dd36	f24	p0	2024-09-18 22:17:38	main.cpp	59	59	get inputs
1db9dd36	f24	p0	2024-09-18 22:17:38	main.cpp	67	67	get next command
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	22	22	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	25	25	set dimensions
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	29	29	set K
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	32	32	allocate height
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	34	34	iterate through height to allocate width
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	37	37	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	39	39	initialize with values of 0
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	50	50	check if coordinates are valid
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	56	57	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	62	62	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	65	65	skip if the cell is the goal cell
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	71	71	update object type at the given coordinates
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	141	142	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.cpp	148	151	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.h	15	15	constructor
1db9dd36	f24	p0	2024-09-18 22:17:38	PotentialField.h	18	18	destructor;
1db9dd36	f24	p0	2024-09-18 22:17:47	main.cpp	16	16	string to store commands
1db9dd36	f24	p0	2024-09-18 22:17:47	main.cpp	20	20	instantiate PotentialField object
1db9dd36	f24	p0	2024-09-18 22:17:47	main.cpp	26	26	get inputs
1db9dd36	f24	p0	2024-09-18 22:17:47	main.cpp	30	30	create the grid
1db9dd36	f24	p0	2024-09-18 22:17:47	main.cpp	35	35	get inputs
1db9dd36	f24	p0	2024-09-18 22:17:47	main.cpp	46	46	get inputs
1db9dd36	f24	p0	2024-09-18 22:17:47	main.cpp	59	59	get inputs
1db9dd36	f24	p0	2024-09-18 22:17:47	main.cpp	67	67	get next command
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	22	22	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	25	25	set dimensions
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	29	29	set K
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	32	32	allocate height
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	34	34	iterate through height to allocate width
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	37	37	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	39	39	initialize with values of 0
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	50	50	check if coordinates are valid
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	56	57	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	62	62	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	65	65	skip if the cell is the goal cell
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	71	71	update object type at the given coordinates
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	141	142	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.cpp	148	151	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.h	15	15	constructor
1db9dd36	f24	p0	2024-09-18 22:17:47	PotentialField.h	18	18	destructor;
1db9dd36	f24	p0	2024-09-18 22:19:59	main.cpp	16	16	string to store commands
1db9dd36	f24	p0	2024-09-18 22:19:59	main.cpp	20	20	instantiate PotentialField object
1db9dd36	f24	p0	2024-09-18 22:19:59	main.cpp	26	26	get inputs
1db9dd36	f24	p0	2024-09-18 22:19:59	main.cpp	30	30	create the grid
1db9dd36	f24	p0	2024-09-18 22:19:59	main.cpp	35	35	get inputs
1db9dd36	f24	p0	2024-09-18 22:19:59	main.cpp	46	46	get inputs
1db9dd36	f24	p0	2024-09-18 22:19:59	main.cpp	59	59	get inputs
1db9dd36	f24	p0	2024-09-18 22:19:59	main.cpp	67	67	get next command
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	22	22	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	25	25	set dimensions
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	29	29	set K
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	32	32	allocate height
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	34	34	iterate through height to allocate width
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	37	37	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	39	39	initialize with values of 0
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	50	50	check if coordinates are valid
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	56	57	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	62	62	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	65	65	skip if the cell is the goal cell
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	71	71	update object type at the given coordinates
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	141	142	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.cpp	148	151	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.h	15	15	constructor
1db9dd36	f24	p0	2024-09-18 22:19:59	PotentialField.h	18	18	destructor;
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	5	5	enum to allow switch case using input strings
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	7	7	converts input command strings to command type
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	18	18	string to store commands
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	22	22	instantiate PotentialField object
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	25	25	keep program running until EXIT is reached
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	29	29	get inputs
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	33	33	create the grid
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	38	38	get inputs
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	44	44	add point
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	49	49	get inputs
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	53	53	print potential
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	58	58	clear grid
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	63	63	get inputs
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	66	66	update value of K
1db9dd36	f24	p0	2024-09-19 00:24:57	main.cpp	71	71	get next command
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	15	15	iterate through each row
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	17	17	iterate through each pair in row
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	19	19	deallocate innermost array
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	22	22	deallocate row array
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	25	25	deallocate outermost array
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	30	30	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	33	33	set dimensions
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	37	37	set K
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	40	40	allocate height
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	42	42	iterate through height to allocate width
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	45	45	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	47	47	initialize with values of 0
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	58	58	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	64	65	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	70	70	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	73	73	skip if the cell in which the new object is being placed
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	79	79	update object type at the given coordinates
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	95	95	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	100	100	get potential at given coordinates
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	103	103	print potential (twice)
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	110	110	grid must already be initialized to call this function
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	115	115	iterate through grid and set all values to 0.0
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	129	129	newK must be a positive value
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	135	136	all potentials must be updated by dividing by\noldK and multiplying by newK
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	139	139	iterate through array and multiply all potentials by newK / oldK
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	146	146	update K
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	155	155	return true if x and y are both with the dimensions of grid
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	161	162	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	168	171	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.cpp	177	177	add potential due to new object at given coordinates
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	6	6	static constants to reprsent goals and obstacles
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	9	9	dimensions of grid
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	11	11	3D array to represent the map
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	13	13	constant used for potential calculations
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	16	17	helper functions that don't need to be accessed\noutside of the scope of the class
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	19	19	deallocates the grid
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	21	21	checks if a pair of coordinates is within the grid
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	23	23	recomputes the potential for a grid cell given a newly placed object
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	27	27	trivial constructor
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	30	30	destructor;
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	33	33	initialize values of PotentialField object
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	36	36	add goal or obstacle to field at given coordinates
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	39	39	prints the potential at the given coordinates
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	42	42	sets all values in grid to 0.0
1db9dd36	f24	p0	2024-09-19 00:24:57	PotentialField.h	45	45	updates value of K
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	5	5	enum to allow switch case using input strings
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	7	7	converts input command strings to command type
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	18	18	string to store commands
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	22	22	instantiate PotentialField object
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	25	25	keep program running until EXIT is reached
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	29	29	get inputs
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	33	33	create the grid
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	38	38	get inputs
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	44	44	add point
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	49	49	get inputs
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	53	53	print potential
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	58	58	clear grid
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	63	63	get inputs
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	66	66	update value of K
1db9dd36	f24	p0	2024-09-19 00:40:22	main.cpp	71	71	get next command
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	15	15	iterate through each row
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	17	17	iterate through each pair in row
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	19	19	deallocate innermost array
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	22	22	deallocate row array
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	25	25	deallocate outermost array
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	30	30	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	33	33	set dimensions
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	37	37	set K
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	40	40	allocate height
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	42	42	iterate through height to allocate width
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	45	45	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	47	47	initialize with values of 0
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	58	58	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	64	65	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	70	70	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	73	73	skip if the cell in which the new object is being placed
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	79	79	update object type at the given coordinates
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	95	95	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	100	100	get potential at given coordinates
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	103	103	print potential (twice)
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	110	110	grid must already be initialized to call this function
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	115	115	iterate through grid and set all values to 0.0
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	129	129	newK must be a positive value
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	135	136	all potentials must be updated by dividing by\noldK and multiplying by newK
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	139	139	iterate through array and multiply all potentials by newK / oldK
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	146	146	update K
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	155	155	return true if x and y are both with the dimensions of grid
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	161	162	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	168	171	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.cpp	177	177	add potential due to new object at given coordinates
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	6	6	static constants to reprsent goals and obstacles
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	9	9	dimensions of grid
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	11	11	3D array to represent the map
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	13	13	constant used for potential calculations
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	16	17	helper functions that don't need to be accessed\noutside of the scope of the class
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	19	19	deallocates the grid
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	21	21	checks if a pair of coordinates is within the grid
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	23	23	recomputes the potential for a grid cell given a newly placed object
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	27	27	trivial constructor
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	30	30	destructor;
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	33	33	initialize values of PotentialField object
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	36	36	add goal or obstacle to field at given coordinates
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	39	39	prints the potential at the given coordinates
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	42	42	sets all values in grid to 0.0
1db9dd36	f24	p0	2024-09-19 00:40:22	PotentialField.h	45	45	updates value of K
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	5	5	enum to allow switch case using input strings
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	7	7	converts input command strings to command type
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	18	18	string to store commands
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	22	22	instantiate PotentialField object
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	25	25	keep program running until EXIT is reached
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	29	29	get inputs
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	33	33	create the grid
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	38	38	get inputs
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	44	44	add point
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	49	49	get inputs
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	53	53	print potential
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	58	58	clear grid
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	63	63	get inputs
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	66	66	update value of K
1db9dd36	f24	p0	2024-09-19 00:45:46	main.cpp	71	71	get next command
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	15	15	iterate through each row
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	17	17	iterate through each pair in row
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	19	19	deallocate innermost array
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	22	22	deallocate row array
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	25	25	deallocate outermost array
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	30	30	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	33	33	set dimensions
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	37	37	set K
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	40	40	allocate height
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	42	42	iterate through height to allocate width
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	45	45	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	47	47	initialize with values of 0
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	58	58	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	64	65	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	70	70	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	73	73	skip if the cell in which the new object is being placed
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	79	79	update object type at the given coordinates
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	95	95	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	100	100	get potential at given coordinates
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	103	103	print potential (twice)
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	110	110	grid must already be initialized to call this function
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	115	115	iterate through grid and set all values to 0.0
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	129	129	newK must be a positive value
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	135	136	all potentials must be updated by dividing by\noldK and multiplying by newK
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	139	139	iterate through array and multiply all potentials by newK / oldK
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	146	146	update K
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	155	155	return true if x and y are both with the dimensions of grid
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	161	162	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	168	171	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.cpp	177	177	add potential due to new object at given coordinates
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	6	6	static constants to reprsent goals and obstacles
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	9	9	dimensions of grid
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	11	11	3D array to represent the map
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	13	13	constant used for potential calculations
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	16	17	helper functions that don't need to be accessed\noutside of the scope of the class
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	19	19	deallocates the grid
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	21	21	checks if a pair of coordinates is within the grid
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	23	23	recomputes the potential for a grid cell given a newly placed object
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	27	27	trivial constructor
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	30	30	destructor;
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	33	33	initialize values of PotentialField object
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	36	36	add goal or obstacle to field at given coordinates
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	39	39	prints the potential at the given coordinates
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	42	42	sets all values in grid to 0.0
1db9dd36	f24	p0	2024-09-19 00:45:46	PotentialField.h	45	45	updates value of K
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	5	5	enum to allow switch case using input strings
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	7	7	converts input command strings to command type
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	18	18	string to store commands
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	22	22	instantiate PotentialField object
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	25	25	keep program running until EXIT is reached
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	29	29	get inputs
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	33	33	create the grid
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	38	38	get inputs
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	44	44	add point
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	49	49	get inputs
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	53	53	print potential
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	58	58	clear grid
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	63	63	get inputs
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	66	66	update value of K
1db9dd36	f24	p0	2024-09-19 01:12:33	main.cpp	71	71	get next command
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	15	15	iterate through each row
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	17	17	iterate through each pair in row
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	19	19	deallocate innermost array
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	22	22	deallocate row array
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	25	25	deallocate outermost array
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	30	30	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	33	33	set dimensions
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	37	37	set K
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	40	40	allocate height
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	42	42	iterate through height to allocate width
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	45	45	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	47	47	initialize with values of 0
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	58	58	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	64	65	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	70	70	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	73	73	skip if the cell in which the new object is being placed
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	79	79	update object type at the given coordinates
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	95	95	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	100	100	get potential at given coordinates
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	103	103	print potential (twice)
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	110	110	grid must already be initialized to call this function
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	115	115	iterate through grid and set all values to 0.0
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	129	129	newK must be a positive value
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	135	136	all potentials must be updated by dividing by\noldK and multiplying by newK
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	139	139	iterate through array and multiply all potentials by newK / oldK
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	146	146	update K
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	155	155	return true if x and y are both with the dimensions of grid
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	161	162	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	168	171	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.cpp	177	177	add potential due to new object at given coordinates
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	6	6	static constants to reprsent goals and obstacles
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	9	9	dimensions of grid
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	11	11	3D array to represent the map
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	13	13	constant used for potential calculations
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	16	17	helper functions that don't need to be accessed\noutside of the scope of the class
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	19	19	deallocates the grid
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	21	21	checks if a pair of coordinates is within the grid
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	23	23	recomputes the potential for a grid cell given a newly placed object
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	27	27	trivial constructor
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	30	30	destructor;
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	33	33	initialize values of PotentialField object
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	36	36	add goal or obstacle to field at given coordinates
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	39	39	prints the potential at the given coordinates
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	42	42	sets all values in grid to 0.0
1db9dd36	f24	p0	2024-09-19 01:12:33	PotentialField.h	45	45	updates value of K
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	5	5	enum to allow switch case using input strings
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	7	7	converts input command strings to command type
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	18	18	string to store commands
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	22	22	instantiate PotentialField object
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	25	25	keep program running until EXIT is reached
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	29	29	get inputs
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	33	33	create the grid
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	38	38	get inputs
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	44	44	add point
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	49	49	get inputs
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	53	53	print potential
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	58	58	clear grid
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	63	63	get inputs
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	66	66	update value of K
1db9dd36	f24	p0	2024-09-19 01:15:25	main.cpp	71	71	get next command
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	15	15	iterate through each row
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	17	17	iterate through each pair in row
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	19	19	deallocate innermost array
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	22	22	deallocate row array
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	25	25	deallocate outermost array
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	30	30	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	33	33	set dimensions
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	37	37	set K
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	40	40	allocate height
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	42	42	iterate through height to allocate width
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	45	45	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	47	47	initialize with values of 0
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	58	58	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	64	65	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	70	70	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	73	73	skip if the cell in which the new object is being placed
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	79	79	update object type at the given coordinates
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	95	95	check if coordinates are valid
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	100	100	get potential at given coordinates
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	103	103	print potential (twice)
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	110	110	grid must already be initialized to call this function
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	115	115	iterate through grid and set all values to 0.0
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	129	129	newK must be a positive value
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	135	136	all potentials must be updated by dividing by\noldK and multiplying by newK
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	139	139	iterate through array and multiply all potentials by newK / oldK
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	146	146	update K
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	155	155	return true if x and y are both with the dimensions of grid
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	161	162	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	168	171	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.cpp	177	177	add potential due to new object at given coordinates
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	6	6	static constants to reprsent goals and obstacles
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	9	9	dimensions of grid
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	11	11	3D array to represent the map
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	13	13	constant used for potential calculations
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	16	17	helper functions that don't need to be accessed\noutside of the scope of the class
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	19	19	deallocates the grid
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	21	21	checks if a pair of coordinates is within the grid
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	23	23	recomputes the potential for a grid cell given a newly placed object
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	27	27	trivial constructor
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	30	30	destructor;
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	33	33	initialize values of PotentialField object
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	36	36	add goal or obstacle to field at given coordinates
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	39	39	prints the potential at the given coordinates
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	42	42	sets all values in grid to 0.0
1db9dd36	f24	p0	2024-09-19 01:15:25	PotentialField.h	45	45	updates value of K
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	5	5	enum to allow switch case using input strings
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	7	7	converts input command strings to command type
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	18	18	string to store commands
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	22	22	instantiate PotentialField object
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	25	25	keep program running until EXIT is reached
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	29	29	get inputs
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	33	33	create the grid
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	38	38	get inputs
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	44	44	add point
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	49	49	get inputs
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	53	53	print potential
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	58	58	clear grid
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	63	63	get inputs
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	66	66	update value of K
1db9dd36	f24	p0	2024-09-22 21:30:39	main.cpp	71	71	get next command
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	15	15	iterate through each row
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	17	17	iterate through each pair in row
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	19	19	deallocate innermost array
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	22	22	deallocate row array
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	25	25	deallocate outermost array
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	30	30	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	33	33	set dimensions
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	37	37	set K
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	40	40	allocate height
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	42	42	iterate through height to allocate width
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	45	45	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	47	47	initialize with values of 0
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	58	58	check if coordinates are valid
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	64	65	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	70	70	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	73	73	skip if the cell in which the new object is being placed
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	79	79	update object type at the given coordinates
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	95	95	check if coordinates are valid
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	100	100	get potential at given coordinates
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	103	103	print potential (twice)
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	110	110	grid must already be initialized to call this function
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	115	115	iterate through grid and set all values to 0.0
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	129	129	newK must be a positive value
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	135	136	all potentials must be updated by dividing by\noldK and multiplying by newK
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	139	139	iterate through array and multiply all potentials by newK / oldK
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	146	146	update K
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	155	155	return true if x and y are both with the dimensions of grid
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	161	162	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	168	171	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.cpp	177	177	add potential due to new object at given coordinates
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	6	6	static constants to reprsent goals and obstacles
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	9	9	dimensions of grid
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	11	11	3D array to represent the map
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	13	13	constant used for potential calculations
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	16	17	helper functions that don't need to be accessed\noutside of the scope of the class
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	19	19	deallocates the grid
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	21	21	checks if a pair of coordinates is within the grid
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	23	23	recomputes the potential for a grid cell given a newly placed object
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	27	27	trivial constructor
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	30	30	destructor;
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	33	33	initialize values of PotentialField object
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	36	36	add goal or obstacle to field at given coordinates
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	39	39	prints the potential at the given coordinates
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	42	42	sets all values in grid to 0.0
1db9dd36	f24	p0	2024-09-22 21:30:39	PotentialField.h	45	45	updates value of K
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	5	5	enum to allow switch case using input strings
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	7	7	converts input command strings to command type
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	18	18	string to store commands
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	22	22	instantiate PotentialField object
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	25	25	keep program running until EXIT is reached
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	29	29	get inputs
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	33	33	create the grid
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	38	38	get inputs
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	44	44	add point
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	49	49	get inputs
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	53	53	print potential
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	58	58	clear grid
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	63	63	get inputs
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	66	66	update value of K
1db9dd36	f24	p0	2024-10-02 01:47:09	main.cpp	71	71	get next command
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	16	16	iterate through each row
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	19	19	iterate through each pair in row
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	22	22	deallocate innermost array
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	25	25	deallocate row array
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	28	28	deallocate outermost array
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	34	34	if a grid already exists, we have to delete it first
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	38	38	set dimensions
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	42	42	set K
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	45	45	allocate height
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	47	47	iterate through height to allocate width
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	51	51	iterate through width to allocate arrays of size 2
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	54	54	initialize with values of 0
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	66	66	check if coordinates are valid
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	73	74	if the point that we are trying to place is\nalready there, return
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	82	82	iterate through each cell and update the potential
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	87	87	skip if the cell in which the new object is being placed
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	94	94	update object type at the given coordinates
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	112	112	check if coordinates are valid
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	118	118	get potential at given coordinates
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	121	121	print potential (twice)
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	129	129	grid must already be initialized to call this function
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	135	135	iterate through grid and set all values to 0.0
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	152	152	newK must be a positive value
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	159	160	all potentials must be updated by dividing by\noldK and multiplying by newK
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	163	163	iterate through array and multiply all potentials by newK / oldK
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	172	172	update K
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	182	182	return true if x and y are both with the dimensions of grid
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	189	190	x and y are coordinates for the cell to be updated\nxG and yG are coordinates for the newly placed goal or obstacle
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	196	199	if object in cell is opposite of object being added,\ne.g. cell has obstacle and we are adding goal,\nwe need to double the potential being added\nto cancel out the potential from the original object
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.cpp	206	206	add potential due to new object at given coordinates
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	6	6	static constants to reprsent goals and obstacles
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	9	9	dimensions of grid
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	11	11	3D array to represent the map
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	13	13	constant used for potential calculations
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	16	17	helper functions that don't need to be accessed\noutside of the scope of the class
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	19	19	deallocates the grid
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	21	21	checks if a pair of coordinates is within the grid
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	23	23	recomputes the potential for a grid cell given a newly placed object
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	27	27	trivial constructor
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	30	30	destructor;
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	33	33	initialize values of PotentialField object
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	36	36	add goal or obstacle to field at given coordinates
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	39	39	prints the potential at the given coordinates
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	42	42	sets all values in grid to 0.0
1db9dd36	f24	p0	2024-10-02 01:47:09	PotentialField.h	45	45	updates value of K
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.cpp	6	6	Constructor
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.cpp	19	19	Destructor
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.cpp	29	29	Add Point
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.cpp	32	32	Out of bounds
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.cpp	37	38	Add new goal or obstacle (overwrite)\nG is -1 and O is 1
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.cpp	46	46	Recompute potentials for every (n, m)
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.cpp	53	53	Calculating potential at point i
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.cpp	75	75	Out of bounds
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.cpp	80	80	Return potential
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.h	9	13	Basics\nConstructor\nDo not copy\nDo not move\nDestructor
1e6f1e18	f24	p0	2024-09-23 18:21:47	grid.h	15	15	Functions
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.cpp	6	6	Constructor
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.cpp	19	19	Destructor
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.cpp	29	29	Add Point
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.cpp	32	32	Out of bounds
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.cpp	37	38	Add new goal or obstacle (overwrite)\nG is -1 and O is 1
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.cpp	46	46	Recompute potentials for every (n, m)
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.cpp	53	53	Calculating potential at point i
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.cpp	75	75	Out of bounds
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.cpp	80	80	Return potential
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.h	9	13	Basics\nConstructor\nDo not copy\nDo not move\nDestructor
1e6f1e18	f24	p0	2024-09-23 18:29:06	grid.h	15	15	Functions
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	6	6	Constructor
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	19	19	Destructor
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	29	29	Add Point
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	32	32	Out of bounds
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	37	38	Add new goal or obstacle (overwrite)\nG is -1 and O is 1
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	46	46	Recompute potentials for every (n, m)
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	53	53	Calculating potential at point i
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	75	75	Out of bounds
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	80	80	Return potential
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	94	94	Recompute potentials for every (n, m)
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.cpp	101	101	Calculating potential at point i
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.h	9	13	Basics\nConstructor\nDo not copy\nDo not move\nDestructor
1e6f1e18	f24	p0	2024-09-23 18:46:05	grid.h	15	15	Functions
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	6	6	Constructor
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	19	19	Destructor
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	29	29	Add Point
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	32	32	Out of bounds
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	37	38	Add new goal or obstacle (overwrite)\nG is -1 and O is 1
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	46	46	Recompute potentials for every (n, m)
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	53	53	Calculating potential at point i
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	75	75	Out of bounds
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	80	80	Return potential
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	94	94	Recompute potentials for every (n, m)
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.cpp	101	101	Calculating potential at point i
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.h	9	11	Basics\nConstructor\nDestructor
1e6f1e18	f24	p0	2024-09-23 22:32:39	grid.h	13	13	Functions
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	6	6	Constructor
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	19	19	Destructor
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	29	29	Add Point
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	32	32	Out of bounds
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	37	38	Add new goal or obstacle (overwrite)\nG is -1 and O is 1
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	46	46	Recompute potentials for every (n, m)
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	53	53	Calculating potential at point i
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	75	75	Out of bounds
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	80	80	Return potential
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	94	94	Recompute potentials for every (n, m)
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.cpp	101	101	Calculating potential at point i
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.h	9	11	Basics\nConstructor\nDestructor
1e6f1e18	f24	p0	2024-09-23 22:47:02	grid.h	13	13	Functions
202a5c76	f24	p0	2024-09-21 23:31:39	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:31:39	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:31:39	Project0.cpp	17	18	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-21 23:31:39	Project0.cpp	24	25	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-21 23:31:39	Project0.cpp	103	103	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:31:39	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:31:39	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-21 23:31:39	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-21 23:37:04	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:37:04	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:37:04	Project0.cpp	17	18	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-21 23:37:04	Project0.cpp	24	25	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-21 23:37:04	Project0.cpp	103	103	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:37:04	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:37:04	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-21 23:37:04	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-21 23:37:07	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:37:07	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:37:07	Project0.cpp	17	18	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-21 23:37:07	Project0.cpp	24	25	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-21 23:37:07	Project0.cpp	103	103	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:37:07	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:37:07	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-21 23:37:07	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-21 23:37:16	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:37:16	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:37:16	Project0.cpp	17	18	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-21 23:37:16	Project0.cpp	24	25	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-21 23:37:16	Project0.cpp	103	103	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:37:16	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:37:16	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-21 23:37:16	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-21 23:37:28	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:37:28	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:37:28	Project0.cpp	17	18	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-21 23:37:28	Project0.cpp	24	25	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-21 23:37:28	Project0.cpp	103	103	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-21 23:37:28	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-21 23:37:28	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-21 23:37:28	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-22 00:05:55	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:05:55	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:05:55	Project0.cpp	17	18	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-22 00:05:55	Project0.cpp	24	25	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-22 00:05:55	Project0.cpp	103	103	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:05:55	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:05:55	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-22 00:05:55	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-22 00:13:41	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:13:41	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:13:41	Project0.cpp	18	19	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-22 00:13:41	Project0.cpp	25	26	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-22 00:13:41	Project0.cpp	104	104	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:13:41	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:13:41	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-22 00:13:41	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-22 00:23:50	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:23:50	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:23:50	Project0.cpp	18	19	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-22 00:23:50	Project0.cpp	25	26	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-22 00:23:50	Project0.cpp	104	104	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:23:50	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:23:50	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-22 00:23:50	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-22 00:28:03	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:28:03	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:28:03	Project0.cpp	18	19	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-22 00:28:03	Project0.cpp	25	26	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-22 00:28:03	Project0.cpp	104	104	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:28:03	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:28:03	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-22 00:28:03	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-22 00:28:31	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:28:31	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:28:31	Project0.cpp	18	19	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-22 00:28:31	Project0.cpp	25	26	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-22 00:28:31	Project0.cpp	107	107	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-22 00:28:31	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 00:28:31	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-22 00:28:31	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-22 21:36:33	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 21:36:33	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-22 21:36:33	Project0.cpp	18	19	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-22 21:36:33	Project0.cpp	25	26	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-22 21:36:33	Project0.cpp	107	107	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-22 21:36:33	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 21:36:33	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-22 21:36:33	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-22 21:45:29	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 21:45:29	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-22 21:45:29	Project0.cpp	18	19	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-22 21:45:29	Project0.cpp	25	26	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-22 21:45:29	Project0.cpp	107	107	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-22 21:45:29	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-22 21:45:29	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-22 21:45:29	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-23 00:26:00	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 00:26:00	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-23 00:26:00	Project0.cpp	18	19	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-23 00:26:00	Project0.cpp	25	26	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-23 00:26:00	Project0.cpp	107	107	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-23 00:26:00	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 00:26:00	Project0.hpp	15	18	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-23 00:26:00	Project0.hpp	42	42	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-23 11:00:01	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 11:00:01	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-23 11:00:01	Project0.cpp	21	22	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-23 11:00:01	Project0.cpp	28	29	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-23 11:00:01	Project0.cpp	111	111	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-23 11:00:01	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 11:00:01	Project0.hpp	16	19	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-23 11:00:01	Project0.hpp	43	43	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-23 13:17:33	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 13:17:33	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-23 13:17:33	Project0.cpp	21	22	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-23 13:17:33	Project0.cpp	28	29	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-23 13:17:33	Project0.cpp	111	111	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-23 13:17:33	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 13:17:33	Project0.hpp	16	19	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-23 13:17:33	Project0.hpp	43	43	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-23 13:49:44	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 13:49:44	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-23 13:49:44	Project0.cpp	21	22	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-23 13:49:44	Project0.cpp	28	29	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-23 13:49:44	Project0.cpp	111	111	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-23 13:49:44	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 13:49:44	Project0.hpp	16	19	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-23 13:49:44	Project0.hpp	43	43	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-23 16:53:14	main.cpp	19	22	}else if (g1 == nullptr){\nstd::cout << "failure" << std::endl;\ncontinue;\n}
202a5c76	f24	p0	2024-09-23 16:53:14	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 16:53:14	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-23 16:53:14	Project0.cpp	21	22	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-23 16:53:14	Project0.cpp	28	29	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-23 16:53:14	Project0.cpp	111	111	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-23 16:53:14	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 16:53:14	Project0.hpp	16	19	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-23 16:53:14	Project0.hpp	43	43	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
202a5c76	f24	p0	2024-09-23 17:06:55	main.cpp	34	34	g1->deleteGrid();
202a5c76	f24	p0	2024-09-23 17:06:55	Project0.cpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 17:06:55	Project0.cpp	7	7	---------------------------------------------- Pos class functions ---------------------------------------------------
202a5c76	f24	p0	2024-09-23 17:06:55	Project0.cpp	21	22	---------------------------------------------------------------- Grid class functions --------------------------------------------------\nDefault Constructor (part of create function)
202a5c76	f24	p0	2024-09-23 17:06:55	Project0.cpp	28	29	Create function\nNeed to flip here since I messed up the column & rows for Grid_array
202a5c76	f24	p0	2024-09-23 17:06:55	Project0.cpp	111	111	----------------------------------------------------------------- Helper functions ----------------------------------------------------------------
202a5c76	f24	p0	2024-09-23 17:06:55	Project0.hpp	1	3	\nCreated by vivih on 2024-09-18.\n
202a5c76	f24	p0	2024-09-23 17:06:55	Project0.hpp	16	19	void setType(char T);\nchar getType() const;\ndouble getPotential();\nvoid setPotential(double p1, double p2);
202a5c76	f24	p0	2024-09-23 17:06:55	Project0.hpp	43	43	C___DATA_STRUCTURES_AND_ALGORITHMS_PROJECT0_HPP
207763d7	f24	p0	2024-09-23 12:04:32	main.cpp	12	12	Read the entire line
207763d7	f24	p0	2024-09-23 12:04:32	tools.cpp	9	9	if there is already a map created
207763d7	f24	p0	2024-09-23 12:04:32	tools.cpp	15	15	create a new map
207763d7	f24	p0	2024-09-23 12:04:32	tools.cpp	50	50	recompute potential of all points in map
207763d7	f24	p0	2024-09-23 12:04:32	tools.cpp	71	71	complexity is O(1) = O(NXM) since it accesses a 2D array's index
207763d7	f24	p0	2024-09-23 12:04:32	tools.h	1	1	Include guard
207763d7	f24	p0	2024-09-23 12:14:27	main.cpp	12	12	Read the entire line
207763d7	f24	p0	2024-09-23 12:14:27	tools.cpp	9	9	if there is already a map created
207763d7	f24	p0	2024-09-23 12:14:27	tools.cpp	15	15	create a new map
207763d7	f24	p0	2024-09-23 12:14:27	tools.cpp	50	50	recompute potential of all points in map
207763d7	f24	p0	2024-09-23 12:14:27	tools.cpp	71	71	complexity is O(1) = O(NXM) since it accesses a 2D array's index
207763d7	f24	p0	2024-09-23 12:14:27	tools.h	1	1	Include guard
207763d7	f24	p0	2024-09-23 12:22:55	main.cpp	12	12	Read the entire line
207763d7	f24	p0	2024-09-23 12:22:55	tools.cpp	9	9	if there is already a map created
207763d7	f24	p0	2024-09-23 12:22:55	tools.cpp	15	15	create a new map
207763d7	f24	p0	2024-09-23 12:22:55	tools.cpp	50	50	recompute potential of all points in map
207763d7	f24	p0	2024-09-23 12:22:55	tools.cpp	71	71	complexity is O(1) = O(NXM) since it accesses a 2D array's index
207763d7	f24	p0	2024-09-23 12:22:55	tools.h	1	1	Include guard
207763d7	f24	p0	2024-09-23 12:33:56	main.cpp	12	12	Read the entire line
207763d7	f24	p0	2024-09-23 12:33:56	tools.cpp	9	9	if there is already a map created
207763d7	f24	p0	2024-09-23 12:33:56	tools.cpp	15	15	create a new map
207763d7	f24	p0	2024-09-23 12:33:56	tools.cpp	50	50	recompute potential of all points in map
207763d7	f24	p0	2024-09-23 12:33:56	tools.cpp	71	71	complexity is O(1) = O(NXM) since it accesses a 2D array's index
207763d7	f24	p0	2024-09-23 12:33:56	tools.h	1	1	Include guard
207763d7	f24	p0	2024-09-23 12:46:02	main.cpp	12	12	Read the entire line
207763d7	f24	p0	2024-09-23 12:46:02	tools.cpp	9	9	if there is already a map created
207763d7	f24	p0	2024-09-23 12:46:02	tools.cpp	15	15	create a new map
207763d7	f24	p0	2024-09-23 12:46:02	tools.cpp	50	50	recompute potential of all points in map
207763d7	f24	p0	2024-09-23 12:46:02	tools.cpp	71	71	complexity is O(1) = O(NXM) since it accesses a 2D array's index
207763d7	f24	p0	2024-09-23 12:46:02	tools.h	1	1	Include guard
207763d7	f24	p0	2024-09-23 13:02:43	main.cpp	12	12	Read the entire line
207763d7	f24	p0	2024-09-23 13:02:43	tools.cpp	32	32	Add boundary checks
207763d7	f24	p0	2024-09-23 13:02:43	tools.cpp	68	68	complexity is O(1) = O(NXM) since it accesses a 2D array's index
207763d7	f24	p0	2024-09-23 13:02:43	tools.h	1	1	Include guard
207763d7	f24	p0	2024-09-23 14:15:49	main.cpp	12	12	Read the entire line
207763d7	f24	p0	2024-09-23 14:15:49	tools.cpp	32	32	Add boundary checks
207763d7	f24	p0	2024-09-23 14:15:49	tools.cpp	68	68	complexity is O(1) = O(NXM) since it accesses a 2D array's index
207763d7	f24	p0	2024-09-23 14:15:49	tools.h	1	1	Include guard
21141cc4	f24	p0	2024-10-04 15:03:58	main.cpp	20	20	if input is "G", then goal (1), and obstacle (-1) if O
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	4	4	Initialize Potential Field to nullptr, K to 1
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	7	7	Delete map to clean up memory usage
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	13	13	delete the previous map if existing
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	28	28	Adds new point at a specified location, either a goal or an obstacle
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	40	40	potential at the location of the goal/obstacle is 0
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	46	46	calculating potential
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	54	54	move the robot and output potential at that point
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	72	72	clear all objects on the grid
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	88	88	update the value of k and recalculate potential
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	101	101	Update potentials with new K
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	109	109	delete the grid
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	113	113	free each row
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	115	115	free the array of pointers
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.cpp	121	121	debug function
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.h	5	7	Grid to be dynamically allocated later\nDimensions of the grid\nConstant used in calculation of potential
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.h	13	13	creates the grid to specifications
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.h	15	15	adds markers (either goal or obstacles) at a point on the grid
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.h	17	17	clears the grid
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.h	19	19	deletes the grid when necessary
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.h	21	21	changes the value of k and recalculates the potential
21141cc4	f24	p0	2024-10-04 15:03:58	PotentialField.h	23	23	computing the lowest potential on the grid
21141cc4	f24	p0	2024-10-29 15:04:16	main.cpp	20	20	if input is "G", then goal (1), and obstacle (-1) if O
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	4	4	Initialize Potential Field to nullptr, K to 1
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	7	7	Delete map to clean up memory usage
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	13	13	delete the previous map if existing
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	28	28	Adds new point at a specified location, either a goal or an obstacle
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	40	40	potential at the location of the goal/obstacle is 0
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	46	46	calculating potential
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	54	54	move the robot and output potential at that point
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	72	72	clear all objects on the grid
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	88	88	update the value of k and recalculate potential
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	101	101	Update potentials with new K
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	109	109	delete the grid
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	113	113	free each row
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	115	115	free the array of pointers
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.cpp	121	121	debug function
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.h	5	7	Grid to be dynamically allocated later\nDimensions of the grid\nConstant used in calculation of potential
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.h	13	13	creates the grid to specifications
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.h	15	15	adds markers (either goal or obstacles) at a point on the grid
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.h	17	17	clears the grid
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.h	19	19	deletes the grid when necessary
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.h	21	21	changes the value of k and recalculates the potential
21141cc4	f24	p0	2024-10-29 15:04:16	PotentialField.h	23	23	computing the lowest potential on the grid
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	85	85	cout<< potential[0] << "+" << grid[i][j]<<"*"<<constant_K<<"/sqrt("<<pow((a_x-i),2)<<"+"<<pow((a_y-j),2)<<")" <<endl;
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	140	141	string file_name = "test_basic.txt";\nifstream file(file_name);
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	147	147	if (file.is_open()) {
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	149	150	while (getline(file, line)) {\ncout << line << endl;
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	158	158	int x_range = stoi(inputs[1]);
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	160	160	int y_range = stoi(inputs[2]);
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	170	172	string target = inputs[1];\nint x_index = stoi(inputs[2]);\nint y_index = stoi(inputs[3]);
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	198	199	int x_index = stoi(inputs[1]);\nint y_index = stoi(inputs[2]);
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	233	233	float constant_K = stof(inputs[1]);
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	260	263	file.close();\n} else {\ncout << "ERROR: cannot open file "  << file_name << endl;\n}
22768b6e	f24	p0	2024-09-04 13:11:38	main.cpp	265	265	cout << "Program finish" << endl;
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	85	85	cout<< potential[0] << "+" << grid[i][j]<<"*"<<constant_K<<"/sqrt("<<pow((a_x-i),2)<<"+"<<pow((a_y-j),2)<<")" <<endl;
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	140	141	string file_name = "test_basic.txt";\nifstream file(file_name);
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	147	147	if (file.is_open()) {
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	149	150	while (getline(file, line)) {\ncout << line << endl;
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	158	158	int x_range = stoi(inputs[1]);
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	160	160	int y_range = stoi(inputs[2]);
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	170	172	string target = inputs[1];\nint x_index = stoi(inputs[2]);\nint y_index = stoi(inputs[3]);
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	198	199	int x_index = stoi(inputs[1]);\nint y_index = stoi(inputs[2]);
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	233	233	float constant_K = stof(inputs[1]);
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	260	263	file.close();\n} else {\ncout << "ERROR: cannot open file "  << file_name << endl;\n}
22768b6e	f24	p0	2024-09-04 14:22:06	main.cpp	265	265	cout << "Program finish" << endl;
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	85	85	cout<< potential[0] << "+" << grid[i][j]<<"*"<<constant_K<<"/sqrt("<<pow((a_x-i),2)<<"+"<<pow((a_y-j),2)<<")" <<endl;
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	140	141	string file_name = "test_basic.txt";\nifstream file(file_name);
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	147	147	if (file.is_open()) {
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	149	150	while (getline(file, line)) {\ncout << line << endl;
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	158	158	int x_range = stoi(inputs[1]);
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	160	160	int y_range = stoi(inputs[2]);
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	170	172	string target = inputs[1];\nint x_index = stoi(inputs[2]);\nint y_index = stoi(inputs[3]);
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	198	199	int x_index = stoi(inputs[1]);\nint y_index = stoi(inputs[2]);
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	233	233	float constant_K = stof(inputs[1]);
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	260	263	file.close();\n} else {\ncout << "ERROR: cannot open file "  << file_name << endl;\n}
22768b6e	f24	p0	2024-09-04 14:31:59	main.cpp	265	265	cout << "Program finish" << endl;
25c90d86	f24	p0	2024-09-20 17:25:37	class1.cpp	1	1	class1.cpp
25c90d86	f24	p0	2024-09-20 17:25:37	class1.cpp	4	4	Constructor
25c90d86	f24	p0	2024-09-20 17:25:37	class1.cpp	7	7	Destructor
25c90d86	f24	p0	2024-09-20 17:25:37	class1.cpp	12	12	Allocate grid
25c90d86	f24	p0	2024-09-20 17:25:37	class1.cpp	18	18	Initialize all potentials to 0
25c90d86	f24	p0	2024-09-20 17:25:37	class1.cpp	22	22	Deallocate grid
25c90d86	f24	p0	2024-09-20 17:25:37	class1.cpp	35	35	Create grid
25c90d86	f24	p0	2024-09-20 17:25:37	class1.cpp	37	39	Clear previous grid if it exists\nAllocate new grid\nOutput success message
25c90d86	f24	p0	2024-09-20 17:25:37	class1.cpp	42	42	Optional: Debugging function to print the grid
25c90d86	f24	p0	2024-09-20 17:25:37	class1.h	1	1	class1.h
25c90d86	f24	p0	2024-09-20 17:25:37	class1.h	10	13	2D array for potential values\nNumber of rows\nNumber of columns\nConstant for potential calculations
25c90d86	f24	p0	2024-09-20 17:25:37	class1.h	15	16	Helper function to allocate the grid\nHelper function to deallocate the grid
25c90d86	f24	p0	2024-09-20 17:25:37	class1.h	19	22	Constructor\nDestructor\nMethod to create the grid\nOptional: for debugging purposes
25c90d86	f24	p0	2024-09-20 17:25:37	class1.h	25	25	CLASS1_H
25c90d86	f24	p0	2024-09-20 17:25:37	project0MainFile.cpp	30	30	Exit the loop
25c90d86	f24	p0	2024-09-20 17:59:50	class1.cpp	1	1	class1.cpp
25c90d86	f24	p0	2024-09-20 17:59:50	class1.cpp	4	4	Constructor
25c90d86	f24	p0	2024-09-20 17:59:50	class1.cpp	7	7	Destructor
25c90d86	f24	p0	2024-09-20 17:59:50	class1.cpp	12	12	Allocate grid
25c90d86	f24	p0	2024-09-20 17:59:50	class1.cpp	18	18	Initialize all potentials to 0
25c90d86	f24	p0	2024-09-20 17:59:50	class1.cpp	22	22	Deallocate grid
25c90d86	f24	p0	2024-09-20 17:59:50	class1.cpp	35	35	Create grid
25c90d86	f24	p0	2024-09-20 17:59:50	class1.cpp	37	39	Clear previous grid if it exists\nAllocate new grid\nOutput success message
25c90d86	f24	p0	2024-09-20 17:59:50	class1.cpp	42	42	Optional: Debugging function to print the grid
25c90d86	f24	p0	2024-09-20 17:59:50	class1.h	1	1	class1.h
25c90d86	f24	p0	2024-09-20 17:59:50	class1.h	10	13	2D array for potential values\nNumber of rows\nNumber of columns\nConstant for potential calculations
25c90d86	f24	p0	2024-09-20 17:59:50	class1.h	15	16	Helper function to allocate the grid\nHelper function to deallocate the grid
25c90d86	f24	p0	2024-09-20 17:59:50	class1.h	19	22	Constructor\nDestructor\nMethod to create the grid\nOptional: for debugging purposes
25c90d86	f24	p0	2024-09-20 17:59:50	class1.h	25	25	CLASS1_H
25c90d86	f24	p0	2024-09-20 17:59:50	project0MainFile.cpp	30	30	Exit the loop
25c90d86	f24	p0	2024-09-21 02:17:32	class1.cpp	1	1	class1.cpp
25c90d86	f24	p0	2024-09-21 02:17:32	class1.cpp	4	4	Constructor
25c90d86	f24	p0	2024-09-21 02:17:32	class1.cpp	7	7	Destructor
25c90d86	f24	p0	2024-09-21 02:17:32	class1.cpp	12	12	Allocate grid
25c90d86	f24	p0	2024-09-21 02:17:32	class1.cpp	18	18	Initialize all potentials to 0
25c90d86	f24	p0	2024-09-21 02:17:32	class1.cpp	22	22	Deallocate grid
25c90d86	f24	p0	2024-09-21 02:17:32	class1.cpp	35	35	Create grid
25c90d86	f24	p0	2024-09-21 02:17:32	class1.cpp	37	39	Clear previous grid if it exists\nAllocate new grid\nOutput success message
25c90d86	f24	p0	2024-09-21 02:17:32	class1.cpp	42	42	Optional: Debugging function to print the grid
25c90d86	f24	p0	2024-09-21 02:17:32	class1.h	1	1	class1.h
25c90d86	f24	p0	2024-09-21 02:17:32	class1.h	10	13	2D array for potential values\nNumber of rows\nNumber of columns\nConstant for potential calculations
25c90d86	f24	p0	2024-09-21 02:17:32	class1.h	15	16	Helper function to allocate the grid\nHelper function to deallocate the grid
25c90d86	f24	p0	2024-09-21 02:17:32	class1.h	19	22	Constructor\nDestructor\nMethod to create the grid\nOptional: for debugging purposes
25c90d86	f24	p0	2024-09-21 02:17:32	class1.h	25	25	CLASS1_H
25c90d86	f24	p0	2024-09-21 02:17:32	project0MainFile.cpp	30	30	Exit the loop
25c90d86	f24	p0	2024-09-21 02:55:14	class1.cpp	1	1	class1.cpp
25c90d86	f24	p0	2024-09-21 02:55:14	class1.cpp	4	4	Constructor
25c90d86	f24	p0	2024-09-21 02:55:14	class1.cpp	7	7	Destructor
25c90d86	f24	p0	2024-09-21 02:55:14	class1.cpp	12	12	Allocate grid
25c90d86	f24	p0	2024-09-21 02:55:14	class1.cpp	18	18	Initialize all potentials to 0
25c90d86	f24	p0	2024-09-21 02:55:14	class1.cpp	22	22	Deallocate grid
25c90d86	f24	p0	2024-09-21 02:55:14	class1.cpp	35	35	Create grid
25c90d86	f24	p0	2024-09-21 02:55:14	class1.cpp	37	39	Clear previous grid if it exists\nAllocate new grid\nOutput success message
25c90d86	f24	p0	2024-09-21 02:55:14	class1.cpp	42	42	Optional: Debugging function to print the grid
25c90d86	f24	p0	2024-09-21 02:55:14	class1.h	1	1	class1.h
25c90d86	f24	p0	2024-09-21 02:55:14	class1.h	10	13	2D array for potential values\nNumber of rows\nNumber of columns\nConstant for potential calculations
25c90d86	f24	p0	2024-09-21 02:55:14	class1.h	15	16	Helper function to allocate the grid\nHelper function to deallocate the grid
25c90d86	f24	p0	2024-09-21 02:55:14	class1.h	19	22	Constructor\nDestructor\nMethod to create the grid\nOptional: for debugging purposes
25c90d86	f24	p0	2024-09-21 02:55:14	class1.h	25	25	CLASS1_H
25c90d86	f24	p0	2024-09-21 02:55:14	project0MainFile.cpp	16	16	Exit the loop
25c90d86	f24	p0	2024-09-21 02:55:14	project0MainFile.cpp	30	30	Exit the loop
25c90d86	f24	p0	2024-09-21 13:10:15	class1.cpp	1	1	class1.cpp
25c90d86	f24	p0	2024-09-21 13:10:15	class1.cpp	4	4	Constructor
25c90d86	f24	p0	2024-09-21 13:10:15	class1.cpp	7	7	Destructor
25c90d86	f24	p0	2024-09-21 13:10:15	class1.cpp	12	12	Allocate grid
25c90d86	f24	p0	2024-09-21 13:10:15	class1.cpp	18	18	Initialize all potentials to 0
25c90d86	f24	p0	2024-09-21 13:10:15	class1.cpp	22	22	Deallocate grid
25c90d86	f24	p0	2024-09-21 13:10:15	class1.cpp	35	35	Create grid
25c90d86	f24	p0	2024-09-21 13:10:15	class1.cpp	37	39	Clear previous grid if it exists\nAllocate new grid\nOutput success message
25c90d86	f24	p0	2024-09-21 13:10:15	class1.cpp	42	42	Optional: Debugging function to print the grid
25c90d86	f24	p0	2024-09-21 13:10:15	class1.h	1	1	class1.h
25c90d86	f24	p0	2024-09-21 13:10:15	class1.h	10	13	2D array for potential values\nNumber of rows\nNumber of columns\nConstant for potential calculations
25c90d86	f24	p0	2024-09-21 13:10:15	class1.h	15	16	Helper function to allocate the grid\nHelper function to deallocate the grid
25c90d86	f24	p0	2024-09-21 13:10:15	class1.h	19	22	Constructor\nDestructor\nMethod to create the grid\nOptional: for debugging purposes
25c90d86	f24	p0	2024-09-21 13:10:15	class1.h	25	25	CLASS1_H
25c90d86	f24	p0	2024-09-21 13:10:15	project0MainFile.cpp	16	16	Exit the loop
25c90d86	f24	p0	2024-09-21 13:10:15	project0MainFile.cpp	30	30	Exit the loop
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	3	3	Utility function to calculate square root without cmath
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	5	6	Handle negative input\nBase cases
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	8	9	Initial guess\nTolerance for precision
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	12	13	Newton's method formula\nCheck for convergence
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	29	29	Clear previous grid if exists
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	36	36	Set potential to (0, 0)
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	65	65	Return dummy value for out of bounds
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	94	94	Reset potentials
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	100	100	Add potential contributions from goals
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	106	107	Ignore the goal position\nUse mySqrt
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	114	114	Add potential contributions from obstacles
25c90d86	f24	p0	2024-09-21 13:36:17	environment.cpp	120	121	Ignore the obstacle position\nUse mySqrt
25c90d86	f24	p0	2024-09-21 13:36:17	environment.h	11	14	2D array for potential values\nList of goals\nList of obstacles\nConstant for potential calculations
25c90d86	f24	p0	2024-09-21 13:36:17	environment.h	28	28	ENVIRONMENT_H
25c90d86	f24	p0	2024-09-21 13:36:17	project0MainFile.cpp	44	44	Exit the loop
25c90d86	f24	p0	2024-09-21 13:36:17	robot.h	8	8	Pointer to the environment
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	4	4	Constructor
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	7	7	Destructor
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	9	9	Ensure memory is freed when the object is destroyed
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	12	12	Function to dynamically create the grid
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	14	14	Delete any existing grid
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	17	17	Set the dimensions
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	21	21	Allocate memory for the grid
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	27	27	Initialize all grid values to 0
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	30	30	Initial potential set to 0
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	34	34	Print success message
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	38	38	Function to delete the grid and free memory
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	49	49	Manual square root calculation using Newton's method
25c90d86	f24	p0	2024-09-21 14:51:48	environment.cpp	56	56	Iteratively improve approximation
25c90d86	f24	p0	2024-09-21 14:51:48	environment.h	6	9	Number of rows in the grid\nNumber of columns in the grid\nConstant value K used in potential calculation\nDynamically allocated 2D array for the grid
25c90d86	f24	p0	2024-09-21 14:51:48	environment.h	11	11	Helper function to free the allocated grid memory
25c90d86	f24	p0	2024-09-21 14:51:48	environment.h	14	14	Helper function to calculate the square root (without cmath)
25c90d86	f24	p0	2024-09-21 14:51:48	environment.h	18	18	Constructor
25c90d86	f24	p0	2024-09-21 14:51:48	environment.h	21	21	Destructor
25c90d86	f24	p0	2024-09-21 14:51:48	environment.h	24	24	Function to create a new grid
25c90d86	f24	p0	2024-09-21 14:51:48	environment.h	27	27	Function to print the grid (for testing purposes)
25c90d86	f24	p0	2024-09-21 14:51:48	project0MainFile.cpp	15	15	Create the grid of size N x M
25c90d86	f24	p0	2024-09-21 14:51:48	project0MainFile.cpp	17	17	Additional commands for POINT, MOVE, CLEAR, etc. will go here later
25c90d86	f24	p0	2024-09-21 14:51:48	project0MainFile.cpp	19	19	Exit the loop
25c90d86	f24	p0	2024-09-21 18:09:22	environment.cpp	15	15	Clean up existing potential if any
25c90d86	f24	p0	2024-09-21 18:09:22	environment.cpp	26	26	Initialize potential
25c90d86	f24	p0	2024-09-21 18:09:22	environment.cpp	31	31	Initialize potential values to 0
25c90d86	f24	p0	2024-09-21 18:09:22	environment.cpp	41	41	Out of bounds
25c90d86	f24	p0	2024-09-21 18:09:22	environment.cpp	45	46	Set potential to 0\nShow success
25c90d86	f24	p0	2024-09-21 18:09:22	environment.cpp	48	48	Invalid point type
25c90d86	f24	p0	2024-09-21 18:09:22	environment.h	8	11	2D dynamically allocated array for potential values\nNumber of rows (N)\nNumber of columns (M)\nConstant K for potential field calculations
25c90d86	f24	p0	2024-09-21 18:09:22	environment.h	14	18	Default constructor\nDestructor\nCreate a new grid\nPrint potential values\nAdd a new point (goal or obstacle)
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	29	29	Initialize potential values to 0
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	34	35	Reset goal count\nReset obstacle count
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	41	41	Out of bounds
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	50	50	Set potential to 0
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	58	58	Set potential to 0
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	61	61	Invalid point type
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	64	64	Show potential grid after the command
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	68	69	Handle negative input\nSquare root of 0 is 0
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	71	72	Initial estimate\nDefine a tolerance for convergence
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	77	77	Return when close enough
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	79	79	Update estimate
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	86	86	Out of bounds
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	89	89	Calculate potential for every grid cell
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	95	95	Calculate potential due to goals
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	106	106	Calculate potential due to obstacles
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	117	118	Store the computed potential value\nRobot's position has potential 0
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	122	122	Print potential values at (x, y)
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	126	126	Show potential grid after moving
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	133	133	Map not created
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	140	140	Reset potential values to 0
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	147	148	Output success\nShow potential grid after clearing
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	153	153	Invalid K
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	157	157	Update the value of K
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	159	159	Recalculate potentials for the entire grid
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	165	165	Calculate potential due to goals
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	176	176	Calculate potential due to obstacles
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	187	188	Update potential at grid position\nStore the computed potential value
25c90d86	f24	p0	2024-09-21 21:26:05	environment.cpp	192	192	Output success for valid K
25c90d86	f24	p0	2024-09-21 21:26:05	environment.h	9	16	2D dynamically allocated array for potential values\nNumber of rows (N)\nNumber of columns (M)\nConstant K for potential field calculations\nFixed-size array to store goal positions\nFixed-size array to store obstacle positions\nNumber of goals\nNumber of obstacles
25c90d86	f24	p0	2024-09-21 21:26:05	environment.h	19	27	Default constructor\nDestructor\nCreate a new grid\nPrint potential values\nAdd a new point (goal or obstacle)\nMove and calculate potential\nClear all obstacles and goals\nUpdate K value and recalculate potentials\nCustom square root function
25c90d86	f24	p0	2024-09-21 21:26:05	project0MainFile.cpp	16	16	env.print(); // Show potential grid
25c90d86	f24	p0	2024-09-21 21:26:05	project0MainFile.cpp	21	21	env.print(); // Show potential grid
25c90d86	f24	p0	2024-09-21 21:26:05	project0MainFile.cpp	26	26	env.print(); // Show potential grid
25c90d86	f24	p0	2024-09-21 21:26:05	project0MainFile.cpp	30	30	env.print(); // Show potential grid
25c90d86	f24	p0	2024-09-21 21:26:05	project0MainFile.cpp	36	36	env.print(); // Show potential grid
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	29	29	Initialize potential values to 0
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	34	35	Reset goal count\nReset obstacle count
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	41	41	Out of bounds
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	50	50	Set potential to 0
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	58	58	Set potential to 0
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	61	61	Invalid point type
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	64	64	print(); // Commented out to avoid printing the grid
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	68	69	Handle negative input\nSquare root of 0 is 0
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	71	72	Initial estimate\nDefine a tolerance for convergence
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	77	77	Return when close enough
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	79	79	Update estimate
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	86	86	Out of bounds
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	92	92	Calculate potential for every grid cell
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	98	98	Calculate potential due to goals
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	109	109	Calculate potential due to obstacles
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	120	121	Store the computed potential value\nRobot's position has potential 0
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	125	126	Print potential values at (x, y)\nOutput potential values
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	128	128	print(); // Commented out to avoid printing the grid
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	135	135	Map not created
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	142	142	Reset potential values to 0
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	149	150	Output success\nprint(); // Commented out to avoid printing the grid
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	155	155	Invalid K
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	159	159	Update the value of K
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	161	161	Recalculate potentials for the entire grid
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	167	167	Calculate potential due to goals
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	178	178	Calculate potential due to obstacles
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	189	190	Update potential at grid position\nStore the computed potential value
25c90d86	f24	p0	2024-09-21 21:35:36	environment.cpp	194	194	Output success for valid K
25c90d86	f24	p0	2024-09-21 21:35:36	environment.h	9	16	2D dynamically allocated array for potential values\nNumber of rows (N)\nNumber of columns (M)\nConstant K for potential field calculations\nFixed-size array to store goal positions\nFixed-size array to store obstacle positions\nNumber of goals\nNumber of obstacles
25c90d86	f24	p0	2024-09-21 21:35:36	environment.h	19	26	Default constructor\nDestructor\nCreate a new grid\nAdd a new point (goal or obstacle)\nMove and calculate potential\nClear all obstacles and goals\nUpdate K value and recalculate potentials\nCustom square root function
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	30	30	Initialize potential values to 0
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	35	36	Reset goal count\nReset obstacle count
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	42	42	Out of bounds
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	45	45	Overwrite existing goal or obstacle at (x, y)
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	55	55	Invalid point type
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	59	59	Recalculate potential for the entire grid
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	65	65	Calculate potential due to goals
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	76	76	Calculate potential due to obstacles
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	87	88	Update potential for the grid cell\nStore total potential
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	92	92	Indicate successful addition
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	96	97	Handle negative input\nSquare root of 0 is 0
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	99	100	Initial estimate\nDefine a tolerance for convergence
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	105	105	Return when close enough
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	107	107	Update estimate
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	114	114	Out of bounds
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	117	118	Output the potential value at the specified location\nOutput potential values
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	120	120	Return potential at the robot's position
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	125	125	Map not created
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	132	132	Reset potential values to 0
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	139	139	Output success
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	144	144	Invalid K
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	148	148	Update the value of K
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	150	150	Recalculate potentials for the entire grid
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	156	156	Calculate potential due to goals
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	167	167	Calculate potential due to obstacles
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	178	179	Update potential at grid position\nStore the computed potential value
25c90d86	f24	p0	2024-09-22 20:04:01	environment.cpp	183	183	Output success for valid K
25c90d86	f24	p0	2024-09-22 20:04:01	environment.h	8	15	2D dynamically allocated array for potential values\nNumber of rows (N)\nNumber of columns (M)\nConstant K for potential field calculations\nFixed-size array to store goal positions\nFixed-size array to store obstacle positions\nNumber of goals\nNumber of obstacles
25c90d86	f24	p0	2024-09-22 20:04:01	environment.h	18	25	Default constructor\nDestructor\nCreate a new grid\nAdd a new point (goal or obstacle)\nMove and calculate potential\nClear all obstacles and goals\nUpdate K value and recalculate potentials\nCustom square root function
25c90d86	f24	p0	2024-09-22 21:58:26	environment.cpp	39	39	printGrid(); // Commented out
25c90d86	f24	p0	2024-09-22 21:58:26	environment.cpp	63	63	printGrid(); // Commented out
25c90d86	f24	p0	2024-09-22 21:58:26	environment.cpp	97	97	printGrid(); // Commented out
25c90d86	f24	p0	2024-09-22 21:58:26	environment.cpp	116	116	printGrid(); // Commented out
25c90d86	f24	p0	2024-09-22 21:58:26	environment.cpp	129	129	printGrid(); // Commented out
25c90d86	f24	p0	2024-09-22 21:58:26	environment.cpp	148	148	Commented out the entire printGrid function
25c90d86	f24	p0	2024-09-22 21:58:26	environment.h	34	34	void printGrid();
25c90d86	f24	p0	2024-09-23 17:37:39	environment.cpp	35	35	Initialize K to 1.0
25c90d86	f24	p0	2024-09-23 17:37:39	environment.h	34	34	void printGrid();
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	5	5	Constructor: Initializes the environment with default values.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	8	8	Destructor: Cleans up dynamically allocated memory for the potential field.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	13	13	Helper function to clean up the dynamically allocated memory.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	24	24	Creates a new grid of size N x M and initializes all potential values to zero.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	26	26	Edge case: Non-positive dimensions
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	31	31	Free previous memory if it exists.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	33	33	Update the size of the grid.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	37	37	Dynamically allocate the new grid and initialize all cells to 0.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	46	46	Reset constants and flags.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	54	54	Adds a goal ('G') or obstacle ('O') at position (X, Y), if valid.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	68	68	Fail if max obstacles reached
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	83	83	Helper function to check if a given position (x, y) is within the bounds of the grid.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	88	88	Recomputes the potential at every point in the grid based on goals and obstacles.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	107	107	Helper function to compute the potential due to the goal at a given grid point.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	114	114	Negative potential for goals.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	116	116	Zero potential if at the goal location.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	119	119	Helper function to compute the potential due to an obstacle at a given grid point.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	126	126	Positive potential for obstacles.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	128	128	Zero potential if at the obstacle location.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	131	131	Prints the potential at position (X, Y) if valid.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	133	133	Edge case: Out-of-bounds coordinates
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	138	138	Output the potential at the given position.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	142	142	Clears the environment by resetting all potentials and removing goals/obstacles.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	144	144	Edge case: Trying to clear a non-existent grid.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	152	152	Reset all potential values to zero.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	162	162	Updates the constant K and recomputes the potential field.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	164	164	Edge case: K must be positive.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.cpp	170	170	Recompute the potential with the new K value.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	7	8	Constants\nDefine the maximum number of obstacles
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	10	10	Struct to represent a point in the grid (goal or obstacle).
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	18	25	2D dynamically allocated array for the potential grid.\nNumber of rows in the grid.\nNumber of columns in the grid.\nScaling factor for potential calculation.\nCoordinates of the goal point.\nFixed-size array to store obstacle coordinates.\nCount of obstacles added to the environment.\nFlag to indicate if a goal is set.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	27	27	Helper function to recalculate potential across the grid.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	30	30	Helper function to clean up the dynamically allocated memory for potential.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	33	33	Helper function to check if a point (x, y) is within the grid bounds.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	36	36	Helper function to compute the potential contribution from the goal.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	39	39	Helper function to compute the potential contribution from an obstacle.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	43	43	Constructor to initialize the environment.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	46	46	Destructor to free allocated memory.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	49	49	Creates a grid of size N x M.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	52	52	Adds a goal ('G') or an obstacle ('O') at position (X, Y).
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	55	55	Prints the potential value at position (X, Y).
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	58	58	Clears the grid and resets goal/obstacle settings.
25c90d86	f24	p0	2024-09-23 17:57:36	environment.h	61	61	Updates the constant K and recalculates potentials.
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	5	5	Constructor
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	9	9	Destructor
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	19	19	Create a new environment with specified rows and columns
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	46	46	Add a goal or obstacle to the grid
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	82	82	Update the potential field based on the positions of the goals and obstacles
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	88	88	Influence of all goals on the potential field
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	96	96	Influence of goal is negative
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	100	100	Influence of all obstacles on the potential field
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	108	108	Influence of obstacle is positive
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	124	124	Clear the environment, removing all goals and obstacles
25c90d86	f24	p0	2024-09-23 20:00:30	environment.cpp	143	143	Update the influence constant K and refresh the potential field
25c90d86	f24	p0	2024-09-23 20:00:30	environment.h	13	15	Array to store multiple goals\nNumber of goals\nArray to store obstacles
25c90d86	f24	p0	2024-09-23 20:00:30	environment.h	18	18	Update potential field
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	7	7	chatgpt.com/ (accessed September 23, 2024).
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	14	14	Constructor
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	18	18	Destructor
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	28	28	Create a grid of size n x m
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	34	34	if grid exists already delete it
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	40	40	Allocate memory for potential grid
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	59	59	chatgpt.com/ (accessed September 23, 2024).
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	82	82	Add a goal or obstacle to the grid at the specific X,Y point
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	84	84	check if point is on grid
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	89	89	Add goal
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	99	99	Add obstacle
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	114	114	Update the entire grids potential values due to the new goal or obstacle
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	118	118	Update the potential field based on the positions of the goals and obstacles
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	122	122	reset potential at that point to 0
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	124	124	Calculate potential influence from goals
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	132	132	Influence of goal is negative
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	136	136	/ Calculate potential influence from obstacles
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	144	144	Influence of obstacle is positive
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	151	151	// Print potential at specific X,Y position
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	153	153	Ensure the point is on the graph
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	160	160	Clear all goals and obstacles, reset potential field
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	179	179	Update the influence constant K and recalculate the potential field with new K value
25c90d86	f24	p0	2024-09-23 22:13:52	environment.cpp	182	182	K must be positive and greater than 0
25c90d86	f24	p0	2024-09-23 22:13:52	environment.h	9	9	Dynamically allocate 2d array for grid values
25c90d86	f24	p0	2024-09-23 22:13:52	environment.h	13	13	Array to store multiple goals - I'm assuming a resonable max amount of goals
25c90d86	f24	p0	2024-09-23 22:13:52	environment.h	15	15	Array to store obstacles - I'm assuming a reasonable max amount of obstacles
25c90d86	f24	p0	2024-09-23 22:13:52	environment.h	17	17	Update potential field
25c90d86	f24	p0	2024-09-23 22:13:52	environment.h	20	26	Constructor\nDesconstructor\nCREATE command\nPOINT command\nMOVE command\nCLEAR command\nUPDATE command
25ee1121	f24	p0	2024-09-20 22:00:12	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-20 22:00:12	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	21	21	first cell one by one
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	24	24	whole array
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	52	52	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	55	55	allocating array
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	58	58	filling the array
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	61	61	Initialize each Cell, Set->potential to 0
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	69	69	changes the type first
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	79	80	compares the potential val off all cells on the map w respect to (x,y)\nreturns the position of the cell with lowest potentail(where robot should go)
25ee1121	f24	p0	2024-09-20 22:00:12	Class_Functions.cpp	134	134	////////////////////Cell Class
25ee1121	f24	p0	2024-09-20 22:00:12	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-20 22:00:12	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-20 22:00:12	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-20 22:00:12	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-20 22:00:12	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-20 22:00:12	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-20 22:00:12	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-20 23:25:44	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-20 23:25:44	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	24	24	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	52	52	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	55	55	allocating array
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	58	58	filling the array
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	61	61	Initialize each Cell, Set->potential to 0
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	69	69	changes the type first
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	79	80	compares the potential val off all cells on the map w respect to (x,y)\nreturns the position of the cell with lowest potentail(where robot should go)
25ee1121	f24	p0	2024-09-20 23:25:44	Class_Functions.cpp	134	134	////////////////////Cell Class
25ee1121	f24	p0	2024-09-20 23:25:44	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-20 23:25:44	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-20 23:25:44	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-20 23:25:44	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-20 23:25:44	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-20 23:25:44	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-20 23:25:44	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-20 23:34:14	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-20 23:34:14	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	24	24	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	52	52	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	55	55	allocating array
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	58	58	filling the array
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	61	61	Initialize each Cell, Set->potential to 0
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	69	69	changes the type first
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	79	80	compares the potential val off all cells on the map w respect to (x,y)\nreturns the position of the cell with lowest potentail(where robot should go)
25ee1121	f24	p0	2024-09-20 23:34:14	Class_Functions.cpp	134	134	////////////////////Cell Class
25ee1121	f24	p0	2024-09-20 23:34:14	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-20 23:34:14	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-20 23:34:14	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-20 23:34:14	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-20 23:34:14	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-20 23:34:14	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-20 23:34:14	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-20 23:34:32	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-20 23:34:32	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	24	24	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	52	52	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	55	55	allocating array
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	58	58	filling the array
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	61	61	Initialize each Cell, Set->potential to 0
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	69	69	changes the type first
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	79	80	compares the potential val off all cells on the map w respect to (x,y)\nreturns the position of the cell with lowest potentail(where robot should go)
25ee1121	f24	p0	2024-09-20 23:34:32	Class_Functions.cpp	134	134	////////////////////Cell Class
25ee1121	f24	p0	2024-09-20 23:34:32	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-20 23:34:32	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-20 23:34:32	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-20 23:34:32	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-20 23:34:32	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-20 23:34:32	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-20 23:34:32	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-20 23:45:01	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-20 23:45:01	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	24	24	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	52	52	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	55	55	allocating array
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	58	58	filling the array
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	61	61	Initialize each Cell, Set->potential to 0
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	69	69	changes the type first
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	79	80	compares the potential val off all cells on the map w respect to (x,y)\nreturns the position of the cell with lowest potentail(where robot should go)
25ee1121	f24	p0	2024-09-20 23:45:01	Class_Functions.cpp	134	134	////////////////////Cell Class
25ee1121	f24	p0	2024-09-20 23:45:01	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-20 23:45:01	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-20 23:45:01	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-20 23:45:01	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-20 23:45:01	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-20 23:45:01	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-20 23:45:01	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-20 23:53:19	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-20 23:53:19	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	32	32	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	37	37	for goal
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	41	41	for obstacle
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	53	53	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-20 23:53:19	Class_Functions.cpp	135	135	////////////////////Cell Class
25ee1121	f24	p0	2024-09-20 23:53:19	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-20 23:53:19	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-20 23:53:19	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-20 23:53:19	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-20 23:53:19	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-20 23:53:19	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-20 23:53:19	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-20 23:58:41	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-20 23:58:41	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	32	32	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	37	37	for goal
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	41	41	for obstacle
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	53	53	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-20 23:58:41	Class_Functions.cpp	135	135	////////////////////Cell Class
25ee1121	f24	p0	2024-09-20 23:58:41	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-20 23:58:41	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-20 23:58:41	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-20 23:58:41	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-20 23:58:41	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-20 23:58:41	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-20 23:58:41	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 00:03:53	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 00:03:53	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	32	32	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	37	37	for goal
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	41	41	for obstacle
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	53	53	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 00:03:53	Class_Functions.cpp	135	135	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 00:03:53	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 00:03:53	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 00:03:53	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 00:03:53	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 00:03:53	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 00:03:53	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 00:03:53	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 00:16:25	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 00:16:25	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	24	24	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	52	52	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	55	55	allocating array
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	58	58	filling the array
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	61	61	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	69	69	changes the type first
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	79	80	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 00:16:25	Class_Functions.cpp	134	134	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 00:16:25	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 00:16:25	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 00:16:25	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 00:16:25	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 00:16:25	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 00:16:25	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 00:16:25	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 00:24:46	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 00:24:46	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	24	24	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	48	48	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	53	53	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 00:24:46	Class_Functions.cpp	135	135	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 00:24:46	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 00:24:46	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 00:24:46	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 00:24:46	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 00:24:46	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 00:24:46	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 00:24:46	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 01:00:11	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 01:00:11	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	24	24	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	48	48	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	53	53	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 01:00:11	Class_Functions.cpp	135	135	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 01:00:11	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 01:00:11	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-21 01:00:11	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 01:00:11	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 01:00:11	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 01:00:11	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 01:00:11	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 01:00:11	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 01:03:43	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 01:03:43	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	21	21	Delete each Cell object
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	24	24	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	48	48	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	53	53	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 01:03:43	Class_Functions.cpp	135	135	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 01:03:43	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 01:03:43	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-21 01:03:43	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 01:03:43	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 01:03:43	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 01:03:43	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 01:03:43	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 01:03:43	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 01:37:23	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 01:37:23	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	23	23	Delete each Cell object
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	26	26	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	32	32	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	37	37	for goal
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	41	41	for obstacle
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	49	49	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	52	52	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	57	57	allocating array
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	60	60	filling the array
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	63	63	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	71	71	changes the type first
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	81	82	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 01:37:23	Class_Functions.cpp	137	137	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 01:37:23	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 01:37:23	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-21 01:37:23	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 01:37:23	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 01:37:23	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 01:37:23	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 01:37:23	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 01:37:23	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 18:23:49	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 18:23:49	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	48	48	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	51	51	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 18:23:49	Class_Functions.cpp	136	136	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 18:23:49	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 18:23:49	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-21 18:23:49	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 18:23:49	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 18:23:49	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 18:23:49	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 18:23:49	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 18:23:49	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 18:24:03	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 18:24:03	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	48	48	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	51	51	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 18:24:03	Class_Functions.cpp	136	136	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 18:24:03	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 18:24:03	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-21 18:24:03	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 18:24:03	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 18:24:03	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 18:24:03	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 18:24:03	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 18:24:03	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 22:33:38	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 22:33:38	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	48	48	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	51	51	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 22:33:38	Class_Functions.cpp	136	136	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 22:33:38	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 22:33:38	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-21 22:33:38	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 22:33:38	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 22:33:38	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 22:33:38	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 22:33:38	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 22:33:38	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-21 23:02:27	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-21 23:02:27	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	48	48	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	51	51	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-21 23:02:27	Class_Functions.cpp	136	136	////////////////////Cell Class
25ee1121	f24	p0	2024-09-21 23:02:27	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-21 23:02:27	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-21 23:02:27	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-21 23:02:27	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-21 23:02:27	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-21 23:02:27	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-21 23:02:27	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-21 23:02:27	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-22 00:04:36	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-22 00:04:36	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	48	48	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	51	51	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-22 00:04:36	Class_Functions.cpp	136	136	////////////////////Cell Class
25ee1121	f24	p0	2024-09-22 00:04:36	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-22 00:04:36	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-22 00:04:36	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-22 00:04:36	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-22 00:04:36	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-22 00:04:36	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-22 00:04:36	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-22 00:04:36	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-22 00:31:58	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-22 00:31:58	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	48	48	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	51	51	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-22 00:31:58	Class_Functions.cpp	136	136	////////////////////Cell Class
25ee1121	f24	p0	2024-09-22 00:31:58	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-22 00:31:58	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-22 00:31:58	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-22 00:31:58	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-22 00:31:58	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-22 00:31:58	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-22 00:31:58	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-22 00:31:58	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-22 00:34:00	Cell.hpp	9	10	Constructor\n
25ee1121	f24	p0	2024-09-22 00:34:00	Cell.hpp	13	14	Destructor\n
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	48	48	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	51	51	since input is from 0 to N, width will be N+1 which includes 0
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	59	59	filling the array
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	62	62	Initialize each Cell, Set potential to 0
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	70	70	changes the type first
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	80	81	computes the potential val of all cells on the map w respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-22 00:34:00	Class_Functions.cpp	136	136	////////////////////Cell Class
25ee1121	f24	p0	2024-09-22 00:34:00	Main.cpp	7	7	g++ -o test ./Main.cpp ./Class_Functions.cpp
25ee1121	f24	p0	2024-09-22 00:34:00	Main.cpp	12	12	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-22 00:34:00	Map.hpp	12	13	Constructor\n
25ee1121	f24	p0	2024-09-22 00:34:00	Map.hpp	16	17	Destructor\n
25ee1121	f24	p0	2024-09-22 00:34:00	Map.hpp	20	20	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-22 00:34:00	Map.hpp	22	22	using pointers because width and height are determined at runtime
25ee1121	f24	p0	2024-09-22 00:34:00	Map.hpp	24	24	Public Functions
25ee1121	f24	p0	2024-09-22 00:34:00	Map.hpp	35	35	Member Functions
25ee1121	f24	p0	2024-09-22 09:47:09	Cell.hpp	9	9	Constructor
25ee1121	f24	p0	2024-09-22 09:47:09	Cell.hpp	12	12	Destructor
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	25	25	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	31	31	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	36	36	for goal
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	40	40	for obstacle
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	48	48	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	55	55	allocating array
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	61	61	filling the array
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	64	64	Initialize each Cell to blank, Set potential to 0
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	72	72	changes the type of the cell
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	81	82	computes the potential val of all cells on the map with respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	106	106	sets all cells to blank again
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	122	122	recalculates potential using new k
25ee1121	f24	p0	2024-09-22 09:47:09	Class_Functions.cpp	137	137	////////////////////Cell Class
25ee1121	f24	p0	2024-09-22 09:47:09	Main.cpp	10	10	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-22 09:47:09	Map.hpp	12	12	Constructor
25ee1121	f24	p0	2024-09-22 09:47:09	Map.hpp	15	15	Destructor
25ee1121	f24	p0	2024-09-22 09:47:09	Map.hpp	18	18	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-22 09:47:09	Map.hpp	20	20	using pointers since the type of cell and k value and xr yr change dynamically
25ee1121	f24	p0	2024-09-22 09:47:09	Map.hpp	22	22	Public Functions
25ee1121	f24	p0	2024-09-22 09:47:09	Map.hpp	33	33	Member Functions
25ee1121	f24	p0	2024-09-22 09:49:44	Cell.hpp	9	9	Constructor
25ee1121	f24	p0	2024-09-22 09:49:44	Cell.hpp	12	12	Destructor
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	26	26	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	32	32	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	37	37	for goal
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	41	41	for obstacle
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	49	49	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	62	62	filling the array
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	65	65	Initialize each Cell to blank, Set potential to 0
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	73	73	changes the type of the cell
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	82	83	computes the potential val of all cells on the map with respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	107	107	sets all cells to blank again
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	123	123	recalculates potential using new k
25ee1121	f24	p0	2024-09-22 09:49:44	Class_Functions.cpp	138	138	////////////////////Cell Class
25ee1121	f24	p0	2024-09-22 09:49:44	Main.cpp	10	10	initialize to prevent conditional jumps
25ee1121	f24	p0	2024-09-22 09:49:44	Map.hpp	12	12	Constructor
25ee1121	f24	p0	2024-09-22 09:49:44	Map.hpp	15	15	Destructor
25ee1121	f24	p0	2024-09-22 09:49:44	Map.hpp	18	18	Xr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-22 09:49:44	Map.hpp	20	20	using pointers since the type of cell and k value and xr yr change dynamically
25ee1121	f24	p0	2024-09-22 09:49:44	Map.hpp	22	22	Public Functions
25ee1121	f24	p0	2024-09-22 09:49:44	Map.hpp	33	33	Member Functions
25ee1121	f24	p0	2024-09-22 10:38:49	Cell.hpp	9	9	Constructor
25ee1121	f24	p0	2024-09-22 10:38:49	Cell.hpp	12	12	Destructor
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	26	26	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	32	32	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	37	37	for goal
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	41	41	for obstacle
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	49	49	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	62	62	filling the array
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	65	65	Initialize each Cell to blank, Set potential to 0
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	73	73	changes the type of the cell
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	82	83	computes the potential val of all cells on the map with respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	107	107	sets all cells to blank again
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	123	123	recalculates potential using new k
25ee1121	f24	p0	2024-09-22 10:38:49	Class_Functions.cpp	138	138	////////////////////Cell Class
25ee1121	f24	p0	2024-09-22 10:38:49	Map.hpp	12	12	Constructor
25ee1121	f24	p0	2024-09-22 10:38:49	Map.hpp	15	15	Destructor
25ee1121	f24	p0	2024-09-22 10:38:49	Map.hpp	18	18	Public member Functions
25ee1121	f24	p0	2024-09-22 10:38:49	Map.hpp	27	28	Member Variables\nXr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-22 10:38:49	Map.hpp	30	30	using pointers since the type of cell and k value and xr yr change dynamically
25ee1121	f24	p0	2024-09-22 10:38:49	Map.hpp	32	32	Member Functions
25ee1121	f24	p0	2024-09-23 16:32:25	Cell.hpp	9	9	Constructor
25ee1121	f24	p0	2024-09-23 16:32:25	Cell.hpp	12	12	Destructor
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	7	7	/Class Function Definition
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	9	9	////////////////////Map Class
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	22	22	Delete each Cell object
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	26	26	Delete the array of Cell pointers
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	32	32	robot at the same cell as goal or obstacle
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	37	37	for goal
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	41	41	for obstacle
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	49	49	Deleting the map if it exists alr
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	56	56	allocating array
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	62	62	filling the array
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	65	65	Initialize each Cell to blank, Set potential to 0
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	73	73	changes the type of the cell
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	82	83	computes the potential val of all cells on the map with respect to (x,y)robot\nreturns the sum of all potentials
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	107	107	sets all cells to blank again
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	123	123	recalculates potential using new k
25ee1121	f24	p0	2024-09-23 16:32:25	Class_Functions.cpp	138	138	////////////////////Cell Class
25ee1121	f24	p0	2024-09-23 16:32:25	Map.hpp	12	12	Constructor
25ee1121	f24	p0	2024-09-23 16:32:25	Map.hpp	15	15	Destructor
25ee1121	f24	p0	2024-09-23 16:32:25	Map.hpp	18	18	Public member Functions
25ee1121	f24	p0	2024-09-23 16:32:25	Map.hpp	27	28	Member Variables\nXr, Yr are robot(x,y)
25ee1121	f24	p0	2024-09-23 16:32:25	Map.hpp	30	30	using pointers since the type of cell and k value and xr yr change dynamically
25ee1121	f24	p0	2024-09-23 16:32:25	Map.hpp	32	32	Member Functions
287324bf	f24	p0	2024-09-22 19:05:56	main.cpp	8	8	Set it iniaitally null
287324bf	f24	p0	2024-09-22 19:05:56	main.cpp	13	13	Takes in user commands
287324bf	f24	p0	2024-09-22 19:05:56	main.cpp	33	33	G for goal O for obstacle
287324bf	f24	p0	2024-09-22 19:05:56	main.cpp	37	37	If unputed something else then it will output failure
287324bf	f24	p0	2024-09-22 19:05:56	main.cpp	50	50	Move robot and calculate total potential
287324bf	f24	p0	2024-09-22 19:05:56	main.cpp	62	62	Update to new K
287324bf	f24	p0	2024-09-22 19:05:56	main.cpp	77	77	Delete beofre exiting out
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	5	5	Constructor: Initializes the potential field grid with specified dimensions (n x m).
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	8	9	Initialize grid values to 0.0\nDynamically allocate memory for goals and obstacles, sized for the maximum possible number
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	16	16	Destructor: Releases dynamically allocated memory.
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	19	19	Free each row of the grid
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	31	31	Initializes the grid with all potential values set to 0.0.
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	34	34	Allocate row pointers
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	37	37	Allocate each row
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	45	45	Calculates the potential at (x, y) from a goal/obstacle at (xG, yG)
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	50	50	Return 0 if the distance is zero
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	53	53	Return the potential, with obstacles being opposite negative potential
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	64	64	Calculates the total potential at (x, y) from all goals and obstacles.
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	69	69	Add uo all the potential for goal
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	75	75	Add up all the potiental for obstacle this is negative
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	83	83	Recomputes potentials across the entire grid based on current goals and obstacles.
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	90	90	Update all the values
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	95	95	Resets the grid and clears all goals and obstacles.
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	99	99	Reset potential values
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	103	103	Reset goal and obstacle counters
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	108	108	Adds a goal ('G') or obstacle ('O') at (x, y).
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	117	117	Remove any existing goal at the location
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	131	131	Remove any existing obstacle at the location
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	168	168	Updates the constant K and recomputes potentials.
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	178	178	Recompute potentials with the new K
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	182	182	Moves the robot to (x, y) and outputs the current potential at that point.
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	187	187	Checks if the move is outside the grid dimensions
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	191	192	Calculate total potential at (x, y)\nHad a problem where it returned -0 istead of just 0 so added a function "fab" to take care of it
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.cpp	196	196	Print the potential twice because it is required
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	10	10	Stores the potential values for each grid
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	13	13	Stores the coordinates of goals and obestacle
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	16	16	Number of goals and obstacle currently present on the grid
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	21	22	Helper function to calculate the potential\nIf isObstacle is true, the K value is negative in the potential equation.
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	25	25	Computes the total potential by summing the potentials from all goals and obstacles
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	28	28	When called upon, it recomputes the potentials across the grid based on the current goals and obstacles
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	32	32	Constructor: Initializes the grid with dimensions rows:n x cols:m and sets the constant K to 1 initially
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	35	35	Destructor: Frees up the memory allocated for the grid and other dynamic arrays
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	38	38	Clears the grid by resetting all potential values to 0 and removes all goals and obstacles
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	41	42	Adds a goal G or obstacle O at the specified location on the grid and recomputes potentials\nIf a goal is added at a location with an obstacle the obstacle is removed and vice versa
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	45	45	Updates the constant K used in potential calculations and recomputes potentials
287324bf	f24	p0	2024-09-22 19:05:56	PFieldMap.h	48	48	Moves the robot and shows the potential at the current location
287324bf	f24	p0	2024-09-22 19:16:11	main.cpp	8	8	Set it iniaitally null
287324bf	f24	p0	2024-09-22 19:16:11	main.cpp	13	13	Takes in user commands
287324bf	f24	p0	2024-09-22 19:16:11	main.cpp	33	33	G for goal O for obstacle
287324bf	f24	p0	2024-09-22 19:16:11	main.cpp	37	37	If unputed something else then it will output failure
287324bf	f24	p0	2024-09-22 19:16:11	main.cpp	50	50	Move robot and calculate total potential
287324bf	f24	p0	2024-09-22 19:16:11	main.cpp	62	62	Update to new K
287324bf	f24	p0	2024-09-22 19:16:11	main.cpp	77	77	Delete beofre exiting out
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	5	5	Constructor: Initializes the potential field grid with specified dimensions (n x m).
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	8	9	Initialize grid values to 0.0\nDynamically allocate memory for goals and obstacles, sized for the maximum possible number
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	16	16	Destructor: Releases dynamically allocated memory.
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	19	19	Free each row of the grid
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	31	31	Initializes the grid with all potential values set to 0.0.
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	34	34	Allocate row pointers
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	37	37	Allocate each row
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	45	45	Calculates the potential at (x, y) from a goal/obstacle at (xG, yG)
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	50	50	Return 0 if the distance is zero
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	53	53	Return the potential, with obstacles being opposite negative potential
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	64	64	Calculates the total potential at (x, y) from all goals and obstacles.
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	69	69	Add uo all the potential for goal
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	75	75	Add up all the potiental for obstacle this is negative
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	83	83	Recomputes potentials across the entire grid based on current goals and obstacles.
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	90	90	Update all the values
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	95	95	Resets the grid and clears all goals and obstacles.
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	99	99	Reset potential values
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	103	103	Reset goal and obstacle counters
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	108	108	Adds a goal ('G') or obstacle ('O') at (x, y).
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	117	117	Remove any existing goal at the location
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	131	131	Remove any existing obstacle at the location
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	168	168	Updates the constant K and recomputes potentials.
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	178	178	Recompute potentials with the new K
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	182	182	Moves the robot to (x, y) and outputs the current potential at that point.
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	187	187	Checks if the move is outside the grid dimensions
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	191	192	Calculate total potential at (x, y)\nHad a problem where it returned -0 istead of just 0 so added a function "fab" to take care of it
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.cpp	196	196	Print the potential twice because it is required
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	10	10	Stores the potential values for each grid
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	13	13	Stores the coordinates of goals and obestacle
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	16	16	Number of goals and obstacle currently present on the grid
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	21	22	Helper function to calculate the potential\nIf isObstacle is true, the K value is negative in the potential equation.
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	25	25	Computes the total potential by summing the potentials from all goals and obstacles
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	28	28	When called upon, it recomputes the potentials across the grid based on the current goals and obstacles
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	32	32	Constructor: Initializes the grid with dimensions rows:n x cols:m and sets the constant K to 1 initially
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	35	35	Destructor: Frees up the memory allocated for the grid and other dynamic arrays
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	38	38	Clears the grid by resetting all potential values to 0 and removes all goals and obstacles
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	41	42	Adds a goal G or obstacle O at the specified location on the grid and recomputes potentials\nIf a goal is added at a location with an obstacle the obstacle is removed and vice versa
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	45	45	Updates the constant K used in potential calculations and recomputes potentials
287324bf	f24	p0	2024-09-22 19:16:11	PFieldMap.h	48	48	Moves the robot and shows the potential at the current location
287324bf	f24	p0	2024-09-22 19:31:37	main.cpp	8	8	Set it iniaitally null
287324bf	f24	p0	2024-09-22 19:31:37	main.cpp	13	13	Takes in user commands
287324bf	f24	p0	2024-09-22 19:31:37	main.cpp	33	33	G for goal O for obstacle
287324bf	f24	p0	2024-09-22 19:31:37	main.cpp	37	37	If unputed something else then it will output failure
287324bf	f24	p0	2024-09-22 19:31:37	main.cpp	50	50	Move robot and calculate total potential
287324bf	f24	p0	2024-09-22 19:31:37	main.cpp	62	62	Update to new K
287324bf	f24	p0	2024-09-22 19:31:37	main.cpp	77	77	Delete beofre exiting out
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	5	6	Constructor: Initializes the potential field grid with specified dimensions (n x m).\nInitialize PGrid to nullptr
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	8	9	Initialize grid values to 0.0\nDynamically allocate memory for goals and obstacles, sized for the maximum possible number
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	16	16	Destructor: Releases dynamically allocated memory.
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	19	19	Free each row of the grid if PGrid is not null
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	33	33	Initializes the grid with all potential values set to 0.0.
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	36	36	If PGrid is already allocated, free the previous memory
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	44	44	Allocate row pointers
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	47	47	Allocate each row
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	50	50	Initialize each element to 0.0
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	55	55	Calculates the potential at (x, y) from a goal/obstacle at (xG, yG)
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	60	60	Return 0 if the distance is zero
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	63	63	Return the potential, with obstacles being opposite negative potential
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	74	74	Calculates the total potential at (x, y) from all goals and obstacles.
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	79	79	Add up all the potential for goals
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	85	85	Add up all the potential for obstacles (negative potential)
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	90	90	Inverting potential as required
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	93	93	Recomputes potentials across the entire grid based on current goals and obstacles.
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	100	100	Update all the values
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	105	105	Resets the grid and clears all goals and obstacles.
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	112	112	Reset potential values
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	116	116	Reset goal and obstacle counters
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	121	121	Adds a goal ('G') or obstacle ('O') at (x, y).
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	130	130	Remove any existing goal at the location
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	144	144	Remove any existing obstacle at the location
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	181	181	Updates the constant K and recomputes potentials.
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	191	191	Recompute potentials with the new K
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	195	195	Moves the robot to (x, y) and outputs the current potential at that point.
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	200	200	Checks if the move is outside the grid dimensions
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	204	204	Calculate total potential at (x, y)
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	206	206	Handling precision issues with very small potentials
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.cpp	211	211	Print the potential twice because it is required
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	10	10	Stores the potential values for each grid
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	13	13	Stores the coordinates of goals and obestacle
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	16	16	Number of goals and obstacle currently present on the grid
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	21	22	Helper function to calculate the potential\nIf isObstacle is true, the K value is negative in the potential equation.
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	25	25	Computes the total potential by summing the potentials from all goals and obstacles
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	28	28	When called upon, it recomputes the potentials across the grid based on the current goals and obstacles
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	32	32	Constructor: Initializes the grid with dimensions rows:n x cols:m and sets the constant K to 1 initially
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	35	35	Destructor: Frees up the memory allocated for the grid and other dynamic arrays
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	38	38	Clears the grid by resetting all potential values to 0 and removes all goals and obstacles
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	41	42	Adds a goal G or obstacle O at the specified location on the grid and recomputes potentials\nIf a goal is added at a location with an obstacle the obstacle is removed and vice versa
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	45	45	Updates the constant K used in potential calculations and recomputes potentials
287324bf	f24	p0	2024-09-22 19:31:37	PFieldMap.h	48	48	Moves the robot and shows the potential at the current location
287324bf	f24	p0	2024-09-22 19:43:58	main.cpp	8	8	Set it iniaitally null
287324bf	f24	p0	2024-09-22 19:43:58	main.cpp	13	13	Takes in user commands
287324bf	f24	p0	2024-09-22 19:43:58	main.cpp	33	33	G for goal O for obstacle
287324bf	f24	p0	2024-09-22 19:43:58	main.cpp	37	37	If unputed something else then it will output failure
287324bf	f24	p0	2024-09-22 19:43:58	main.cpp	50	50	Move robot and calculate total potential
287324bf	f24	p0	2024-09-22 19:43:58	main.cpp	62	62	Update to new K
287324bf	f24	p0	2024-09-22 19:43:58	main.cpp	77	77	Delete beofre exiting out
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	5	5	Constructor: Initializes the potential field grid with specified dimensions (n x m).
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	8	9	Initialize grid values to 0.0\nDynamically allocate memory for goals and obstacles, sized for the maximum possible number
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	16	16	Destructor: Releases dynamically allocated memory.
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	19	19	Free each row of the grid
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	31	31	Initializes the grid with all potential values set to 0.0.
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	34	34	Allocate row pointers
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	37	37	Allocate each row
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	45	45	Calculates the potential at (x, y) from a goal/obstacle at (xG, yG)
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	50	50	Return 0 if the distance is zero
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	53	53	Return the potential, with obstacles being opposite negative potential
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	57	57	Calculates the total potential at (x, y) from all goals and obstacles.
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	62	62	Add up all the potential for goals
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	68	68	Add up all the potential for obstacles (this is negative)
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	76	76	Recomputes potentials across the entire grid based on current goals and obstacles.
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	83	83	Update all the values
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	88	88	Resets the grid and clears all goals and obstacles.
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	92	92	Reset potential values
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	96	96	Reset goal and obstacle counters
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	101	101	Adds a goal ('G') or obstacle ('O') at (x, y).
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	110	110	Remove any existing goal at the location
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	124	124	Remove any existing obstacle at the location
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	161	161	Updates the constant K and recomputes potentials.
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	171	171	Recompute potentials with the new K
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	175	175	Moves the robot to (x, y) and outputs the current potential at that point.
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	180	180	Checks if the move is outside the grid dimensions
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	184	185	Calculate total potential at (x, y)\nHandle potential -0 issue
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.cpp	189	189	Print the potential twice because it is required
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	10	10	Stores the potential values for each grid
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	13	13	Stores the coordinates of goals and obstacles
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	16	17	Number of goals currently present on the grid\nNumber of obstacles currently present on the grid
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	21	22	Helper function to calculate the potential\nIf isObstacle is true, the K value is negative in the potential equation.
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	25	25	Computes the total potential by summing the potentials from all goals and obstacles
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	28	28	When called upon, it recomputes the potentials across the grid based on the current goals and obstacles
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	32	32	Constructor: Initializes the grid with dimensions rows:n x cols:m and sets the constant K to 1 initially
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	35	35	Destructor: Frees up the memory allocated for the grid and other dynamic arrays
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	38	38	Clears the grid by resetting all potential values to 0 and removes all goals and obstacles
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	41	42	Adds a goal G or obstacle O at the specified location on the grid and recomputes potentials\nIf a goal is added at a location with an obstacle the obstacle is removed and vice versa
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	45	45	Updates the constant K used in potential calculations and recomputes potentials
287324bf	f24	p0	2024-09-22 19:43:58	PFieldMap.h	48	48	Moves the robot and shows the potential at the current location
287324bf	f24	p0	2024-09-23 14:46:44	main.cpp	8	8	Set it iniaitally null
287324bf	f24	p0	2024-09-23 14:46:44	main.cpp	13	13	Takes in user commands
287324bf	f24	p0	2024-09-23 14:46:44	main.cpp	33	33	G for goal O for obstacle
287324bf	f24	p0	2024-09-23 14:46:44	main.cpp	37	37	If unputed something else then it will output failure
287324bf	f24	p0	2024-09-23 14:46:44	main.cpp	50	50	Move robot and calculate total potential
287324bf	f24	p0	2024-09-23 14:46:44	main.cpp	62	62	Update to new K
287324bf	f24	p0	2024-09-23 14:46:44	main.cpp	77	77	Delete beofre exiting out
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	5	5	Constructor: Initializes the potential field grid with specified dimensions (n x m).
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	9	9	Dynamically allocate memory for goals and obstacles, sized for the maximum possible number
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	16	16	Destructor: Releases dynamically allocated memory.
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	19	19	Free each row of the grid
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	36	36	Initializes the grid with all potential values set to 0.0.
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	39	39	Allocate row pointers
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	42	42	Allocate each row
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	54	54	Return 0 if the distance is zero
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	56	56	Return the potential, with obstacles being opposite negative potential
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	70	70	Add uo all the potential for goal
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	75	75	Add up all the potiental for obstacle this is negative
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	89	89	Update all the values
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	98	98	Reset potential values
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	101	101	Reset goal and obstacle counters
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	114	114	Remove any existing goal at the location
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	128	128	Remove any existing obstacle at the location
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.cpp	183	183	Had a problem where it returned -0 istead of just 0 so added a function "fab" to take care of it
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.h	10	10	Stores the potential values for each grid
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.h	12	12	Stores the coordinates of goals and obestacle
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.h	14	14	Number of goals and obstacle currently present on the grid
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.h	17	18	Helper function to calculate the potential\nIf isObstacle is true, the K value is negative in the potential equation.
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.h	20	20	Computes the total potential by summing the potentials from all goals and obstacles
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.h	22	22	When called upon, it recomputes the potentials across the grid based on the current goals and obstacles
287324bf	f24	p0	2024-09-23 14:46:44	PFieldMap.h	30	30	If a goal is added at a location with an obstacle the obstacle is removed and vice versa
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	17	17	Get input
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	23	23	Delete old map if we have an old map
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	27	27	Create new map
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	30	30	Get input
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	38	38	Add a goal or object
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	45	45	Get input
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	51	51	Get the potential
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	58	58	Clear map
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	66	66	Get input
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	70	70	Update k
289ebd55	f24	p0	2024-09-16 17:50:27	main.cpp	84	84	Free memory
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	7	7	Constructors and destructors
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	13	13	Create the points
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	17	17	New point automatically initializes with default constructor, which sets it to (0, 0)
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	21	21	0 for no items
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	29	29	Deallocate memory of previous map
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	41	41	Getters and setters
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	64	64	Methods
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	69	69	Get potential due to this object/goal on the current point
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	73	73	potential is 0 if on the same spot (do nothing)
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	76	77	Otherwise, use the equation, but without multiplying k\nWe can multiply k at the end using distributive property
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	83	83	If it's a goal, potential is negative
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	88	88	Add potential due to this goal to the field (as normal)
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	92	92	Do nothing, since we already added this point as a goal earlier
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	94	94	We must add this increment twice, once to cancel the obstacle and once to make it a goal
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	100	100	Add potential due to this object to the field (as normal)
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	104	104	We must add this increment twice, once to cancle the goal and once to make it an obstacle
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	108	108	Do nothing, since we already added this point as an obstacle earlier
289ebd55	f24	p0	2024-09-16 17:50:27	map.cpp	114	114	Record this item in the items list
289ebd55	f24	p0	2024-09-16 17:50:27	map.h	13	13	0=no items, 1=goal, 2=object
289ebd55	f24	p0	2024-09-16 17:50:27	map.h	15	15	Constructors and destructor
289ebd55	f24	p0	2024-09-16 17:50:27	map.h	19	19	Getter and setters
289ebd55	f24	p0	2024-09-16 17:50:27	map.h	25	25	Methods
289ebd55	f24	p0	2024-09-16 17:50:27	point.cpp	3	3	Constructors and destructors
289ebd55	f24	p0	2024-09-16 17:50:27	point.cpp	18	18	Getters and setters
289ebd55	f24	p0	2024-09-16 17:50:27	point.h	10	10	Constructors and destructors
289ebd55	f24	p0	2024-09-16 17:50:27	point.h	15	15	Getters and setters
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	17	17	Get input
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	23	23	Delete old map if we have an old map
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	27	27	Create new map
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	30	30	Get input
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	38	38	Add a goal or object
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	45	45	Get input
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	51	51	Get the potential
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	58	58	Clear map
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	66	66	Get input
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	70	70	Update k
289ebd55	f24	p0	2024-09-16 18:19:59	main.cpp	84	84	Free memory
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	7	7	Constructors and destructors
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	13	13	Create the points
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	17	17	New point automatically initializes with default constructor, which sets it to (0, 0)
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	21	21	0 for no items
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	29	29	Deallocate memory of previous map
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	41	41	Getters and setters
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	64	64	Methods
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	69	69	Get potential due to this object/goal on the current point
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	73	73	potential is 0 if on the same spot (do nothing)
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	76	77	Otherwise, use the equation, but without multiplying k\nWe can multiply k at the end using distributive property
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	83	83	If it's a goal, potential is negative
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	88	88	Add potential due to this goal to the field (as normal)
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	92	92	Do nothing, since we already added this point as a goal earlier
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	94	94	We must add this increment twice, once to cancel the obstacle and once to make it a goal
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	100	100	Add potential due to this object to the field (as normal)
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	104	104	We must add this increment twice, once to cancle the goal and once to make it an obstacle
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	108	108	Do nothing, since we already added this point as an obstacle earlier
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	114	114	Record this item in the items list
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	127	127	Clear map and items
289ebd55	f24	p0	2024-09-16 18:19:59	map.cpp	141	141	Normally would throw error or return something special, but here we never use the result anyways
289ebd55	f24	p0	2024-09-16 18:19:59	map.h	13	13	0=no items, 1=goal, 2=object
289ebd55	f24	p0	2024-09-16 18:19:59	map.h	15	15	Constructors and destructor
289ebd55	f24	p0	2024-09-16 18:19:59	map.h	19	19	Getter and setters
289ebd55	f24	p0	2024-09-16 18:19:59	map.h	25	25	Methods
289ebd55	f24	p0	2024-09-16 18:19:59	point.cpp	3	3	Constructors and destructors
289ebd55	f24	p0	2024-09-16 18:19:59	point.cpp	18	18	Getters and setters
289ebd55	f24	p0	2024-09-16 18:19:59	point.h	10	10	Constructors and destructors
289ebd55	f24	p0	2024-09-16 18:19:59	point.h	15	15	Getters and setters
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	17	17	Get input
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	23	23	Delete old map if we have an old map
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	27	27	Create new map
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	30	30	Get input
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	38	38	Add a goal or object
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	45	45	Get input
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	51	51	Get the potential
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	58	58	Clear map
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	66	66	Get input
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	70	70	Update k
289ebd55	f24	p0	2024-09-20 18:56:00	main.cpp	84	84	Free memory
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	7	7	Constructors and destructors
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	13	13	Create the points
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	17	17	New point automatically initializes with default constructor, which sets it to (0, 0)
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	21	21	0 for no items
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	29	29	Deallocate memory of previous map
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	51	51	Methods
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	56	56	Get potential due to this object/goal on the current point
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	60	60	potential is 0 if on the same spot (do nothing)
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	63	64	Otherwise, use the equation, but without multiplying k\nWe can multiply k at the end using distributive property
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	70	70	If it's a goal, potential is negative
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	75	75	Add potential due to this goal to the field (as normal)
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	79	79	Do nothing, since we already added this point as a goal earlier
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	81	81	We must add this increment twice, once to cancel the obstacle and once to make it a goal
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	87	87	Add potential due to this object to the field (as normal)
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	91	91	We must add this increment twice, once to cancle the goal and once to make it an obstacle
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	95	95	Do nothing, since we already added this point as an obstacle earlier
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	101	101	Record this item in the items list
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	114	114	Clear map and items
289ebd55	f24	p0	2024-09-20 18:56:00	map.cpp	128	128	Normally would throw error or return something special, but here we never use the result anyways
289ebd55	f24	p0	2024-09-20 18:56:00	map.hpp	13	13	0=no items, 1=goal, 2=object
289ebd55	f24	p0	2024-09-20 18:56:00	map.hpp	15	15	Constructors and destructor
289ebd55	f24	p0	2024-09-20 18:56:00	map.hpp	19	19	Getter and setters
289ebd55	f24	p0	2024-09-20 18:56:00	map.hpp	22	22	Methods
289ebd55	f24	p0	2024-09-20 18:56:00	point.cpp	3	3	Constructors and destructors
289ebd55	f24	p0	2024-09-20 18:56:00	point.cpp	18	18	Getters and setters
289ebd55	f24	p0	2024-09-20 18:56:00	point.hpp	10	10	Constructors and destructors
289ebd55	f24	p0	2024-09-20 18:56:00	point.hpp	15	15	Getters and setters
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	48	52	#include "main.hpp"\n#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	54	54	int main() {
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	56	57	string input;\nint n, m;
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	59	59	Map map(n, m); // Create map object
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	61	64	while (cin >> input) {\nif (input == "CREATE") {\ncin >> n >> m;\nmap.create(n, m);
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	66	70	} else if (input == "POINT") {\nchar t;\nint x, y;\ncin >> t >> x >> y;\nmap.point(t, x, y);
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	72	75	} else if (input == "MOVE") {\nint x, y;\ncin >> x >> y;\nmap.move(x, y);
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	77	78	} else if (input == "CLEAR") {\nmap.clear();
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	80	83	} else if (input == "UPDATE") {\ndouble k_up;\ncin >> k_up;\nmap.k_update(k_up);
2937968f	f24	p0	2024-09-23 17:45:59	main.cpp	85	93	} else if (input == "EXIT") {\nbreak;\n}\n// else {\n//     cout << "Please try again." << endl;\n// }\n}\nreturn 0;\n}
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	8	11	Stores 'G' for goals, 'O' for obstacles, ' ' otherwise\nStores the x-component of the potential vector\nStores the y-component of the potential vector\nConstant K used in potential calculations
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	13	13	Recomputes the potentials for the entire grid
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	16	17	Constructor\nDestructor
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	19	23	Creates the grid\nAdds a goal or obstacle\nOutputs the potential vector at position (x, y)\nClears the grid\nUpdates the value of K
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	30	31	#ifndef main_HPP\n#define main_HPP
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	33	36	#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	38	39	class Map {\n// class private variables
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	41	44	private:\nint n = 0;\nint m= 0;\ndouble k = 1;
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	46	47	int numRows;\nint numColumns;
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	50	52	int **arr; // Map array\nchar **goalObstacleGrid;\ndouble **robotPotentialGrid;
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	54	57	// class public functions\npublic:\nMap (int n, int m); //constructor\n~Map (); //deconstructor
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	59	61	bool if_created = false;\nbool create (int n,  int m);\nbool point (char t, int x, int y);
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	63	64	bool add_goal (int x, int y);\nbool add_obstacle (int x, int y);
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	66	70	void move (int x, int y);\nvoid clear ();\nvoid k_update (double k_up);\nvoid exit ();\ndouble computePotential(double x, double y, double xG, double yG);
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	72	73	void recomputePotentials ();\n};
2937968f	f24	p0	2024-09-23 17:45:59	main.hpp	75	75	#endif
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	8	8	deconstructor
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	13	13	Create dynamic 2D arrays
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	20	20	Clear existing grids if any
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	25	25	Allocate grids
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	105	105	Reset potentials
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	113	113	Calculate potentials due to goals and obstacles
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	123	123	Potential is zero if at the same position
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	147	147	#include "main.hpp"
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	149	157	//constructor\nMap::Map(int n, int m){\nnumRows=n;\nnumColumns=m;\narr=nullptr; // Map array\ngoalObstacleGrid=nullptr;\nrobotPotentialGrid=nullptr;\nk= 1;\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	159	162	//deconstructor\nMap::~Map(){\nclear();\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	164	168	// Create dynamic 2D arrays\nbool Map::create(int n, int m) {\nif (arr != nullptr){\nclear();\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	170	173	arr = new int*[n];\nfor (int i = 0; i < n; ++i) {\narr[i] = new int[m];\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	175	176	goalObstacleGrid = new char*[n];\nrobotPotentialGrid = new double*[n];
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	178	181	for (int i = 0; i < n; ++i) {\ngoalObstacleGrid[i] = new char[m];\nrobotPotentialGrid[i] = new double[m];\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	183	188	for (int i = 0; i < n; ++i) {\nfor (int j = 0; j < m; ++j) {\ngoalObstacleGrid[i][j] = ' ';\nrobotPotentialGrid[i][j] = 0.0;\n}\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	190	191	numRows = n;\nnumColumns = m;
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	193	195	cout << "success" << endl;\nreturn true;\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	197	198	// Add point to grid\nbool Map::point(char t, int x, int y) {
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	200	208	if (0 <=x && x< numRows && 0 <= y && y < numColumns) {\ngoalObstacleGrid[x][y] = t; // Store either 'G' or 'O'\nrecomputePotentials(); // Recompute potentials after adding\ncout << "success" << endl;\nreturn true;\n} else {\ncout << "failure" << endl;\nreturn false;\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	211	223	// if (x < numRows && y < numColumns) {\n//     if (t == 'G') {\n//         goalObstacleGrid[x][y] = 'G';\n//     } else if (t == 'O') {\n//         goalObstacleGrid[x][y] = 'O';\n//     }\n//     cout << "success" << endl;\n//     return true;\n// } else {\n//     cout << "failure" << endl;\n//     return false;\n// }\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	225	234	// Outputs direction robot should move if its @x,y\nvoid Map::move(int x, int y) {\nif (x <0 || x >=numRows || y< 0 || y >= numColumns){\ncout<< "failure" <<endl;\nreturn;\n}\nelse{\ncout << robotPotentialGrid[x][y] << " " << robotPotentialGrid[x][y] <<endl;\n}\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	237	245	// Clear the grid\nvoid Map::clear() {\nif (goalObstacleGrid !=nullptr){\nfor (int i =0; i < numRows; ++i) {\ndelete[] goalObstacleGrid[i];\ndelete[] robotPotentialGrid[i];\n}\ndelete[] goalObstacleGrid;\ndelete[] robotPotentialGrid;
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	247	249	goalObstacleGrid = nullptr;\nrobotPotentialGrid = nullptr;\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	251	254	numRows = 0;\nnumColumns = 0;\ncout << "success" << endl;\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	256	266	// Update k and recompute potentials\nvoid Map::k_update(double k_up) {\nif (k_up > 0) {\nk = k_up;\nrecomputePotentials();\ncout << "success" << endl;\n}\nelse {\ncout << "failure" << endl;\n}\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	269	278	// class functions\n// compute potential\ndouble Map::computePotential(double x, double y, double xG, double yG) {\ndouble denominator = sqrt(pow(x - xG, 2) + pow(y - yG, 2));\nif (denominator ==0){\nreturn 0;\n}\ndouble Px = -k / pow(denominator, 2);\nreturn Px;\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	280	281	// recompute potential\nvoid Map::recomputePotentials() {
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	283	287	for (int i=0; i <numRows; ++i) {\nfor (int j =0; j < numColumns; ++j) {\nrobotPotentialGrid[i][j] = 0.0; // Reset potential\n}\n}
2937968f	f24	p0	2024-09-23 17:45:59	map.cpp	289	307	// Calculate potentials based on goals and obstacles\nfor (int i = 0; i < numRows; ++i) {\nfor (int j = 0; j < numColumns; ++j) {\nif (goalObstacleGrid[i][j] == 'G') { // If there's a goal\nfor (int x = 0; x < numRows; ++x) {\nfor (int y = 0; y < numColumns; ++y) {\nrobotPotentialGrid[x][y] -= computePotential(x, y, i, j); // Add potential\n}\n}\n} else if (goalObstacleGrid[i][j] == 'O') { // If there's an obstacle\nfor (int x = 0; x < numRows; ++x) {\nfor (int y = 0; y < numColumns; ++y) {\nrobotPotentialGrid[x][y] += computePotential(x, y, i, j); // Subtract potential\n}\n}\n}\n}\n}\n}
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	48	52	#include "main.hpp"\n#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	54	54	int main() {
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	56	57	string input;\nint n, m;
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	59	59	Map map(n, m); // Create map object
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	61	64	while (cin >> input) {\nif (input == "CREATE") {\ncin >> n >> m;\nmap.create(n, m);
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	66	70	} else if (input == "POINT") {\nchar t;\nint x, y;\ncin >> t >> x >> y;\nmap.point(t, x, y);
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	72	75	} else if (input == "MOVE") {\nint x, y;\ncin >> x >> y;\nmap.move(x, y);
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	77	78	} else if (input == "CLEAR") {\nmap.clear();
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	80	83	} else if (input == "UPDATE") {\ndouble k_up;\ncin >> k_up;\nmap.k_update(k_up);
2937968f	f24	p0	2024-09-23 17:47:52	main.cpp	85	93	} else if (input == "EXIT") {\nbreak;\n}\n// else {\n//     cout << "Please try again." << endl;\n// }\n}\nreturn 0;\n}
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	8	11	Stores 'G' for goals, 'O' for obstacles, ' ' otherwise\nStores the x-component of the potential vector\nStores the y-component of the potential vector\nConstant K used in potential calculations
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	13	13	Recomputes the potentials for the entire grid
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	16	17	Constructor\nDestructor
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	19	23	Creates the grid\nAdds a goal or obstacle\nOutputs the potential vector at position (x, y)\nClears the grid\nUpdates the value of K
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	30	31	#ifndef main_HPP\n#define main_HPP
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	33	36	#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	38	39	class Map {\n// class private variables
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	41	44	private:\nint n = 0;\nint m= 0;\ndouble k = 1;
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	46	47	int numRows;\nint numColumns;
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	50	52	int **arr; // Map array\nchar **goalObstacleGrid;\ndouble **robotPotentialGrid;
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	54	57	// class public functions\npublic:\nMap (int n, int m); //constructor\n~Map (); //deconstructor
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	59	61	bool if_created = false;\nbool create (int n,  int m);\nbool point (char t, int x, int y);
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	63	64	bool add_goal (int x, int y);\nbool add_obstacle (int x, int y);
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	66	70	void move (int x, int y);\nvoid clear ();\nvoid k_update (double k_up);\nvoid exit ();\ndouble computePotential(double x, double y, double xG, double yG);
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	72	73	void recomputePotentials ();\n};
2937968f	f24	p0	2024-09-23 17:47:52	main.hpp	75	75	#endif
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	8	8	deconstructor
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	13	13	Create dynamic 2D arrays
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	20	20	Clear existing grids if any
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	25	25	Allocate grids
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	105	105	Reset potentials
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	113	113	Calculate potentials due to goals and obstacles
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	123	123	Potential is zero if at the same position
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	147	147	#include "main.hpp"
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	149	157	//constructor\nMap::Map(int n, int m){\nnumRows=n;\nnumColumns=m;\narr=nullptr; // Map array\ngoalObstacleGrid=nullptr;\nrobotPotentialGrid=nullptr;\nk= 1;\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	159	162	//deconstructor\nMap::~Map(){\nclear();\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	164	168	// Create dynamic 2D arrays\nbool Map::create(int n, int m) {\nif (arr != nullptr){\nclear();\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	170	173	arr = new int*[n];\nfor (int i = 0; i < n; ++i) {\narr[i] = new int[m];\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	175	176	goalObstacleGrid = new char*[n];\nrobotPotentialGrid = new double*[n];
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	178	181	for (int i = 0; i < n; ++i) {\ngoalObstacleGrid[i] = new char[m];\nrobotPotentialGrid[i] = new double[m];\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	183	188	for (int i = 0; i < n; ++i) {\nfor (int j = 0; j < m; ++j) {\ngoalObstacleGrid[i][j] = ' ';\nrobotPotentialGrid[i][j] = 0.0;\n}\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	190	191	numRows = n;\nnumColumns = m;
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	193	195	cout << "success" << endl;\nreturn true;\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	197	198	// Add point to grid\nbool Map::point(char t, int x, int y) {
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	200	208	if (0 <=x && x< numRows && 0 <= y && y < numColumns) {\ngoalObstacleGrid[x][y] = t; // Store either 'G' or 'O'\nrecomputePotentials(); // Recompute potentials after adding\ncout << "success" << endl;\nreturn true;\n} else {\ncout << "failure" << endl;\nreturn false;\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	211	223	// if (x < numRows && y < numColumns) {\n//     if (t == 'G') {\n//         goalObstacleGrid[x][y] = 'G';\n//     } else if (t == 'O') {\n//         goalObstacleGrid[x][y] = 'O';\n//     }\n//     cout << "success" << endl;\n//     return true;\n// } else {\n//     cout << "failure" << endl;\n//     return false;\n// }\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	225	234	// Outputs direction robot should move if its @x,y\nvoid Map::move(int x, int y) {\nif (x <0 || x >=numRows || y< 0 || y >= numColumns){\ncout<< "failure" <<endl;\nreturn;\n}\nelse{\ncout << robotPotentialGrid[x][y] << " " << robotPotentialGrid[x][y] <<endl;\n}\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	237	245	// Clear the grid\nvoid Map::clear() {\nif (goalObstacleGrid !=nullptr){\nfor (int i =0; i < numRows; ++i) {\ndelete[] goalObstacleGrid[i];\ndelete[] robotPotentialGrid[i];\n}\ndelete[] goalObstacleGrid;\ndelete[] robotPotentialGrid;
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	247	249	goalObstacleGrid = nullptr;\nrobotPotentialGrid = nullptr;\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	251	254	numRows = 0;\nnumColumns = 0;\ncout << "success" << endl;\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	256	266	// Update k and recompute potentials\nvoid Map::k_update(double k_up) {\nif (k_up > 0) {\nk = k_up;\nrecomputePotentials();\ncout << "success" << endl;\n}\nelse {\ncout << "failure" << endl;\n}\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	269	278	// class functions\n// compute potential\ndouble Map::computePotential(double x, double y, double xG, double yG) {\ndouble denominator = sqrt(pow(x - xG, 2) + pow(y - yG, 2));\nif (denominator ==0){\nreturn 0;\n}\ndouble Px = -k / pow(denominator, 2);\nreturn Px;\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	280	281	// recompute potential\nvoid Map::recomputePotentials() {
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	283	287	for (int i=0; i <numRows; ++i) {\nfor (int j =0; j < numColumns; ++j) {\nrobotPotentialGrid[i][j] = 0.0; // Reset potential\n}\n}
2937968f	f24	p0	2024-09-23 17:47:52	map.cpp	289	307	// Calculate potentials based on goals and obstacles\nfor (int i = 0; i < numRows; ++i) {\nfor (int j = 0; j < numColumns; ++j) {\nif (goalObstacleGrid[i][j] == 'G') { // If there's a goal\nfor (int x = 0; x < numRows; ++x) {\nfor (int y = 0; y < numColumns; ++y) {\nrobotPotentialGrid[x][y] -= computePotential(x, y, i, j); // Add potential\n}\n}\n} else if (goalObstacleGrid[i][j] == 'O') { // If there's an obstacle\nfor (int x = 0; x < numRows; ++x) {\nfor (int y = 0; y < numColumns; ++y) {\nrobotPotentialGrid[x][y] += computePotential(x, y, i, j); // Subtract potential\n}\n}\n}\n}\n}\n}
2937968f	f24	p0	2024-09-23 20:01:42	main.cpp	15	15	Skip empty lines
2937968f	f24	p0	2024-09-23 20:01:42	main.hpp	9	9	Grid for goals ('G') and obstacles ('O')
2937968f	f24	p0	2024-09-23 20:01:42	main.hpp	11	13	X component of the potential vector\nY component of the potential vector\nScaling factor for potentials
2937968f	f24	p0	2024-09-23 20:01:42	main.hpp	15	15	Recomputes potentials for the grid
2937968f	f24	p0	2024-09-23 20:01:42	main.hpp	18	18	Constructor
2937968f	f24	p0	2024-09-23 20:01:42	main.hpp	21	21	Destructor
2937968f	f24	p0	2024-09-23 20:01:42	main.hpp	24	26	Creates the grid\nAdds a goal or an obstacle\nOutputs the potential vector at (x, y)
2937968f	f24	p0	2024-09-23 20:01:42	main.hpp	28	29	Clears the grid\nUpdates the scaling factor K
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	7	7	Constructor
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	12	12	Destructor
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	14	14	Avoid printing "success" during destruction
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	17	17	Create dynamic 2D arrays
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	24	24	Clear existing grid without output
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	30	30	Allocate 2D arrays
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	111	111	Reset potentials
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	119	119	Calculate potentials due to goals and obstacles
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	130	130	Potential is zero at the same point
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	138	138	'O'
2937968f	f24	p0	2024-09-23 20:01:42	map.cpp	142	142	Add potential component to both X and Y potentials
2937968f	f24	p0	2024-09-23 20:39:06	main.cpp	15	15	Skip empty lines
2937968f	f24	p0	2024-09-23 20:39:06	main.hpp	9	9	Grid for goals ('G') and obstacles ('O')
2937968f	f24	p0	2024-09-23 20:39:06	main.hpp	11	13	X component of the potential vector\nY component of the potential vector\nScaling factor for potentials
2937968f	f24	p0	2024-09-23 20:39:06	main.hpp	15	15	Recomputes potentials for the grid
2937968f	f24	p0	2024-09-23 20:39:06	main.hpp	18	18	Constructor
2937968f	f24	p0	2024-09-23 20:39:06	main.hpp	21	21	Destructor
2937968f	f24	p0	2024-09-23 20:39:06	main.hpp	24	26	Creates the grid\nAdds a goal or an obstacle\nOutputs the potential vector at (x, y)
2937968f	f24	p0	2024-09-23 20:39:06	main.hpp	28	29	Clears the grid\nUpdates the scaling factor K
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	7	7	Constructor
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	12	12	Destructor
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	14	14	Avoid printing "success" during destruction
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	17	17	Create dynamic 2D arrays
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	24	24	Clear existing grid without output
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	30	30	Allocate 2D arrays
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	111	111	Reset potentials
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	119	119	Calculate potentials due to goals and obstacles
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	130	130	Potential is zero at the same point
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	138	138	'O'
2937968f	f24	p0	2024-09-23 20:39:06	map.cpp	142	142	Add potential component to both X and Y potentials
2937968f	f24	p0	2024-09-23 20:42:11	main.cpp	14	14	Create map object
2937968f	f24	p0	2024-09-23 20:42:11	main.cpp	43	45	else {\ncout << "Please try again." << endl;\n}
2937968f	f24	p0	2024-09-23 20:42:11	main.hpp	17	17	Constructor
2937968f	f24	p0	2024-09-23 20:42:11	main.hpp	20	20	Destructor
2937968f	f24	p0	2024-09-23 20:42:11	main.hpp	23	25	Creates the grid\nAdds a goal or an obstacle\nOutputs the potential vector at (x, y)
2937968f	f24	p0	2024-09-23 20:42:11	main.hpp	27	28	Clears the grid\nUpdates the scaling factor K
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	7	7	Constructor
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	17	17	Destructor
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	19	19	my destructer is called when my clear fuction is not assigned a true value in its parameter aka it wont print out success
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	22	22	Create bnamic 2D arrays
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	28	28	my clear fucntion is assigned to false which clear the existing grid without output
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	34	34	Allocate 2D arrays
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	118	118	Reset potentials
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	126	126	Calculate potentials due to goals and obstacles
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	139	139	now over here the potential is zero at the same point
2937968f	f24	p0	2024-09-23 20:42:11	map.cpp	153	153	Add potential component to both X and Y potentials
2937968f	f24	p0	2024-09-23 22:43:43	main.cpp	14	14	Create map object
2937968f	f24	p0	2024-09-23 22:43:43	main.cpp	43	45	else {\ncout << "Please try again." << endl;\n}
2937968f	f24	p0	2024-09-23 22:43:43	main.hpp	17	17	Constructor
2937968f	f24	p0	2024-09-23 22:43:43	main.hpp	20	20	Destructor
2937968f	f24	p0	2024-09-23 22:43:43	main.hpp	23	25	Creates the grid\nAdds a goal or an obstacle\nOutputs the potential vector at (x, y)
2937968f	f24	p0	2024-09-23 22:43:43	main.hpp	27	28	Clears the grid\nUpdates the scaling factor K
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	7	7	Constructor
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	17	17	Destructor
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	19	19	my destructer is called when my clear fuction is not assigned a true value in its parameter aka it wont print out success
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	22	22	Create bnamic 2D arrays
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	28	28	my clear fucntion is assigned to false which clear the existing grid without output
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	34	34	Allocate 2D arrays
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	118	118	Reset potentials
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	126	126	Calculate potentials due to goals and obstacles
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	139	139	now over here the potential is zero at the same point
2937968f	f24	p0	2024-09-23 22:43:43	map.cpp	153	153	Add potential component to both X and Y potentials
2937968f	f24	p0	2024-09-23 22:47:30	main.cpp	9	9	parsing my inputs
2937968f	f24	p0	2024-09-23 22:47:30	main.cpp	13	13	Create map object
2937968f	f24	p0	2024-09-23 22:47:30	main.cpp	42	44	else {\ncout << "Please try again." << endl;\n}
2937968f	f24	p0	2024-09-23 22:47:30	main.hpp	8	8	2D array
2937968f	f24	p0	2024-09-23 22:47:30	main.hpp	11	11	I split this into 2 ind values to store x, y points to compute k at each point
2937968f	f24	p0	2024-09-23 22:47:30	main.hpp	20	20	Constructor
2937968f	f24	p0	2024-09-23 22:47:30	main.hpp	23	23	Destructor
2937968f	f24	p0	2024-09-23 22:47:30	main.hpp	26	28	n rows and m columbs grid created\npoint added a goal or an obstacle t==g or t==o\nOutputs the potential
2937968f	f24	p0	2024-09-23 22:47:30	main.hpp	30	31	Clearing the grid with helper of true false variable\nkeep updating k value based on computations
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	8	8	Constructor
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	13	13	dealocating or nulling the memodry for my grid
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	22	22	Destructor
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	24	24	my destructer is called when my clear fuction is not assigned a true value in its parameter aka it wont print out success
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	27	27	Create bnamic 2D arrays
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	30	30	my clear fucntion is assigned to false which clear the existing grid without output
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	32	33	n ----> ROWS\nm ----> COLUMNS
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	38	38	ROWS Allocate the memory for 2D arrays
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	44	44	COLUMS Allocate the memory for 2D arrays
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	52	52	put empty spaces in each cell of the array
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	54	54	k = Y and X
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	61	61	out of  bounds
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	68	68	making sure robot is in the bounds
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	72	72	calling my function computePotentials for each cell in the grid
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	75	75	not the correct type inputed G or O
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	77	77	if out of bounds
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	82	82	k's at specifc  x,y coordinate
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	84	84	if im out of bounds
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	88	88	checking if grid is empty or not
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	91	91	deletes grid memory when increamented by i
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	98	98	deleting pointers
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	104	104	resetng my pointers to null so we can start fresh
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	109	109	grid rows and coums reset
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	125	125	k would be invalid then it prints fail
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	129	129	reseting the potentials for each cell for x and y
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	137	137	Calculate potentials due to goals and obstacles by iterating through x y point for each cell
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	141	141	my comparison for the arry that check for my xG or xO
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	146	146	k computations for distance
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	152	152	now over here the distance is zero skip aka if at the same point = skip
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	158	163	the first way i tried to do it, lots of number errors so tried a diff way\ndouble denominator = sqrt(pow(x - xG, 2) + pow(y - yG, 2));\nif (denominator ==0){\nreturn 0; }\ndouble Px = -k / pow(denominator, 2);\nreturn Px;
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	166	166	Goal = -'ve potential
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	169	169	Object = +'ve potential
2937968f	f24	p0	2024-09-23 22:47:30	map.cpp	172	172	Adding the potential component the fuction calculated to the to both X and Y potentials
2937968f	f24	p0	2024-09-23 22:48:15	main.cpp	9	9	parsing my inputs
2937968f	f24	p0	2024-09-23 22:48:15	main.cpp	13	13	Create map object
2937968f	f24	p0	2024-09-23 22:48:15	main.cpp	42	44	else {\ncout << "Please try again." << endl;\n}
2937968f	f24	p0	2024-09-23 22:48:15	main.hpp	8	8	2D array
2937968f	f24	p0	2024-09-23 22:48:15	main.hpp	11	11	I split this into 2 ind values to store x, y points to compute k at each point
2937968f	f24	p0	2024-09-23 22:48:15	main.hpp	20	20	Constructor
2937968f	f24	p0	2024-09-23 22:48:15	main.hpp	23	23	Destructor
2937968f	f24	p0	2024-09-23 22:48:15	main.hpp	26	28	n rows and m columbs grid created\npoint added a goal or an obstacle t==g or t==o\nOutputs the potential
2937968f	f24	p0	2024-09-23 22:48:15	main.hpp	30	31	Clearing the grid with helper of true false variable\nkeep updating k value based on computations
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	8	8	Constructor
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	13	13	dealocating or nulling the memodry for my grid
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	22	22	Destructor
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	24	24	my destructer is called when my clear fuction is not assigned a true value in its parameter aka it wont print out success
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	27	27	Create bnamic 2D arrays
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	30	30	my clear fucntion is assigned to false which clear the existing grid without output
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	32	33	n ----> ROWS\nm ----> COLUMNS
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	38	38	ROWS Allocate the memory for 2D arrays
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	44	44	COLUMS Allocate the memory for 2D arrays
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	52	52	put empty spaces in each cell of the array
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	54	54	k = Y and X
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	61	61	out of  bounds
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	68	68	making sure robot is in the bounds
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	72	72	calling my function computePotentials for each cell in the grid
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	75	75	not the correct type inputed G or O
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	77	77	if out of bounds
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	82	82	k's at specifc  x,y coordinate
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	84	84	if im out of bounds
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	88	88	checking if grid is empty or not
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	91	91	deletes grid memory when increamented by i
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	98	98	deleting pointers
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	104	104	resetng my pointers to null so we can start fresh
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	109	109	grid rows and coums reset
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	125	125	k would be invalid then it prints fail
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	129	129	reseting the potentials for each cell for x and y
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	137	137	Calculate potentials due to goals and obstacles by iterating through x y point for each cell
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	141	141	my comparison for the arry that check for my xG or xO
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	146	146	k computations for distance
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	152	152	now over here the distance is zero skip aka if at the same point = skip
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	158	163	the first way i tried to do it, lots of number errors so tried a diff way\ndouble denominator = sqrt(pow(x - xG, 2) + pow(y - yG, 2));\nif (denominator ==0){\nreturn 0; }\ndouble Px = -k / pow(denominator, 2);\nreturn Px;
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	166	166	Goal = -'ve potential
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	169	169	Object = +'ve potential
2937968f	f24	p0	2024-09-23 22:48:15	map.cpp	172	172	Adding the potential component the fuction calculated to the to both X and Y potentials
2937968f	f24	p0	2024-09-23 22:50:57	main.cpp	9	9	parsing my inputs
2937968f	f24	p0	2024-09-23 22:50:57	main.cpp	13	13	Create map object
2937968f	f24	p0	2024-09-23 22:50:57	main.cpp	42	44	else {\ncout << "Please try again." << endl;\n}
2937968f	f24	p0	2024-09-23 22:50:57	main.hpp	8	8	2D array
2937968f	f24	p0	2024-09-23 22:50:57	main.hpp	11	11	I split this into 2 ind values to store x, y points to compute k at each point
2937968f	f24	p0	2024-09-23 22:50:57	main.hpp	20	20	Constructor
2937968f	f24	p0	2024-09-23 22:50:57	main.hpp	23	23	Destructor
2937968f	f24	p0	2024-09-23 22:50:57	main.hpp	26	28	n rows and m columbs grid created\npoint added a goal or an obstacle t==g or t==o\nOutputs the potential
2937968f	f24	p0	2024-09-23 22:50:57	main.hpp	30	31	Clearing the grid with helper of true false variable\nkeep updating k value based on computations
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	8	8	Constructor
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	13	13	dealocating or nulling the memodry for my grid
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	22	22	Destructor
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	24	24	my destructer is called when my clear fuction is not assigned a true value in its parameter aka it wont print out success
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	27	27	Create bnamic 2D arrays
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	30	30	my clear fucntion is assigned to false which clear the existing grid without output
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	32	33	n ----> ROWS\nm ----> COLUMNS
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	38	38	ROWS Allocate the memory for 2D arrays
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	44	44	COLUMS Allocate the memory for 2D arrays
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	52	52	put empty spaces in each cell of the array
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	54	54	k = Y and X
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	61	61	out of  bounds
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	68	68	making sure robot is in the bounds
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	72	72	calling my function computePotentials for each cell in the grid
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	75	75	not the correct type inputed G or O
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	77	77	if out of bounds
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	82	82	k's at specifc  x,y coordinate
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	84	84	if im out of bounds
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	88	88	checking if grid is empty or not
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	91	91	deletes grid memory when increamented by i
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	98	98	deleting pointers
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	104	104	resetng my pointers to null so we can start fresh
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	109	109	grid rows and coums reset
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	125	125	k would be invalid then it prints fail
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	129	129	reseting the potentials for each cell for x and y
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	137	137	Calculate potentials due to goals and obstacles by iterating through x y point for each cell
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	141	141	my comparison for the arry that check for my xG or xO
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	146	146	k computations for distance
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	152	152	now over here the distance is zero skip aka if at the same point = skip
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	158	163	the first way i tried to do it, lots of number errors so tried a diff way\ndouble denominator = sqrt(pow(x - xG, 2) + pow(y - yG, 2));\nif (denominator ==0){\nreturn 0; }\ndouble Px = -k / pow(denominator, 2);\nreturn Px;
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	166	166	Goal = -'ve potential
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	169	169	Object = +'ve potential
2937968f	f24	p0	2024-09-23 22:50:57	map.cpp	172	172	Adding the potential component the fuction calculated to the to both X and Y potentials
2937968f	f24	p0	2024-10-07 13:30:32	main.cpp	9	9	parsing my inputs
2937968f	f24	p0	2024-10-07 13:30:32	main.cpp	13	13	Create map object
2937968f	f24	p0	2024-10-07 13:30:32	main.cpp	42	44	else {\ncout << "Please try again." << endl;\n}
2937968f	f24	p0	2024-10-07 13:30:32	main.hpp	8	8	2D array
2937968f	f24	p0	2024-10-07 13:30:32	main.hpp	11	11	I split this into 2 ind values to store x, y points to compute k at each point
2937968f	f24	p0	2024-10-07 13:30:32	main.hpp	20	20	Constructor
2937968f	f24	p0	2024-10-07 13:30:32	main.hpp	23	23	Destructor
2937968f	f24	p0	2024-10-07 13:30:32	main.hpp	26	28	n rows and m columbs grid created\npoint added a goal or an obstacle t==g or t==o\nOutputs the potential
2937968f	f24	p0	2024-10-07 13:30:32	main.hpp	30	31	Clearing the grid with helper of true false variable\nkeep updating k value based on computations
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	8	8	Constructor
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	13	13	dealocating or nulling the memodry for my grid
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	22	22	Destructor
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	24	24	my destructer is called when my clear fuction is not assigned a true value in its parameter aka it wont print out success
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	27	27	Create bnamic 2D arrays
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	30	30	my clear fucntion is assigned to false which clear the existing grid without output
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	32	33	n ----> ROWS\nm ----> COLUMNS
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	38	38	ROWS Allocate the memory for 2D arrays
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	44	44	COLUMS Allocate the memory for 2D arrays
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	52	52	put empty spaces in each cell of the array
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	54	54	k = Y and X
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	61	61	out of  bounds
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	68	68	making sure robot is in the bounds
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	72	72	calling my function computePotentials for each cell in the grid
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	75	75	not the correct type inputed G or O
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	77	77	if out of bounds
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	82	82	k's at specifc  x,y coordinate
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	84	84	if im out of bounds
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	88	88	checking if grid is empty or not
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	91	91	deletes grid memory when increamented by i
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	98	98	deleting pointers
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	104	104	resetng my pointers to null so we can start fresh
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	109	109	grid rows and coums reset
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	125	125	k would be invalid then it prints fail
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	129	129	reseting the potentials for each cell for x and y
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	137	137	Calculate potentials due to goals and obstacles by iterating through x y point for each cell
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	141	141	my comparison for the arry that check for my xG or xO
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	146	146	k computations for distance
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	152	152	now over here the distance is zero skip aka if at the same point = skip
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	158	163	the first way i tried to do it, lots of number errors so tried a diff way\ndouble denominator = sqrt(pow(x - xG, 2) + pow(y - yG, 2));\nif (denominator ==0){\nreturn 0; }\ndouble Px = -k / pow(denominator, 2);\nreturn Px;
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	166	166	Goal = -'ve potential
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	169	169	Object = +'ve potential
2937968f	f24	p0	2024-10-07 13:30:32	map.cpp	172	172	Adding the potential component the fuction calculated to the to both X and Y potentials
2ad0522b	f24	p0	2024-09-22 21:23:42	main.cpp	8	8	initially no map so start with (0,0)
2ad0522b	f24	p0	2024-09-22 21:23:42	main.cpp	10	10	intilizing the command that will choose what action to do when the user inputs
2ad0522b	f24	p0	2024-09-22 21:23:42	main.cpp	18	18	create a new field with the specified dimensions
2ad0522b	f24	p0	2024-09-22 21:23:42	pair.h	4	4	creating a pair class to avoid the use of <utility>
2ad0522b	f24	p0	2024-09-22 21:23:42	pair.h	11	11	build the default constructor
2ad0522b	f24	p0	2024-09-22 21:23:42	pair.h	13	13	parameterized constructor
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.cpp	5	5	build the constructor for potentialfield
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.cpp	15	15	build the destructor to free memory and avoid leaks
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.cpp	25	25	creating a function to calculate and update potentials for goals and obstacles
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.cpp	40	40	implementing the getPotentialAt function using the custom Pair class
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.cpp	46	46	Return zero potential for out-of-bounds
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.cpp	51	51	function to clear the map and reset all potentials to ⟨0,0⟩
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.cpp	61	61	ppdate the value of K and recompute all potentials then update
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.cpp	72	72	create the getters to get the number of cols and number of rows
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.h	4	4	explain pair class in design document
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.h	7	7	the private objects
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.h	14	14	the public objects
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.h	17	17	destructor
2ad0522b	f24	p0	2024-09-22 21:23:42	potentialfield.h	25	25	create some getters that return the number of rows or return the number of cols
2ad0522b	f24	p0	2024-09-22 21:23:42	robot.cpp	3	3	build a constructor to initialize the robots position
2ad0522b	f24	p0	2024-09-22 21:23:42	robot.cpp	6	6	this will sets the robots current position x and y
2ad0522b	f24	p0	2024-09-22 21:23:42	robot.cpp	12	12	to return the robots X position
2ad0522b	f24	p0	2024-09-22 21:23:42	robot.cpp	17	17	to return the robots Y position
2ad0522b	f24	p0	2024-09-22 21:23:42	robot.h	6	6	This will be the current position of the robot
2ad0522b	f24	p0	2024-09-22 21:23:42	robot.h	10	10	build a constructor to initialize robot's position
2ad0522b	f24	p0	2024-09-22 21:23:42	robot.h	13	13	set the robots current position
2ad0522b	f24	p0	2024-09-22 21:23:42	robot.h	16	16	get x to returns the robots current X position
2ad0522b	f24	p0	2024-09-22 21:23:42	robot.h	19	19	get y to returns the robot's current Y position
2ad0522b	f24	p0	2024-09-23 16:36:19	main.cpp	2	2	including the custom pair class I made so <utility> did not have to be used
2ad0522b	f24	p0	2024-09-23 16:36:19	main.cpp	7	7	create a instance
2ad0522b	f24	p0	2024-09-23 16:36:19	main.cpp	10	10	loop that will continuously read the commands
2ad0522b	f24	p0	2024-09-23 16:36:19	main.cpp	12	12	declares two ints for the grid and calls the create function on the instance which will result in success or failure
2ad0522b	f24	p0	2024-09-23 16:36:19	main.cpp	17	17	char for the 'G' or 'O' then the integers for the coordinates then calls the addPoint function will result in success or failure
2ad0522b	f24	p0	2024-09-23 16:36:19	main.cpp	24	26	attempts to retrieve the potential values and if an out-of-bounds exception is thrown, catches the exception and outputs 'failure'\ncalls the move method to get the potential values at the specified coordinates\noutputs the potential values using potential.first and potential.second
2ad0522b	f24	p0	2024-09-23 16:36:19	main.cpp	36	36	reset grid
2ad0522b	f24	p0	2024-09-23 16:36:19	main.cpp	40	40	updates the new k value results in sucess or failure
2ad0522b	f24	p0	2024-09-23 16:36:19	pair.h	4	4	the goal of this class is to replicate the std::pair class in <utility> as it is forbidden to use STL
2ad0522b	f24	p0	2024-09-23 16:36:19	pair.h	10	11	constructor with default values\ninitializes 'first' and 'second' with the given values and defaults to 0.0 if no values are provided
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	5	5	constructor
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	7	7	destructor so no memory leaks!
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	11	11	clear existing grid if necessary
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	19	19	allocate max possible goals
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	21	21	allocate max possible obstacles
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	27	27	check bounds for x and y
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	29	29	out of bounds so false
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	32	32	goal
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	36	36	obstacle
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	41	41	update the grid based on the new points
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	47	47	deallocates all resources to prevent memory leaks with using delete operator and nullptr
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	70	71	checks if the coordinates are valid; if not it throws an out_of_range exception\nreturns a pair containing the potential values from the grid at '(x, y) and (y, x)'
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	75	75	return Pair instead of std::pair as we made our own pair class
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	81	81	checks if new value is positive if not it returns false
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	83	83	set k to the new value and then adjust the potentials then true if the update is successful
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	90	91	resets and recalculates potential values based on the goals and obstacles\ninitializes all potential values in the grid to zero '0.0'
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	97	98	loops through all grid positions and computes the distance to each goal and updates the potential based on the distance\napplying an attractive force towards the goal
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	107	107	attractive potential
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	113	114	for each obstacle, it calculates its contribution to the potential field\nupdates the potential to apply a repulsive force away from obstacles
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.cpp	123	123	repulsive potential
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.h	7	7	2D array
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.h	11	11	the arrray to store goal positions
2ad0522b	f24	p0	2024-09-23 16:36:19	potentialfield.h	14	14	the array to store obstacle positions
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	23	23	delete[] poiArray;
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	30	30	GridPoi *newPoiArray = new GridPoi[poiCount + 1];
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	38	38	delete[] poiArray;
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	57	57	delete[] poiArray;
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	92	92	delete[] poiArray;
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	110	112	poiArray[poiCount].t = t;\npoiArray[poiCount].x = x;\npoiArray[poiCount].y = y;
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	124	127	if (i == poiArray[k].x && j == poiArray[k].y)\n{\ncontinue;\n}
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	133	134	double pot_x = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));\ndouble pot_y = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	146	147	potentialField[i][j].x = sum_x;\npotentialField[i][j].y = sum_y;
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	162	162	cout << potentialField[x][y].x << " " << potentialField[x][y].y << endl;
2b478410	f24	p0	2024-09-09 19:01:12	grid.cpp	182	182	delete[] poiArray;
2b478410	f24	p0	2024-09-09 19:01:12	grid.hpp	10	14	struct GridCoordinate\n{\ndouble x;\ndouble y;\n};
2b478410	f24	p0	2024-09-09 19:01:12	grid.hpp	16	21	struct GridPoi\n{\nchar t;\ndouble x;\ndouble y;\n};
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	23	23	delete[] poiArray;
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	30	30	GridPoi *newPoiArray = new GridPoi[poiCount + 1];
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	38	38	delete[] poiArray;
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	57	57	delete[] poiArray;
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	92	92	delete[] poiArray;
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	110	112	poiArray[poiCount].t = t;\npoiArray[poiCount].x = x;\npoiArray[poiCount].y = y;
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	124	127	if (i == poiArray[k].x && j == poiArray[k].y)\n{\ncontinue;\n}
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	133	134	double pot_x = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));\ndouble pot_y = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	146	147	potentialField[i][j].x = sum_x;\npotentialField[i][j].y = sum_y;
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	162	162	cout << potentialField[x][y].x << " " << potentialField[x][y].y << endl;
2b478410	f24	p0	2024-09-13 12:42:37	grid.cpp	182	182	delete[] poiArray;
2b478410	f24	p0	2024-09-13 12:42:37	grid.hpp	10	14	struct GridCoordinate\n{\ndouble x;\ndouble y;\n};
2b478410	f24	p0	2024-09-13 12:42:37	grid.hpp	16	21	struct GridPoi\n{\nchar t;\ndouble x;\ndouble y;\n};
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	23	23	delete[] poiArray;
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	39	39	GridPoi *newPoiArray = new GridPoi[poiCount + 1];
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	48	48	delete[] poiArray;
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	69	69	delete[] poiArray;
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	102	108	if (poiArray)\n{\n// delete[] poiArray;\nfree(poiArray);\n}\npoiArray = nullptr;\npoiCount = 0;
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	122	126	poiArray[poiCount].t = t;\npoiArray[poiCount].x = x;\npoiArray[poiCount].y = y;\npoiArray[poiCount].setPoi(t, x, y);\npoiCount++;
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	136	139	if (i == poiArray[k].x && j == poiArray[k].y)\n{\ncontinue;\n}
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	145	146	double pot_x = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));\ndouble pot_y = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	158	159	potentialField[i][j].x = sum_x;\npotentialField[i][j].y = sum_y;
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	174	174	cout << potentialField[x][y].x << " " << potentialField[x][y].y << endl;
2b478410	f24	p0	2024-09-13 14:47:49	grid.cpp	194	194	delete[] poiArray;
2b478410	f24	p0	2024-09-13 14:47:49	grid.hpp	10	14	struct GridCoordinate\n{\ndouble x;\ndouble y;\n};
2b478410	f24	p0	2024-09-13 14:47:49	grid.hpp	16	21	struct GridPoi\n{\nchar t;\ndouble x;\ndouble y;\n};
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	23	23	delete[] poiArray;
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	39	39	GridPoi *newPoiArray = new GridPoi[poiCount + 1];
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	48	48	delete[] poiArray;
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	70	70	delete[] poiArray;
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	105	111	if (poiArray)\n{\n// delete[] poiArray;\nfree(poiArray);\n}\npoiArray = nullptr;\npoiCount = 0;
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	125	129	poiArray[poiCount].t = t;\npoiArray[poiCount].x = x;\npoiArray[poiCount].y = y;\npoiArray[poiCount].setPoi(t, x, y);\npoiCount++;
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	139	142	if (i == poiArray[k].x && j == poiArray[k].y)\n{\ncontinue;\n}
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	148	149	double pot_x = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));\ndouble pot_y = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	161	162	potentialField[i][j].x = sum_x;\npotentialField[i][j].y = sum_y;
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	177	177	cout << potentialField[x][y].x << " " << potentialField[x][y].y << endl;
2b478410	f24	p0	2024-09-13 15:41:10	grid.cpp	197	197	delete[] poiArray;
2b478410	f24	p0	2024-09-13 15:41:10	grid.hpp	10	14	struct GridCoordinate\n{\ndouble x;\ndouble y;\n};
2b478410	f24	p0	2024-09-13 15:41:10	grid.hpp	16	21	struct GridPoi\n{\nchar t;\ndouble x;\ndouble y;\n};
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	23	23	delete[] poiArray;
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	39	39	GridPoi *newPoiArray = new GridPoi[poiCount + 1];
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	48	48	delete[] poiArray;
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	70	70	delete[] poiArray;
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	105	111	if (poiArray)\n{\n// delete[] poiArray;\nfree(poiArray);\n}\npoiArray = nullptr;\npoiCount = 0;
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	125	129	poiArray[poiCount].t = t;\npoiArray[poiCount].x = x;\npoiArray[poiCount].y = y;\npoiArray[poiCount].setPoi(t, x, y);\npoiCount++;
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	139	142	if (i == poiArray[k].x && j == poiArray[k].y)\n{\ncontinue;\n}
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	148	149	double pot_x = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));\ndouble pot_y = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	161	162	potentialField[i][j].x = sum_x;\npotentialField[i][j].y = sum_y;
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	177	177	cout << potentialField[x][y].x << " " << potentialField[x][y].y << endl;
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	197	197	delete[] poiArray;
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	214	214	recompute
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	223	226	if (i == poiArray[k].x && j == poiArray[k].y)\n{\ncontinue;\n}
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	232	233	double pot_x = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));\ndouble pot_y = -K / sqrt(pow((i - poiArray[k].x), 2) + pow((j - poiArray[k].y), 2));
2b478410	f24	p0	2024-09-14 01:37:15	grid.cpp	245	246	potentialField[i][j].x = sum_x;\npotentialField[i][j].y = sum_y;
2b478410	f24	p0	2024-09-14 01:37:15	grid.hpp	10	14	struct GridCoordinate\n{\ndouble x;\ndouble y;\n};
2b478410	f24	p0	2024-09-14 01:37:15	grid.hpp	16	21	struct GridPoi\n{\nchar t;\ndouble x;\ndouble y;\n};
2bfb6893	f24	p0	2024-09-20 00:21:55	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-20 00:21:55	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-20 00:21:55	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-20 00:21:55	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-20 00:21:55	PotentialField.cpp	51	51	check if greater than 0
2bfb6893	f24	p0	2024-09-20 00:21:55	PotentialField.cpp	60	60	call the calculation function to recalculate the potential at that point so should be good
2bfb6893	f24	p0	2024-09-20 00:21:55	PotentialField.cpp	65	65	call the calculator again and recalculate potential accross everything
2bfb6893	f24	p0	2024-09-20 00:21:55	PotentialField.cpp	92	92	Reset all grid values
2bfb6893	f24	p0	2024-09-20 00:21:55	PotentialField.cpp	99	99	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-20 00:21:55	PotentialField.cpp	105	105	use a while loop in main if the command is Exit just break it
2bfb6893	f24	p0	2024-09-20 00:21:55	PotentialField.cpp	123	123	Reset all potentials once before recalculating
2bfb6893	f24	p0	2024-09-20 00:21:55	PotentialField.cpp	146	146	Goal
2bfb6893	f24	p0	2024-09-20 00:21:55	PotentialField.cpp	152	152	Obstacle
2bfb6893	f24	p0	2024-09-20 02:18:08	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-20 02:18:08	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-20 02:18:08	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-20 02:18:08	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-20 02:18:08	PotentialField.cpp	51	51	check if greater than 0
2bfb6893	f24	p0	2024-09-20 02:18:08	PotentialField.cpp	60	60	call the calculation function to recalculate the potential at that point so should be good
2bfb6893	f24	p0	2024-09-20 02:18:08	PotentialField.cpp	65	65	call the calculator again and recalculate potential accross everything
2bfb6893	f24	p0	2024-09-20 02:18:08	PotentialField.cpp	92	92	Reset all grid values
2bfb6893	f24	p0	2024-09-20 02:18:08	PotentialField.cpp	99	99	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-20 02:18:08	PotentialField.cpp	105	105	use a while loop in main if the command is Exit just break it
2bfb6893	f24	p0	2024-09-20 02:18:08	PotentialField.cpp	123	123	Reset all potentials once before recalculating
2bfb6893	f24	p0	2024-09-20 02:18:08	PotentialField.cpp	146	146	Goal
2bfb6893	f24	p0	2024-09-20 02:18:08	PotentialField.cpp	152	152	Obstacle
2bfb6893	f24	p0	2024-09-20 02:34:32	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-20 02:34:32	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-20 02:34:32	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-20 02:34:32	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-20 02:34:32	PotentialField.cpp	51	51	check if greater than 0
2bfb6893	f24	p0	2024-09-20 02:34:32	PotentialField.cpp	60	60	call the calculation function to recalculate the potential at that point so should be good
2bfb6893	f24	p0	2024-09-20 02:34:32	PotentialField.cpp	65	65	call the calculator again and recalculate potential accross everything
2bfb6893	f24	p0	2024-09-20 02:34:32	PotentialField.cpp	92	92	Reset all grid values
2bfb6893	f24	p0	2024-09-20 02:34:32	PotentialField.cpp	99	99	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-20 02:34:32	PotentialField.cpp	105	105	use a while loop in main if the command is Exit just break it
2bfb6893	f24	p0	2024-09-20 02:34:32	PotentialField.cpp	123	123	Reset all potentials once before recalculating
2bfb6893	f24	p0	2024-09-20 02:34:32	PotentialField.cpp	146	146	Goal
2bfb6893	f24	p0	2024-09-20 02:34:32	PotentialField.cpp	152	152	Obstacle
2bfb6893	f24	p0	2024-09-20 03:08:27	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-20 03:08:27	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-20 03:08:27	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-20 03:08:27	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-20 03:08:27	PotentialField.cpp	58	58	check if greater than 0
2bfb6893	f24	p0	2024-09-20 03:08:27	PotentialField.cpp	67	67	call the calculation function to recalculate the potential at that point so should be good
2bfb6893	f24	p0	2024-09-20 03:08:27	PotentialField.cpp	72	72	call the calculator again and recalculate potential accross everything
2bfb6893	f24	p0	2024-09-20 03:08:27	PotentialField.cpp	99	99	Reset all grid values
2bfb6893	f24	p0	2024-09-20 03:08:27	PotentialField.cpp	106	106	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-20 03:08:27	PotentialField.cpp	112	112	use a while loop in main if the command is Exit just break it
2bfb6893	f24	p0	2024-09-20 03:08:27	PotentialField.cpp	130	130	Reset all potentials once before recalculating
2bfb6893	f24	p0	2024-09-20 03:08:27	PotentialField.cpp	153	153	Goal
2bfb6893	f24	p0	2024-09-20 03:08:27	PotentialField.cpp	159	159	Obstacle
2bfb6893	f24	p0	2024-09-20 15:06:27	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-20 15:06:27	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-20 15:06:27	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-20 15:06:27	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-20 15:06:27	PotentialField.cpp	58	58	check if greater than 0
2bfb6893	f24	p0	2024-09-20 15:06:27	PotentialField.cpp	67	67	call the calculation function to recalculate the potential at that point so should be good
2bfb6893	f24	p0	2024-09-20 15:06:27	PotentialField.cpp	72	72	call the calculator again and recalculate potential accross everything
2bfb6893	f24	p0	2024-09-20 15:06:27	PotentialField.cpp	99	99	Reset all grid values
2bfb6893	f24	p0	2024-09-20 15:06:27	PotentialField.cpp	106	106	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-20 15:06:27	PotentialField.cpp	112	112	use a while loop in main if the command is Exit just break it
2bfb6893	f24	p0	2024-09-20 15:06:27	PotentialField.cpp	130	130	Reset all potentials once before recalculating
2bfb6893	f24	p0	2024-09-20 15:06:27	PotentialField.cpp	153	153	Goal
2bfb6893	f24	p0	2024-09-20 15:06:27	PotentialField.cpp	159	159	Obstacle
2bfb6893	f24	p0	2024-09-22 00:27:24	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-22 00:27:24	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-22 00:27:24	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-22 00:27:24	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	7	7	set up constructor with intial values for N/M to 0, K set to 1, and my 2d array grid set to nullptr
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	15	15	Deconstructor
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	17	17	Checking if not nullptr
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	19	19	iterates through the Grid checking each index and deleting each of the pointer arrays
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	23	24	deletes the 2d array grid\nset the grid to nullptr to prevent any memory leaks
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	31	31	Same function as Deconstructor to dellocate any non null 2d grids
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	40	41	set N to input value\nset M to input value
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	43	43	have the grid equal to a dynamically allocated pointer array of size N
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	45	45	iterate through the grid at each index add an dynamcailly allocate array of size N creating the 2d array
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	50	51	set the initial X potential to 0\nset the initial Y potential to 0
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	58	58	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	64	64	Check if type is Goal
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	66	66	set the cell in the grid to a Goal
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	68	68	Check if type is Obtstacle
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	70	70	set grid cell to obstacle
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	72	72	call potential calcualation function to recalculate potential based on new goal/obstacble added
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	79	79	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	85	85	outputs current potential of the specfic cell in the grid
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	91	91	checks if the grid is set to nullptr or if one of the dimensions is set to 0
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	97	97	Reset all Potentials and Types
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	104	104	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	112	112	ensure K is greater than equal to 0
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	118	119	set a new calculation function\ncall the calculation function using the new K vaue
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	131	131	reset all potential values before calculating
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	138	138	if the values are the same of the t
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	148	148	Goal
2bfb6893	f24	p0	2024-09-22 00:27:24	PotentialField.cpp	154	154	Obstacle
2bfb6893	f24	p0	2024-09-22 00:31:12	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-22 00:31:12	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-22 00:31:12	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-22 00:31:12	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	7	7	set up constructor with intial values for N/M to 0, K set to 1, and my 2d array grid set to nullptr
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	15	15	Deconstructor
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	17	17	Checking if not nullptr
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	19	19	iterates through the Grid checking each index and deleting each of the pointer arrays
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	23	24	deletes the 2d array grid\nset the grid to nullptr to prevent any memory leaks
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	31	31	Same function as Deconstructor to dellocate any non null 2d grids
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	40	41	set N to input value\nset M to input value
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	43	43	have the grid equal to a dynamically allocated pointer array of size N
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	45	45	iterate through the grid at each index add an dynamcailly allocate array of size N creating the 2d array
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	50	51	set the initial X potential to 0\nset the initial Y potential to 0
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	58	58	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	64	64	Check if type is Goal
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	66	66	set the cell in the grid to a Goal
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	68	68	Check if type is Obtstacle
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	70	70	set grid cell to obstacle
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	72	72	call potential calcualation function to recalculate potential based on new goal/obstacble added
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	79	79	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	85	85	outputs current potential of the specfic cell in the grid
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	91	91	checks if the grid is set to nullptr or if one of the dimensions is set to 0
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	97	97	Reset all Potentials and Types
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	104	104	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	112	112	ensure K is greater than equal to 0
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	118	119	set a new calculation function\ncall the calculation function using the new K vaue
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	131	131	reset all potential values before calculating
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	138	138	if the values are the same of the t
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	148	148	Goal
2bfb6893	f24	p0	2024-09-22 00:31:12	PotentialField.cpp	154	154	Obstacle
2bfb6893	f24	p0	2024-09-22 00:31:35	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-22 00:31:35	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-22 00:31:35	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-22 00:31:35	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	7	7	set up constructor with intial values for N/M to 0, K set to 1, and my 2d array grid set to nullptr
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	15	15	Deconstructor
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	17	17	Checking if not nullptr
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	19	19	iterates through the Grid checking each index and deleting each of the pointer arrays
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	23	24	deletes the 2d array grid\nset the grid to nullptr to prevent any memory leaks
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	31	31	Same function as Deconstructor to dellocate any non null 2d grids
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	40	41	set N to input value\nset M to input value
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	43	43	have the grid equal to a dynamically allocated pointer array of size N
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	45	45	iterate through the grid at each index add an dynamcailly allocate array of size N creating the 2d array
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	50	51	set the initial X potential to 0\nset the initial Y potential to 0
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	58	58	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	64	64	Check if type is Goal
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	66	66	set the cell in the grid to a Goal
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	68	68	Check if type is Obtstacle
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	70	70	set grid cell to obstacle
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	72	72	call potential calcualation function to recalculate potential based on new goal/obstacble added
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	79	79	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	85	85	outputs current potential of the specfic cell in the grid
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	91	91	checks if the grid is set to nullptr or if one of the dimensions is set to 0
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	97	97	Reset all Potentials and Types
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	104	104	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	112	112	ensure K is greater than equal to 0
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	118	119	set a new calculation function\ncall the calculation function using the new K vaue
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	131	131	reset all potential values before calculating
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	138	138	if the values are the same of the t
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	148	148	Goal
2bfb6893	f24	p0	2024-09-22 00:31:35	PotentialField.cpp	154	154	Obstacle
2bfb6893	f24	p0	2024-09-22 13:11:59	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-22 13:11:59	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-22 13:11:59	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-22 13:11:59	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	15	15	set up constructor with intial values for N/M to 0, K set to 1, and my 2d array grid set to nullptr
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	23	23	Deconstructor
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	25	25	Checking if not nullptr
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	27	27	iterates through the Grid checking each index and deleting each of the pointer arrays
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	31	32	deletes the 2d array grid\nset the grid to nullptr to prevent any memory leaks
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	39	39	Same function as Deconstructor to dellocate any non null 2d grids
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	48	49	set N to input value\nset M to input value
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	51	51	have the grid equal to a dynamically allocated pointer array of size N
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	53	53	iterate through the grid at each index add an dynamcailly allocate array of size N creating the 2d array
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	58	59	set the initial X potential to 0\nset the initial Y potential to 0
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	66	66	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	72	72	Check if type is Goal
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	74	74	set the cell in the grid to a Goal
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	76	76	Check if type is Obtstacle
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	78	78	set grid cell to obstacle
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	80	80	call potential calcualation function to recalculate potential based on new goal/obstacble added
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	87	87	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	93	93	outputs current potential of the specfic cell in the grid
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	99	99	checks if the grid is set to nullptr or if one of the dimensions is set to 0
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	105	105	Reset all Potentials and Types
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	112	112	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	120	120	ensure K is greater than equal to 0
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	126	127	set a new calculation function\ncall the calculation function using the new K vaue
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	139	139	reset all potential values before calculating
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	146	146	if the values are the same of the t
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	156	156	Goal
2bfb6893	f24	p0	2024-09-22 13:11:59	PotentialField.cpp	162	162	Obstacle
2bfb6893	f24	p0	2024-09-23 13:22:27	myheader.hpp	9	9	0 is Nothing, 1 is Goal, 2 is Obstacle
2bfb6893	f24	p0	2024-09-23 13:22:27	myheader.hpp	11	11	Define the constructor inline
2bfb6893	f24	p0	2024-09-23 13:22:27	myheader.hpp	23	23	Calculation method is private
2bfb6893	f24	p0	2024-09-23 13:22:27	myheader.hpp	30	30	Declare the public methods
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	15	15	set up constructor with intial values for N/M to 0, K set to 1, and my 2d array grid set to nullptr
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	23	23	Deconstructor
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	25	25	Checking if not nullptr
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	27	27	iterates through the Grid checking each index and deleting each of the pointer arrays
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	31	32	deletes the 2d array grid\nset the grid to nullptr to prevent any memory leaks
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	39	39	Same function as Deconstructor to dellocate any non null 2d grids
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	48	49	set N to input value\nset M to input value
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	51	51	have the grid equal to a dynamically allocated pointer array of size N
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	53	53	iterate through the grid at each index add an dynamcailly allocate array of size N creating the 2d array
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	58	59	set the initial X potential to 0\nset the initial Y potential to 0
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	66	66	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	72	72	Check if type is Goal
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	74	74	set the cell in the grid to a Goal
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	76	76	Check if type is Obtstacle
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	78	78	set grid cell to obstacle
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	80	80	call potential calcualation function to recalculate potential based on new goal/obstacble added
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	87	87	check if greater than 0 and that the input values dont exceed the size of the grid
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	93	93	outputs current potential of the specfic cell in the grid
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	99	99	checks if the grid is set to nullptr or if one of the dimensions is set to 0
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	105	105	Reset all Potentials and Types
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	112	112	Reset goal/obstacle status as well
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	120	120	ensure K is greater than equal to 0
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	126	127	set a new calculation function\ncall the calculation function using the new K vaue
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	139	139	reset all potential values before calculating
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	146	146	if the values are the same of the t
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	156	156	Goal
2bfb6893	f24	p0	2024-09-23 13:22:27	PotentialField.cpp	162	162	Obstacle
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	1	1	ok according to piazza to use cmath for the sqrt function
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	4	4	default constructor
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	13	13	destructor
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	15	15	to make sure we dont delete a nullptr
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	21	21	functions to delete the linked lists
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	29	32	removes the point with coords x,y from the list\ntraverse, while its not the end\ncheck if right coords\nmeans its the head
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	34	35	not the head\nmake prev point to nocde after curr, removing the curr
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	37	37	free mem
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	41	41	to iterate if we havent found the node to remove
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	48	51	while we are not at the end of the list\ntemp to store the head\nmove the head to the next node\ndelete the node
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	55	55	point passed by reference
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	57	58	links the new point to the head + rest of list by extension\nadd the new point to the head of the list
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	65	66	allocate memory for the 2d array\n
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	68	69	for each row, allocate array of m chars\neffecitevly creating a 2d array of m x n
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	77	77	set all cells to empty
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	80	81	clear the linked lists\nclear the linked lists
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	85	87	need to ensure that the point was not a goal/obstacle before, bc if it was then we would have duplicate entires\nremove the point from the list\nremove the point from the list
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	89	89	set the type of the cell
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	92	92	add the point to the list
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	94	94	add the point to the list
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	99	99	update the value of k, check is done in a helper fucntion
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	106	106	calculate the potential for the goal and obstacle lists, use the same function just pass in the sign depending on if its a goal or an obstacle
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	113	114	calculate on the fly we dont need to store\nx naught, y naught are the coords of the goal/obstacle
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	117	117	distance formula from manual
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	120	120	calculate the potential if its not 0
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	125	125	traverse thro the linked list
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	130	130	helpers
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	133	133	check if the new dimensions are valid (positive)
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	137	138	check if the point is within the bounds of the grid and if the type is valid\ni dont remember if we need to check the type for input validation but like it makes sense to have?
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	141	141	k must be positive
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.cpp	146	146	check if the point is within the bounds of the grid
360ea78f	f24	p0	2024-09-22 13:13:00	navGrid.h	32	32	Validity check methods
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	1	1	ok according to piazza to use cmath for the sqrt function
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	4	4	default constructor
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	13	13	destructor
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	15	15	to make sure we dont delete a nullptr
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	21	21	functions to delete the linked lists
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	29	32	removes the point with coords x,y from the list\ntraverse, while its not the end\ncheck if right coords\nmeans its the head
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	34	35	not the head\nmake prev point to nocde after curr, removing the curr
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	37	37	free mem
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	41	41	to iterate if we havent found the node to remove
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	48	51	while we are not at the end of the list\ntemp to store the head\nmove the head to the next node\ndelete the node
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	55	55	point passed by reference
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	57	58	links the new point to the head + rest of list by extension\nadd the new point to the head of the list
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	65	66	allocate memory for the 2d array\n
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	68	69	for each row, allocate array of m chars\neffecitevly creating a 2d array of m x n
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	77	77	set all cells to empty
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	80	81	clear the linked lists\nclear the linked lists
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	85	87	need to ensure that the point was not a goal/obstacle before, bc if it was then we would have duplicate entires\nremove the point from the list\nremove the point from the list
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	89	89	set the type of the cell
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	92	92	add the point to the list
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	94	94	add the point to the list
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	99	99	update the value of k, check is done in a helper fucntion
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	106	106	calculate the potential for the goal and obstacle lists, use the same function just pass in the sign depending on if its a goal or an obstacle
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	113	114	calculate on the fly we dont need to store\nx naught, y naught are the coords of the goal/obstacle
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	117	117	distance formula from manual
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	120	120	calculate the potential if its not 0
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	125	125	traverse thro the linked list
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	130	130	helpers
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	133	133	check if the new dimensions are valid (positive)
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	137	138	check if the point is within the bounds of the grid and if the type is valid\ni dont remember if we need to check the type for input validation but like it makes sense to have?
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	141	141	k must be positive
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.cpp	146	146	check if the point is within the bounds of the grid
360ea78f	f24	p0	2024-09-22 13:20:29	navGrid.h	32	32	Validity check methods
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	1	1	ok according to piazza to use cmath for the sqrt function
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	4	4	default constructor
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	13	13	destructor
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	15	15	to make sure we dont delete a nullptr
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	21	21	functions to delete the linked lists
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	29	32	removes the point with coords x,y from the list\ntraverse, while its not the end\ncheck if right coords\nmeans its the head
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	34	35	not the head\nmake prev point to nocde after curr, removing the curr
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	37	37	free mem
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	41	41	to iterate if we havent found the node to remove
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	48	51	while we are not at the end of the list\ntemp to store the head\nmove the head to the next node\ndelete the node
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	55	55	point passed by reference
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	57	58	links the new point to the head + rest of list by extension\nadd the new point to the head of the list
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	65	66	allocate memory for the 2d array\n
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	68	69	for each row, allocate array of m chars\neffecitevly creating a 2d array of m x n
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	77	77	set all cells to empty
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	80	81	clear the linked lists\nclear the linked lists
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	85	87	need to ensure that the point was not a goal/obstacle before, bc if it was then we would have duplicate entires\nremove the point from the list\nremove the point from the list
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	89	89	set the type of the cell
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	92	92	add the point to the list
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	94	94	add the point to the list
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	99	99	update the value of k, check is done in a helper fucntion
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	106	106	calculate the potential for the goal and obstacle lists, use the same function just pass in the sign depending on if its a goal or an obstacle
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	113	114	calculate on the fly we dont need to store\nx naught, y naught are the coords of the goal/obstacle
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	117	117	distance formula from manual
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	120	120	calculate the potential if its not 0
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	125	125	traverse thro the linked list
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	130	130	helpers
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	133	133	check if the new dimensions are valid (positive)
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	137	138	check if the point is within the bounds of the grid and if the type is valid\ni dont remember if we need to check the type for input validation but like it makes sense to have?
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	141	141	k must be positive
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.cpp	146	146	check if the point is within the bounds of the grid
360ea78f	f24	p0	2024-09-22 13:20:42	navGrid.h	32	32	Validity check methods
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	1	1	ok according to piazza to use cmath for the sqrt function
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	4	4	default constructor
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	13	13	destructor
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	15	15	to make sure we dont delete a nullptr
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	21	21	functions to delete the linked lists
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	29	32	removes the point with coords x,y from the list\ntraverse, while its not the end\ncheck if right coords\nmeans its the head
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	34	35	not the head\nmake prev point to nocde after curr, removing the curr
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	37	37	free mem
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	41	41	to iterate if we havent found the node to remove
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	48	51	while we are not at the end of the list\ntemp to store the head\nmove the head to the next node\ndelete the node
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	55	55	point passed by reference
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	57	58	links the new point to the head + rest of list by extension\nadd the new point to the head of the list
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	65	66	allocate memory for the 2d array\n
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	68	69	for each row, allocate array of m chars\neffecitevly creating a 2d array of m x n
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	77	77	set all cells to empty
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	80	81	clear the linked lists\nclear the linked lists
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	85	87	need to ensure that the point was not a goal/obstacle before, bc if it was then we would have duplicate entires\nremove the point from the list\nremove the point from the list
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	89	89	set the type of the cell
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	92	92	add the point to the list
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	94	94	add the point to the list
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	99	99	update the value of k, check is done in a helper fucntion
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	106	106	calculate the potential for the goal and obstacle lists, use the same function just pass in the sign depending on if its a goal or an obstacle
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	113	114	calculate on the fly we dont need to store\nx naught, y naught are the coords of the goal/obstacle
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	117	117	distance formula from manual
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	120	120	calculate the potential if its not 0
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	125	125	traverse thro the linked list
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	130	130	helpers
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	133	133	check if the new dimensions are valid (positive)
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	137	138	check if the point is within the bounds of the grid and if the type is valid\ni dont remember if we need to check the type for input validation but like it makes sense to have?
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	141	141	k must be positive
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.cpp	146	146	check if the point is within the bounds of the grid
360ea78f	f24	p0	2024-09-22 13:22:19	navGrid.h	32	32	Validity check methods
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	1	1	ok according to piazza to use cmath for the sqrt function
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	4	4	default constructor
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	13	13	destructor
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	15	15	to make sure we dont delete a nullptr
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	21	21	functions to delete the linked lists
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	29	32	removes the point with coords x,y from the list\ntraverse, while its not the end\ncheck if right coords\nmeans its the head
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	34	35	not the head\nmake prev point to nocde after curr, removing the curr
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	37	37	free mem
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	41	41	to iterate if we havent found the node to remove
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	48	51	while we are not at the end of the list\ntemp to store the head\nmove the head to the next node\ndelete the node
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	55	55	point passed by reference
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	57	58	links the new point to the head + rest of list by extension\nadd the new point to the head of the list
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	65	66	allocate memory for the 2d array\n
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	68	69	for each row, allocate array of m chars\neffecitevly creating a 2d array of m x n
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	77	77	set all cells to empty
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	80	81	clear the linked lists\nclear the linked lists
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	85	87	need to ensure that the point was not a goal/obstacle before, bc if it was then we would have duplicate entires\nremove the point from the list\nremove the point from the list
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	89	89	set the type of the cell
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	92	92	add the point to the list
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	94	94	add the point to the list
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	99	99	update the value of k, check is done in a helper fucntion
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	106	106	calculate the potential for the goal and obstacle lists, use the same function just pass in the sign depending on if its a goal or an obstacle
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	113	114	calculate on the fly we dont need to store\nx naught, y naught are the coords of the goal/obstacle
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	117	117	distance formula from manual
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	120	120	calculate the potential if its not 0
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	125	125	traverse thro the linked list
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	130	130	helpers
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	133	133	check if the new dimensions are valid (positive)
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	137	138	check if the point is within the bounds of the grid and if the type is valid\ni dont remember if we need to check the type for input validation but like it makes sense to have?
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	141	141	k must be positive
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.cpp	146	146	check if the point is within the bounds of the grid
360ea78f	f24	p0	2024-09-22 13:30:17	navGrid.h	32	32	Validity check methods
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	1	1	ok according to piazza to use cmath for the sqrt function
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	4	4	default constructor
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	13	13	destructor
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	15	15	to make sure we dont delete a nullptr
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	21	21	functions to delete the linked lists
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	29	32	removes the point with coords x,y from the list\ntraverse, while its not the end\ncheck if right coords\nmeans its the head
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	34	35	not the head\nmake prev point to nocde after curr, removing the curr
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	37	37	free mem
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	41	41	to iterate if we havent found the node to remove
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	48	51	while we are not at the end of the list\ntemp to store the head\nmove the head to the next node\ndelete the node
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	55	55	point passed by reference
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	57	58	links the new point to the head + rest of list by extension\nadd the new point to the head of the list
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	73	73	end citation
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	78	79	allocate memory for the 2d array\n
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	81	82	for each row, allocate array of m chars\neffecitevly creating a 2d array of m x n
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	90	90	set all cells to empty
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	93	94	clear the linked lists\nclear the linked lists
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	98	100	need to ensure that the point was not a goal/obstacle before, bc if it was then we would have duplicate entires\nremove the point from the list\nremove the point from the list
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	102	102	set the type of the cell
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	105	105	add the point to the list
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	107	107	add the point to the list
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	112	112	update the value of k, check is done in a helper fucntion
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	119	119	calculate the potential for the goal and obstacle lists, use the same function just pass in the sign depending on if its a goal or an obstacle
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	126	127	calculate on the fly we dont need to store\nx naught, y naught are the coords of the goal/obstacle
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	130	130	distance formula from manual
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	133	133	calculate the potential if its not 0
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	138	138	traverse thro the linked list
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	143	143	helpers
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	146	146	check if the new dimensions are valid (positive)
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	150	151	check if the point is within the bounds of the grid and if the type is valid\ni dont remember if we need to check the type for input validation but like it makes sense to have?
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	154	154	k must be positive
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.cpp	159	159	check if the point is within the bounds of the grid
360ea78f	f24	p0	2024-09-22 13:37:57	navGrid.h	32	32	Validity check methods
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	1	1	ok according to piazza to use cmath for the sqrt function
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	4	4	default constructor
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	13	13	destructor
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	15	15	to make sure we dont delete a nullptr
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	21	21	functions to delete the linked lists
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	29	32	removes the point with coords x,y from the list\ntraverse, while its not the end\ncheck if right coords\nmeans its the head
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	34	35	not the head\nmake prev point to nocde after curr, removing the curr
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	37	37	free mem
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	41	41	to iterate if we havent found the node to remove
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	48	51	while we are not at the end of the list\ntemp to store the head\nmove the head to the next node\ndelete the node
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	55	55	point passed by reference
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	57	58	links the new point to the head + rest of list by extension\nadd the new point to the head of the list
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	73	73	end citation
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	78	79	allocate memory for the 2d array\n
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	81	82	for each row, allocate array of m chars\neffecitevly creating a 2d array of m x n
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	90	90	set all cells to empty
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	93	94	clear the linked lists\nclear the linked lists
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	98	100	need to ensure that the point was not a goal/obstacle before, bc if it was then we would have duplicate entires\nremove the point from the list\nremove the point from the list
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	102	102	set the type of the cell
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	105	105	add the point to the list
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	107	107	add the point to the list
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	112	112	update the value of k, check is done in a helper fucntion
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	119	119	calculate the potential for the goal and obstacle lists, use the same function just pass in the sign depending on if its a goal or an obstacle
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	126	127	calculate on the fly we dont need to store\nx naught, y naught are the coords of the goal/obstacle
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	130	130	distance formula from manual
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	133	133	calculate the potential if its not 0
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	138	138	traverse thro the linked list
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	143	143	helpers
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	146	146	check if the new dimensions are valid (positive)
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	150	151	check if the point is within the bounds of the grid and if the type is valid\ni dont remember if we need to check the type for input validation but like it makes sense to have?
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	154	154	k must be positive
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.cpp	159	159	check if the point is within the bounds of the grid
360ea78f	f24	p0	2024-09-22 22:30:42	navGrid.h	32	32	Validity check methods
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	1	1	ok according to piazza to use cmath for the sqrt function
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	4	4	default constructor
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	13	13	destructor
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	15	15	to make sure we dont delete a nullptr
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	21	21	functions to delete the linked lists
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	29	32	removes the point with coords x,y from the list\ntraverse, while its not the end\ncheck if right coords\nmeans its the head
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	34	35	not the head\nmake prev point to nocde after curr, removing the curr
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	37	37	free mem
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	41	41	to iterate if we havent found the node to remove
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	48	51	while we are not at the end of the list\ntemp to store the head\nmove the head to the next node\ndelete the node
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	55	55	point passed by reference
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	57	58	links the new point to the head + rest of list by extension\nadd the new point to the head of the list
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	73	73	end citation
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	78	79	allocate memory for the 2d array\n
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	81	82	for each row, allocate array of m chars\neffecitevly creating a 2d array of m x n
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	90	90	set all cells to empty
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	93	94	clear the linked lists\nclear the linked lists
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	98	100	need to ensure that the point was not a goal/obstacle before, bc if it was then we would have duplicate entires\nremove the point from the list\nremove the point from the list
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	102	102	set the type of the cell
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	105	105	add the point to the list
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	107	107	add the point to the list
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	112	112	update the value of k, check is done in a helper fucntion
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	119	119	calculate the potential for the goal and obstacle lists, use the same function just pass in the sign depending on if its a goal or an obstacle
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	126	127	calculate on the fly we dont need to store\nx naught, y naught are the coords of the goal/obstacle
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	130	130	distance formula from manual
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	133	133	calculate the potential if its not 0
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	138	138	traverse thro the linked list
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	143	143	helpers
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	146	146	check if the new dimensions are valid (positive)
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	150	151	check if the point is within the bounds of the grid and if the type is valid\ni dont remember if we need to check the type for input validation but like it makes sense to have?
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	154	154	k must be positive
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.cpp	159	159	check if the point is within the bounds of the grid
360ea78f	f24	p0	2024-09-23 19:29:57	navGrid.h	32	32	Validity check methods
3a27a0a8	f24	p0	2024-09-23 00:26:54	goMap.cpp	9	9	create 2D array
3a27a0a8	f24	p0	2024-09-23 00:26:54	goMap.cpp	11	11	initialize all map values to 0
3a27a0a8	f24	p0	2024-09-23 00:26:54	goMap.cpp	18	18	deallocate each row
3a27a0a8	f24	p0	2024-09-23 00:26:54	goMap.cpp	20	20	deallocate array of pointers
3a27a0a8	f24	p0	2024-09-23 00:26:54	goMap.cpp	29	29	-1 represents an obstacle in the array
3a27a0a8	f24	p0	2024-09-23 00:26:54	goMap.cpp	31	31	1 represents a goal in the array
3a27a0a8	f24	p0	2024-09-23 00:26:54	goMap.cpp	55	55	since the calculation for Px and Py are the same, only one value is returned
3a27a0a8	f24	p0	2024-09-23 00:26:54	goMap.cpp	61	61	reset all values to 0
3a27a0a8	f24	p0	2024-09-23 00:30:09	goMap.cpp	9	9	create 2D array
3a27a0a8	f24	p0	2024-09-23 00:30:09	goMap.cpp	11	11	initialize all map values to 0
3a27a0a8	f24	p0	2024-09-23 00:30:09	goMap.cpp	18	18	deallocate each row
3a27a0a8	f24	p0	2024-09-23 00:30:09	goMap.cpp	20	20	deallocate array of pointers
3a27a0a8	f24	p0	2024-09-23 00:30:09	goMap.cpp	29	29	-1 represents an obstacle in the array
3a27a0a8	f24	p0	2024-09-23 00:30:09	goMap.cpp	31	31	1 represents a goal in the array
3a27a0a8	f24	p0	2024-09-23 00:30:09	goMap.cpp	55	55	since the calculation for Px and Py are the same, only one value is returned
3a27a0a8	f24	p0	2024-09-23 00:30:09	goMap.cpp	61	61	reset all values to 0
3a27a0a8	f24	p0	2024-09-23 10:47:43	goMap.cpp	9	9	create 2D array
3a27a0a8	f24	p0	2024-09-23 10:47:43	goMap.cpp	11	11	initialize all map values to 0
3a27a0a8	f24	p0	2024-09-23 10:47:43	goMap.cpp	18	18	deallocate each row
3a27a0a8	f24	p0	2024-09-23 10:47:43	goMap.cpp	20	20	deallocate array of pointers
3a27a0a8	f24	p0	2024-09-23 10:47:43	goMap.cpp	29	29	-1 represents an obstacle in the array
3a27a0a8	f24	p0	2024-09-23 10:47:43	goMap.cpp	31	31	1 represents a goal in the array
3a27a0a8	f24	p0	2024-09-23 10:47:43	goMap.cpp	55	55	since the calculation for Px and Py are the same, only one value is returned
3a27a0a8	f24	p0	2024-09-23 10:47:43	goMap.cpp	61	61	reset all values to 0
3a27a0a8	f24	p0	2024-09-23 11:09:26	goMap.cpp	9	9	create 2D array
3a27a0a8	f24	p0	2024-09-23 11:09:26	goMap.cpp	11	11	initialize all map values to 0
3a27a0a8	f24	p0	2024-09-23 11:09:26	goMap.cpp	18	18	deallocate each row
3a27a0a8	f24	p0	2024-09-23 11:09:26	goMap.cpp	20	20	deallocate array of pointers
3a27a0a8	f24	p0	2024-09-23 11:09:26	goMap.cpp	29	29	-1 represents an obstacle in the array
3a27a0a8	f24	p0	2024-09-23 11:09:26	goMap.cpp	31	31	1 represents a goal in the array
3a27a0a8	f24	p0	2024-09-23 11:09:26	goMap.cpp	55	55	since the calculation for Px and Py are the same, only one value is returned
3a27a0a8	f24	p0	2024-09-23 11:09:26	goMap.cpp	61	61	reset all values to 0
3a27a0a8	f24	p0	2024-09-23 14:49:54	goMap.cpp	9	9	create 2D array
3a27a0a8	f24	p0	2024-09-23 14:49:54	goMap.cpp	11	11	initialize all map values to 0
3a27a0a8	f24	p0	2024-09-23 14:49:54	goMap.cpp	18	18	deallocate each row
3a27a0a8	f24	p0	2024-09-23 14:49:54	goMap.cpp	20	20	deallocate array of pointers
3a27a0a8	f24	p0	2024-09-23 14:49:54	goMap.cpp	29	29	-1 represents an obstacle in the array
3a27a0a8	f24	p0	2024-09-23 14:49:54	goMap.cpp	31	31	1 represents a goal in the array
3a27a0a8	f24	p0	2024-09-23 14:49:54	goMap.cpp	55	55	since the calculation for Px and Py are the same, only one value is returned
3a27a0a8	f24	p0	2024-09-23 14:49:54	goMap.cpp	61	61	reset all values to 0
3a27a0a8	f24	p0	2024-09-23 20:45:52	goMap.cpp	9	9	create 2D array
3a27a0a8	f24	p0	2024-09-23 20:45:52	goMap.cpp	11	11	initialize all map values to 0
3a27a0a8	f24	p0	2024-09-23 20:45:52	goMap.cpp	18	18	deallocate each row
3a27a0a8	f24	p0	2024-09-23 20:45:52	goMap.cpp	20	20	deallocate array of pointers
3a27a0a8	f24	p0	2024-09-23 20:45:52	goMap.cpp	29	29	-1 represents an obstacle in the array
3a27a0a8	f24	p0	2024-09-23 20:45:52	goMap.cpp	31	31	1 represents a goal in the array
3a27a0a8	f24	p0	2024-09-23 20:45:52	goMap.cpp	55	55	since the calculation for Px and Py are the same, only one value is returned
3a27a0a8	f24	p0	2024-09-23 20:45:52	goMap.cpp	61	61	reset all values to 0
3c85ec20	f24	p0	2024-09-22 00:46:08	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 00:46:08	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-22 00:46:08	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-22 00:46:08	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 00:46:08	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-22 00:46:08	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-22 00:46:08	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-22 00:46:08	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-22 00:46:08	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-22 00:46:08	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-22 00:46:08	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-22 00:46:08	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 00:46:08	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-22 00:46:08	map.cpp	55	55	iterate through grid
3c85ec20	f24	p0	2024-09-22 00:46:08	map.cpp	60	60	x = y
3c85ec20	f24	p0	2024-09-22 00:46:08	map.cpp	62	62	Iterate through objects
3c85ec20	f24	p0	2024-09-22 00:46:08	map.cpp	69	69	Point is a object
3c85ec20	f24	p0	2024-09-22 00:46:08	map.cpp	71	71	potential from object is 0
3c85ec20	f24	p0	2024-09-22 00:46:08	map.cpp	77	77	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-22 00:46:08	map.cpp	87	87	check if object exists at the point
3c85ec20	f24	p0	2024-09-22 00:46:08	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 00:46:08	map.hpp	11	11	Inline Helper Functions
3c85ec20	f24	p0	2024-09-22 00:46:08	map.hpp	20	21	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-22 00:46:08	map.hpp	38	38	helpers
3c85ec20	f24	p0	2024-09-22 00:46:08	map.hpp	47	47	PROJECT0_MAP_HPP
3c85ec20	f24	p0	2024-09-22 00:50:04	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 00:50:04	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-22 00:50:04	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-22 00:50:04	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 00:50:04	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-22 00:50:04	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-22 00:50:04	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-22 00:50:04	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-22 00:50:04	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-22 00:50:04	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-22 00:50:04	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-22 00:50:04	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 00:50:04	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-22 00:50:04	map.cpp	55	55	iterate through grid
3c85ec20	f24	p0	2024-09-22 00:50:04	map.cpp	60	60	x = y
3c85ec20	f24	p0	2024-09-22 00:50:04	map.cpp	62	62	Iterate through objects
3c85ec20	f24	p0	2024-09-22 00:50:04	map.cpp	69	69	Point is a object
3c85ec20	f24	p0	2024-09-22 00:50:04	map.cpp	71	71	potential from object is 0
3c85ec20	f24	p0	2024-09-22 00:50:04	map.cpp	77	77	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-22 00:50:04	map.cpp	87	87	check if object exists at the point
3c85ec20	f24	p0	2024-09-22 00:50:04	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 00:50:04	map.hpp	11	11	Inline Helper Functions
3c85ec20	f24	p0	2024-09-22 00:50:04	map.hpp	20	21	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-22 00:50:04	map.hpp	38	38	helpers
3c85ec20	f24	p0	2024-09-22 00:50:04	map.hpp	47	47	PROJECT0_MAP_HPP
3c85ec20	f24	p0	2024-09-22 01:17:47	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:17:47	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-22 01:17:47	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-22 01:17:47	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 01:17:47	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-22 01:17:47	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-22 01:17:47	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-22 01:17:47	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-22 01:17:47	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-22 01:17:47	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-22 01:17:47	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-22 01:17:47	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:17:47	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-22 01:17:47	map.cpp	55	55	iterate through grid
3c85ec20	f24	p0	2024-09-22 01:17:47	map.cpp	60	60	x = y
3c85ec20	f24	p0	2024-09-22 01:17:47	map.cpp	62	62	Iterate through objects
3c85ec20	f24	p0	2024-09-22 01:17:47	map.cpp	69	69	Point is a object
3c85ec20	f24	p0	2024-09-22 01:17:47	map.cpp	71	71	potential from object is 0
3c85ec20	f24	p0	2024-09-22 01:17:47	map.cpp	77	77	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-22 01:17:47	map.cpp	87	87	check if object exists at the point
3c85ec20	f24	p0	2024-09-22 01:17:47	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:17:47	map.hpp	11	11	Inline Helper Functions
3c85ec20	f24	p0	2024-09-22 01:17:47	map.hpp	20	21	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-22 01:17:47	map.hpp	38	38	helpers
3c85ec20	f24	p0	2024-09-22 01:17:47	map.hpp	47	47	PROJECT0_MAP_HPP
3c85ec20	f24	p0	2024-09-22 01:33:10	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:33:10	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-22 01:33:10	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-22 01:33:10	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 01:33:10	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-22 01:33:10	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-22 01:33:10	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-22 01:33:10	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-22 01:33:10	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-22 01:33:10	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-22 01:33:10	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-22 01:33:10	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:33:10	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-22 01:33:10	map.cpp	55	55	iterate through grid
3c85ec20	f24	p0	2024-09-22 01:33:10	map.cpp	60	60	x = y
3c85ec20	f24	p0	2024-09-22 01:33:10	map.cpp	62	62	Iterate through objects
3c85ec20	f24	p0	2024-09-22 01:33:10	map.cpp	69	69	Point is a object
3c85ec20	f24	p0	2024-09-22 01:33:10	map.cpp	71	71	potential from object is 0
3c85ec20	f24	p0	2024-09-22 01:33:10	map.cpp	77	77	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-22 01:33:10	map.cpp	87	87	check if object exists at the point
3c85ec20	f24	p0	2024-09-22 01:33:10	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:33:10	map.hpp	11	11	Inline Helper Functions
3c85ec20	f24	p0	2024-09-22 01:33:10	map.hpp	20	21	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-22 01:33:10	map.hpp	38	38	helpers
3c85ec20	f24	p0	2024-09-22 01:33:10	map.hpp	47	47	PROJECT0_MAP_HPP
3c85ec20	f24	p0	2024-09-22 01:46:42	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:46:42	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-22 01:46:42	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-22 01:46:42	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 01:46:42	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-22 01:46:42	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-22 01:46:42	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-22 01:46:42	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-22 01:46:42	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-22 01:46:42	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-22 01:46:42	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-22 01:46:42	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:46:42	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-22 01:46:42	map.cpp	55	55	iterate through grid
3c85ec20	f24	p0	2024-09-22 01:46:42	map.cpp	60	60	x = y
3c85ec20	f24	p0	2024-09-22 01:46:42	map.cpp	62	62	Iterate through objects
3c85ec20	f24	p0	2024-09-22 01:46:42	map.cpp	69	69	Point is a object
3c85ec20	f24	p0	2024-09-22 01:46:42	map.cpp	71	71	potential from object is 0
3c85ec20	f24	p0	2024-09-22 01:46:42	map.cpp	77	77	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-22 01:46:42	map.cpp	87	87	check if object exists at the point
3c85ec20	f24	p0	2024-09-22 01:46:42	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:46:42	map.hpp	11	11	Inline Helper Functions
3c85ec20	f24	p0	2024-09-22 01:46:42	map.hpp	20	21	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-22 01:46:42	map.hpp	38	38	helpers
3c85ec20	f24	p0	2024-09-22 01:46:42	map.hpp	47	47	PROJECT0_MAP_HPP
3c85ec20	f24	p0	2024-09-22 01:48:32	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:48:32	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-22 01:48:32	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-22 01:48:32	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 01:48:32	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-22 01:48:32	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-22 01:48:32	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-22 01:48:32	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-22 01:48:32	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-22 01:48:32	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-22 01:48:32	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-22 01:48:32	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:48:32	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-22 01:48:32	map.cpp	55	55	iterate through grid
3c85ec20	f24	p0	2024-09-22 01:48:32	map.cpp	60	60	x = y
3c85ec20	f24	p0	2024-09-22 01:48:32	map.cpp	62	62	Iterate through objects
3c85ec20	f24	p0	2024-09-22 01:48:32	map.cpp	69	69	Point is a object
3c85ec20	f24	p0	2024-09-22 01:48:32	map.cpp	71	71	potential from object is 0
3c85ec20	f24	p0	2024-09-22 01:48:32	map.cpp	77	77	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-22 01:48:32	map.cpp	87	87	check if object exists at the point
3c85ec20	f24	p0	2024-09-22 01:48:32	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 01:48:32	map.hpp	12	12	Inline Helper Functions
3c85ec20	f24	p0	2024-09-22 01:48:32	map.hpp	21	22	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-22 01:48:32	map.hpp	39	39	helpers
3c85ec20	f24	p0	2024-09-22 01:48:32	map.hpp	48	48	PROJECT0_MAP_HPP
3c85ec20	f24	p0	2024-09-22 02:04:29	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 02:04:29	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-22 02:04:29	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-22 02:04:29	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 02:04:29	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-22 02:04:29	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-22 02:04:29	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-22 02:04:29	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-22 02:04:29	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-22 02:04:29	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-22 02:04:29	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-22 02:04:29	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 02:04:29	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-22 02:04:29	map.cpp	57	57	iterate through grid
3c85ec20	f24	p0	2024-09-22 02:04:29	map.cpp	62	62	x = y
3c85ec20	f24	p0	2024-09-22 02:04:29	map.cpp	64	64	Iterate through objects
3c85ec20	f24	p0	2024-09-22 02:04:29	map.cpp	71	71	Point is a object
3c85ec20	f24	p0	2024-09-22 02:04:29	map.cpp	73	73	potential from object is 0
3c85ec20	f24	p0	2024-09-22 02:04:29	map.cpp	79	79	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-22 02:04:29	map.cpp	89	89	check if object exists at the point
3c85ec20	f24	p0	2024-09-22 02:04:29	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 02:04:29	map.hpp	12	12	Inline Helper Functions
3c85ec20	f24	p0	2024-09-22 02:04:29	map.hpp	21	22	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-22 02:04:29	map.hpp	39	39	helpers
3c85ec20	f24	p0	2024-09-22 02:04:29	map.hpp	48	48	PROJECT0_MAP_HPP
3c85ec20	f24	p0	2024-09-22 02:06:29	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 02:06:29	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-22 02:06:29	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-22 02:06:29	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 02:06:29	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-22 02:06:29	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-22 02:06:29	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-22 02:06:29	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-22 02:06:29	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-22 02:06:29	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-22 02:06:29	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-22 02:06:29	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 02:06:29	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-22 02:06:29	map.cpp	57	57	iterate through grid
3c85ec20	f24	p0	2024-09-22 02:06:29	map.cpp	62	62	x = y
3c85ec20	f24	p0	2024-09-22 02:06:29	map.cpp	64	64	Iterate through objects
3c85ec20	f24	p0	2024-09-22 02:06:29	map.cpp	71	71	Point is a object
3c85ec20	f24	p0	2024-09-22 02:06:29	map.cpp	73	73	potential from object is 0
3c85ec20	f24	p0	2024-09-22 02:06:29	map.cpp	79	79	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-22 02:06:29	map.cpp	89	89	check if object exists at the point
3c85ec20	f24	p0	2024-09-22 02:06:29	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-22 02:06:29	map.hpp	12	12	Inline Helper Functions
3c85ec20	f24	p0	2024-09-22 02:06:29	map.hpp	21	22	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-22 02:06:29	map.hpp	39	39	helpers
3c85ec20	f24	p0	2024-09-22 02:06:29	map.hpp	48	48	PROJECT0_MAP_HPP
3c85ec20	f24	p0	2024-09-23 16:25:38	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-23 16:25:38	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-23 16:25:38	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-23 16:25:38	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-23 16:25:38	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-23 16:25:38	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-23 16:25:38	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-23 16:25:38	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-23 16:25:38	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-23 16:25:38	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-23 16:25:38	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-23 16:25:38	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-23 16:25:38	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-23 16:25:38	map.cpp	57	57	iterate through grid
3c85ec20	f24	p0	2024-09-23 16:25:38	map.cpp	62	62	x = y
3c85ec20	f24	p0	2024-09-23 16:25:38	map.cpp	64	64	Iterate through objects
3c85ec20	f24	p0	2024-09-23 16:25:38	map.cpp	71	71	Point is a object
3c85ec20	f24	p0	2024-09-23 16:25:38	map.cpp	73	73	potential from object is 0
3c85ec20	f24	p0	2024-09-23 16:25:38	map.cpp	79	79	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-23 16:25:38	map.cpp	89	89	check if object exists at the point
3c85ec20	f24	p0	2024-09-23 16:25:38	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-23 16:25:38	map.hpp	12	12	Inline Helper Functions
3c85ec20	f24	p0	2024-09-23 16:25:38	map.hpp	21	22	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-23 16:25:38	map.hpp	39	39	helpers
3c85ec20	f24	p0	2024-09-23 16:25:38	map.hpp	48	48	PROJECT0_MAP_HPP
3c85ec20	f24	p0	2024-09-23 16:32:48	list.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-23 16:32:48	list.cpp	8	8	empty destructor
3c85ec20	f24	p0	2024-09-23 16:32:48	list.cpp	37	37	Destructor
3c85ec20	f24	p0	2024-09-23 16:32:48	list.cpp	42	42	Insert at the beginning
3c85ec20	f24	p0	2024-09-23 16:32:48	list.cpp	49	49	Clear the entire list
3c85ec20	f24	p0	2024-09-23 16:32:48	list.cpp	63	63	Case 1: nodeToDelete is the head
3c85ec20	f24	p0	2024-09-23 16:32:48	list.cpp	71	71	Case 2: nodeToDelete is not the last node
3c85ec20	f24	p0	2024-09-23 16:32:48	list.cpp	80	80	Case 3: nodeToDelete is the last node
3c85ec20	f24	p0	2024-09-23 16:32:48	list.cpp	99	99	returns nullptr if doesnt exist
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	11	11	-1 for goal, 1 for obstacle
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	16	16	empty destructor
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	34	34	Destructor
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	37	37	Insert at the beginning
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	40	40	Clear the entire list
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	43	43	Delete Pair
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	46	46	Check exists
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	49	49	Get Head
3c85ec20	f24	p0	2024-09-23 16:32:48	list.hpp	55	55	PROJECT0_LIST_HPP
3c85ec20	f24	p0	2024-09-23 16:32:48	main.cpp	7	7	Test File
3c85ec20	f24	p0	2024-09-23 16:32:48	map.cpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-23 16:32:48	map.cpp	18	18	initialize grid to potentials of 0s
3c85ec20	f24	p0	2024-09-23 16:32:48	map.cpp	57	57	iterate through grid
3c85ec20	f24	p0	2024-09-23 16:32:48	map.cpp	62	62	x = y
3c85ec20	f24	p0	2024-09-23 16:32:48	map.cpp	64	64	Iterate through objects
3c85ec20	f24	p0	2024-09-23 16:32:48	map.cpp	71	71	Point is a object
3c85ec20	f24	p0	2024-09-23 16:32:48	map.cpp	73	73	potential from object is 0
3c85ec20	f24	p0	2024-09-23 16:32:48	map.cpp	79	79	Subtract potential since goals attract
3c85ec20	f24	p0	2024-09-23 16:32:48	map.cpp	89	89	check if object exists at the point
3c85ec20	f24	p0	2024-09-23 16:32:48	map.hpp	1	3	\nCreated by Ali A on 2024-09-21.\n
3c85ec20	f24	p0	2024-09-23 16:32:48	map.hpp	12	12	Inline Helper Functions
3c85ec20	f24	p0	2024-09-23 16:32:48	map.hpp	21	22	flattened grid: each row sequentially, stores potential vector at each point\nlist of coordinates of objects
3c85ec20	f24	p0	2024-09-23 16:32:48	map.hpp	39	39	helpers
3c85ec20	f24	p0	2024-09-23 16:32:48	map.hpp	48	48	PROJECT0_MAP_HPP
3de202eb	f24	p0	2024-09-20 15:44:24	project_0.cpp	6	6	variable declaration
3de202eb	f24	p0	2024-09-20 15:44:24	project_0.cpp	60	60	Map class members functions
3de202eb	f24	p0	2024-09-20 15:44:24	project_0.cpp	149	149	Independent functions (Doesn't belongs to any classes)
3de202eb	f24	p0	2024-09-20 15:50:46	project_0.cpp	6	6	variable declaration
3de202eb	f24	p0	2024-09-20 15:50:46	project_0.cpp	60	60	Map class members functions
3de202eb	f24	p0	2024-09-20 15:50:46	project_0.cpp	149	149	Independent functions (Doesn't belongs to any classes)
3de202eb	f24	p0	2024-09-20 16:15:50	project_0.cpp	6	6	variable declaration
3de202eb	f24	p0	2024-09-20 16:15:50	project_0.cpp	63	63	Map class members functions
3de202eb	f24	p0	2024-09-20 16:15:50	project_0.cpp	152	152	Independent functions (Doesn't belongs to any classes)
3de202eb	f24	p0	2024-09-20 16:25:35	project_0.cpp	6	6	variable declaration
3de202eb	f24	p0	2024-09-20 16:25:35	project_0.cpp	72	72	Map class members functions
3de202eb	f24	p0	2024-09-20 16:25:35	project_0.cpp	161	161	Independent functions (Doesn't belongs to any classes)
3de202eb	f24	p0	2024-09-20 17:31:42	project_0.cpp	6	6	variable declaration
3de202eb	f24	p0	2024-09-20 17:31:42	project_0.cpp	72	72	Map class members functions
3de202eb	f24	p0	2024-09-20 17:31:42	project_0.cpp	161	161	Independent functions (Doesn't belongs to any classes)
3de202eb	f24	p0	2024-09-20 19:13:14	project_0.cpp	6	6	variable declaration
3de202eb	f24	p0	2024-09-20 19:13:14	project_0.cpp	72	72	Map class members functions
3de202eb	f24	p0	2024-09-20 19:13:14	project_0.cpp	161	161	Independent functions (Doesn't belongs to any classes)
3de202eb	f24	p0	2024-09-21 12:06:55	project_0.cpp	6	6	variable declaration
3de202eb	f24	p0	2024-09-21 12:06:55	project_0.cpp	72	72	Map class members functions
3de202eb	f24	p0	2024-09-21 12:06:55	project_0.cpp	161	161	Independent functions (Doesn't belongs to any classes)
3de202eb	f24	p0	2024-09-22 00:05:45	project_0.cpp	6	6	variable declaration
3de202eb	f24	p0	2024-09-22 00:05:45	project_0.cpp	79	79	Map class members functions
3de202eb	f24	p0	2024-09-22 00:05:45	project_0.cpp	168	168	Independent functions (Doesn't belongs to any classes)
3e723143	f24	p0	2024-09-20 15:09:34	project_0.cpp	4	4	Constructor
3e723143	f24	p0	2024-09-20 15:09:34	project_0.cpp	15	15	Destructor to free the memory for the 2D array
3e723143	f24	p0	2024-09-20 15:09:34	project_0.cpp	23	23	To update potential field after placing a goal or obstacle
3e723143	f24	p0	2024-09-20 15:09:34	project_0.cpp	39	39	To place goals or obstacles and recalculate potential field
3e723143	f24	p0	2024-09-20 15:09:34	project_0.cpp	50	50	Suggests potential values at the given (x, y) position
3e723143	f24	p0	2024-09-20 15:09:34	project_0.cpp	63	63	To clear the grid and reset potentials
3e723143	f24	p0	2024-09-20 15:09:34	project_0.cpp	73	73	ToU update the force constant used in the potential field calculations
3e723143	f24	p0	2024-09-20 15:09:34	project_0.h	15	15	Our main dynamically allocated 2D array
3e723143	f24	p0	2024-09-20 15:11:36	project_0.cpp	4	4	Constructor
3e723143	f24	p0	2024-09-20 15:11:36	project_0.cpp	15	15	Destructor to free the memory for the 2D array
3e723143	f24	p0	2024-09-20 15:11:36	project_0.cpp	23	23	To update potential field after placing a goal or obstacle
3e723143	f24	p0	2024-09-20 15:11:36	project_0.cpp	39	39	To place goals or obstacles and recalculate potential field
3e723143	f24	p0	2024-09-20 15:11:36	project_0.cpp	50	50	Suggests potential values at the given (x, y) position
3e723143	f24	p0	2024-09-20 15:11:36	project_0.cpp	63	63	To clear the grid and reset potentials
3e723143	f24	p0	2024-09-20 15:11:36	project_0.cpp	73	73	ToU update the force constant used in the potential field calculations
3e723143	f24	p0	2024-09-20 15:11:36	project_0.h	15	15	Our main dynamically allocated 2D array
3e723143	f24	p0	2024-09-20 15:13:02	project_0.cpp	4	4	Constructor
3e723143	f24	p0	2024-09-20 15:13:02	project_0.cpp	15	15	Destructor to free the memory for the 2D array
3e723143	f24	p0	2024-09-20 15:13:02	project_0.cpp	23	23	To update potential field after placing a goal or obstacle
3e723143	f24	p0	2024-09-20 15:13:02	project_0.cpp	39	39	To place goals or obstacles and recalculate potential field
3e723143	f24	p0	2024-09-20 15:13:02	project_0.cpp	50	50	Suggests potential values at the given (x, y) position
3e723143	f24	p0	2024-09-20 15:13:02	project_0.cpp	63	63	To clear the grid and reset potentials
3e723143	f24	p0	2024-09-20 15:13:02	project_0.cpp	73	73	ToU update the force constant used in the potential field calculations
3e723143	f24	p0	2024-09-20 15:13:02	project_0.h	15	15	Our main dynamically allocated 2D array
3eeb41bb	f24	p0	2024-09-21 03:49:05	Code.cpp	20	20	Problem sets (1,1) as the starting grid instead of (0,0), thus a conversion is needed
3eeb41bb	f24	p0	2024-09-21 03:49:05	Code.cpp	49	50	delete array;\narray = nullptr;
3eeb41bb	f24	p0	2024-09-22 16:06:58	Code.cpp	39	39	std::cout << i << " " << px << " " << py;
3eeb41bb	f24	p0	2024-09-22 16:06:58	Code.cpp	46	46	std::cout << i << " " << c << " " << d << " " << px << " " << py << std::endl;
3eeb41bb	f24	p0	2024-09-22 16:06:58	Code.cpp	53	53	std::cout << i  << " " << c << " " << d << " " << px << " " << py << std::endl;
3eeb41bb	f24	p0	2024-09-22 16:06:58	Code.cpp	62	63	delete array;\narray = nullptr;
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	48	48	checks if position is valid
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	50	50	position is out of bounds
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	53	53	Resets value if there is a goal in the cell
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	56	56	Resets value if there is a
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	60	60	add goal or obstacle
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	64	64	add was successful
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	96	96	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	101	101	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	108	108	new value is not valid
3f648950	f24	p0	2024-09-22 14:48:42	field.cpp	123	123	Successfully updated
3f648950	f24	p0	2024-09-22 14:48:42	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-22 14:48:42	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-22 14:48:42	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-22 14:48:42	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-22 14:48:42	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	44	44	Print Px Py
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	46	46	Move failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	49	49	Map not yet created
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	53	53	Make sure the map exists
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	57	57	Map not yet created
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	64	64	Make sure the map exists
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	68	68	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	71	71	Map not yet created
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	75	75	End of input
3f648950	f24	p0	2024-09-22 14:48:42	main.cpp	79	79	Clean up the dynamically allocated memory if needed
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	48	48	checks if position is valid
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	50	50	position is out of bounds
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	53	53	Resets value if there is a goal in the cell
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	56	56	Resets value if there is a
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	60	60	add goal or obstacle
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	64	64	add was successful
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	96	96	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	101	101	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	108	108	new value is not valid
3f648950	f24	p0	2024-09-22 14:53:05	field.cpp	123	123	Successfully updated
3f648950	f24	p0	2024-09-22 14:53:05	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-22 14:53:05	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-22 14:53:05	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-22 14:53:05	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-22 14:53:05	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	44	44	Print Px Py
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	46	46	Move failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	49	49	Map not yet created
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	53	53	Make sure the map exists
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	57	57	Map not yet created
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	64	64	Make sure the map exists
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	68	68	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	71	71	Map not yet created
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	75	75	End of input
3f648950	f24	p0	2024-09-22 14:53:05	main.cpp	79	79	Clean up the dynamically allocated memory if needed
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	48	48	checks if position is valid
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	50	50	position is out of bounds
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	53	53	Resets value if there is a goal in the cell
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	56	56	Resets value if there is a
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	60	60	add goal or obstacle
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	64	64	add was successful
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	96	96	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	101	101	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	108	108	new value is not valid
3f648950	f24	p0	2024-09-22 15:02:42	field.cpp	123	123	Successfully updated
3f648950	f24	p0	2024-09-22 15:02:42	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-22 15:02:42	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-22 15:02:42	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-22 15:02:42	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-22 15:02:42	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	44	44	Print Px Py
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	46	46	Move failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	49	49	Map not yet created
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	53	53	Make sure the map exists
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	57	57	Map not yet created
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	64	64	Make sure the map exists
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	68	68	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	71	71	Map not yet created
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	75	75	End of input
3f648950	f24	p0	2024-09-22 15:02:42	main.cpp	79	79	Clean up the dynamically allocated memory if needed
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	47	47	checks if position is valid
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	49	49	position is out of bounds
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	52	57	if(grid[x][y].getContent() == 'G'){ // Resets value if there is a goal in the cell\ncomputePotential(x, y, false);\n}\nelse if(grid[x][y].getContent() == 'O'){ // Resets value if there is a\ncomputePotential(x, y, true);\n}
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	59	59	add goal or obstacle
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	63	63	add was successful
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	99	99	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	104	104	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	111	111	new value is not valid
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	116	116	Reset all potentials to 0 before recalculating
3f648950	f24	p0	2024-09-23 09:22:23	field.cpp	133	133	Successfully updated
3f648950	f24	p0	2024-09-23 09:22:23	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-23 09:22:23	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-23 09:22:23	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-23 09:22:23	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-23 09:22:23	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	44	44	Map not yet created
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	48	48	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	52	52	Map not yet created
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	59	59	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	63	63	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	66	66	Map not yet created
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	70	70	End of input
3f648950	f24	p0	2024-09-23 09:22:23	main.cpp	74	74	Clean up the dynamically allocated memory if needed
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	47	47	checks if position is valid
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	49	49	position is out of bounds
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	52	57	if(grid[x][y].getContent() == 'G'){ // Resets value if there is a goal in the cell\ncomputePotential(x, y, false);\n}\nelse if(grid[x][y].getContent() == 'O'){ // Resets value if there is a\ncomputePotential(x, y, true);\n}
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	59	59	add goal or obstacle
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	63	63	add was successful
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	99	99	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	104	104	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	111	111	new value is not valid
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	116	116	Reset all potentials to 0 before recalculating
3f648950	f24	p0	2024-09-23 09:24:46	field.cpp	133	133	Successfully updated
3f648950	f24	p0	2024-09-23 09:24:46	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-23 09:24:46	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-23 09:24:46	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-23 09:24:46	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-23 09:24:46	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	44	44	Map not yet created
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	48	48	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	52	52	Map not yet created
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	59	59	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	63	63	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	66	66	Map not yet created
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	70	70	End of input
3f648950	f24	p0	2024-09-23 09:24:46	main.cpp	74	74	Clean up the dynamically allocated memory if needed
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	47	47	checks if position is valid
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	49	49	position is out of bounds
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	52	57	if(grid[x][y].getContent() == 'G'){ // Resets value if there is a goal in the cell\ncomputePotential(x, y, false);\n}\nelse if(grid[x][y].getContent() == 'O'){ // Resets value if there is a\ncomputePotential(x, y, true);\n}
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	59	59	add goal or obstacle
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	63	63	add was successful
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	99	99	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	104	104	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	111	111	new value is not valid
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	116	116	Reset all potentials to 0 before recalculating
3f648950	f24	p0	2024-09-23 09:24:54	field.cpp	133	133	Successfully updated
3f648950	f24	p0	2024-09-23 09:24:54	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-23 09:24:54	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-23 09:24:54	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-23 09:24:54	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-23 09:24:54	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	44	44	Map not yet created
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	48	48	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	52	52	Map not yet created
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	59	59	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	63	63	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	66	66	Map not yet created
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	70	70	End of input
3f648950	f24	p0	2024-09-23 09:24:54	main.cpp	74	74	Clean up the dynamically allocated memory if needed
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	48	48	checks if position is valid
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	50	50	position is out of bounds
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	53	58	if(grid[x][y].getContent() == 'G'){ // Resets value if there is a goal in the cell\ncomputePotential(x, y, false);\n}\nelse if(grid[x][y].getContent() == 'O'){ // Resets value if there is a\ncomputePotential(x, y, true);\n}
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	60	60	add goal or obstacle
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	64	64	add was successful
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	100	100	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	105	105	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	112	112	new value is not valid
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	117	117	Reset all potentials to 0 before recalculating
3f648950	f24	p0	2024-09-23 09:36:48	field.cpp	134	134	Successfully updated
3f648950	f24	p0	2024-09-23 09:36:48	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-23 09:36:48	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-23 09:36:48	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-23 09:36:48	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-23 09:36:48	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	44	44	Map not yet created
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	48	48	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	52	52	Map not yet created
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	59	59	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	63	63	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	66	66	Map not yet created
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	70	70	End of input
3f648950	f24	p0	2024-09-23 09:36:48	main.cpp	74	74	Clean up the dynamically allocated memory if needed
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	48	48	checks if position is valid
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	50	50	position is out of bounds
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	53	58	if(grid[x][y].getContent() == 'G'){ // Resets value if there is a goal in the cell\ncomputePotential(x, y, false);\n}\nelse if(grid[x][y].getContent() == 'O'){ // Resets value if there is a\ncomputePotential(x, y, true);\n}
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	60	60	add goal or obstacle
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	64	64	add was successful
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	100	100	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	105	105	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	112	112	new value is not valid
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	117	117	Reset all potentials to 0 before recalculating
3f648950	f24	p0	2024-09-23 09:38:24	field.cpp	134	134	Successfully updated
3f648950	f24	p0	2024-09-23 09:38:24	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-23 09:38:24	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-23 09:38:24	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-23 09:38:24	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-23 09:38:24	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	44	44	Map not yet created
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	48	48	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	52	52	Map not yet created
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	59	59	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	63	63	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	66	66	Map not yet created
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	70	70	End of input
3f648950	f24	p0	2024-09-23 09:38:24	main.cpp	74	74	Clean up the dynamically allocated memory if needed
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	48	48	checks if position is valid
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	50	50	position is out of bounds
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	53	58	if(grid[x][y].getContent() == 'G'){ // Resets value if there is a goal in the cell\ncomputePotential(x, y, false);\n}\nelse if(grid[x][y].getContent() == 'O'){ // Resets value if there is a\ncomputePotential(x, y, true);\n}
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	60	60	add goal or obstacle
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	64	64	add was successful
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	100	100	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	105	105	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	112	112	new value is not valid
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	117	117	Reset all potentials to 0 before recalculating
3f648950	f24	p0	2024-09-23 09:40:17	field.cpp	134	134	Successfully updated
3f648950	f24	p0	2024-09-23 09:40:17	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-23 09:40:17	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-23 09:40:17	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-23 09:40:17	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-23 09:40:17	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	44	44	Map not yet created
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	48	48	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	52	52	Map not yet created
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	59	59	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	63	63	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	66	66	Map not yet created
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	70	70	End of input
3f648950	f24	p0	2024-09-23 09:40:17	main.cpp	74	74	Clean up the dynamically allocated memory if needed
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	48	48	checks if position is valid
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	50	50	position is out of bounds
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	53	53	Resets value if there is a goal in the cell
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	56	56	Resets value if there is a
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	60	60	add goal or obstacle
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	64	64	add was successful
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	100	100	Function to clear the map and reset all cells
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	105	105	Set content to 'N' (nothing)
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	112	112	new value is not valid
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	117	117	Reset all potentials to 0 before recalculating
3f648950	f24	p0	2024-09-23 09:41:00	field.cpp	134	134	Successfully updated
3f648950	f24	p0	2024-09-23 09:41:00	field.hpp	16	17	X and Y value of potential\n'G' for goal, 'O' for obstacle, 'N' for nothing
3f648950	f24	p0	2024-09-23 09:41:00	field.hpp	25	27	dimensions\nconstant\narray to hold X values
3f648950	f24	p0	2024-09-23 09:41:00	field.hpp	37	37	constructor
3f648950	f24	p0	2024-09-23 09:41:00	field.hpp	39	39	destreuctor
3f648950	f24	p0	2024-09-23 09:41:00	field.hpp	45	45	resets map to default
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	6	7	Pointer to the potential field\nTo store the input commands
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	16	16	If a map already exists, delete it
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	18	18	Create a new map of size N x M
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	27	27	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	31	31	Insertion failed (e.g., out of bounds)
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	34	34	Map not yet created
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	41	41	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	44	44	Map not yet created
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	48	48	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	52	52	Map not yet created
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	59	59	Make sure the map exists
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	63	63	Invalid K value (e.g., K <= 0)
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	66	66	Map not yet created
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	70	70	End of input
3f648950	f24	p0	2024-09-23 09:41:00	main.cpp	74	74	Clean up the dynamically allocated memory if needed
409b9c1d	f24	p0	2024-09-23 15:11:36	Grid.cpp	31	31	Deallocate potentials array
409b9c1d	f24	p0	2024-09-23 15:11:36	Grid.cpp	34	34	Deallocate objects
409b9c1d	f24	p0	2024-09-23 15:11:36	Grid.cpp	67	67	Clear  potentials
409b9c1d	f24	p0	2024-09-23 15:11:36	Grid.h	33	33	GRID_H
409b9c1d	f24	p0	2024-09-23 15:15:33	Grid.cpp	31	31	Deallocate potentials array
409b9c1d	f24	p0	2024-09-23 15:15:33	Grid.cpp	34	34	Deallocate objects
409b9c1d	f24	p0	2024-09-23 15:15:33	Grid.cpp	67	67	Clear  potentials
409b9c1d	f24	p0	2024-09-23 15:15:33	Grid.h	33	33	GRID_H
409b9c1d	f24	p0	2024-09-23 15:19:02	Grid.cpp	31	31	Deallocate potentials array
409b9c1d	f24	p0	2024-09-23 15:19:02	Grid.cpp	34	34	Deallocate objects
409b9c1d	f24	p0	2024-09-23 15:19:02	Grid.cpp	67	67	Clear  potentials
409b9c1d	f24	p0	2024-09-23 15:19:02	Grid.h	33	33	GRID_H
409b9c1d	f24	p0	2024-09-23 18:35:11	Grid.cpp	31	31	Deallocate potentials array
409b9c1d	f24	p0	2024-09-23 18:35:11	Grid.cpp	34	34	Deallocate objects
409b9c1d	f24	p0	2024-09-23 18:35:11	Grid.cpp	67	67	Clear  potentials
409b9c1d	f24	p0	2024-09-23 18:35:11	Grid.h	33	33	GRID_H
409b9c1d	f24	p0	2024-09-23 18:59:00	Grid.cpp	31	31	Deallocate potentials array
409b9c1d	f24	p0	2024-09-23 18:59:00	Grid.cpp	34	34	Deallocate objects
409b9c1d	f24	p0	2024-09-23 18:59:00	Grid.cpp	67	67	Clear  potentials
409b9c1d	f24	p0	2024-09-23 18:59:00	Grid.h	33	33	GRID_H
409b9c1d	f24	p0	2024-09-23 19:15:51	Grid.cpp	31	31	Deallocate potentials array
409b9c1d	f24	p0	2024-09-23 19:15:51	Grid.cpp	34	34	Deallocate objects
409b9c1d	f24	p0	2024-09-23 19:15:51	Grid.cpp	74	74	Object is already present, do nothing
409b9c1d	f24	p0	2024-09-23 19:15:51	Grid.cpp	79	79	No object preset, update and calculate potential impact
409b9c1d	f24	p0	2024-09-23 19:15:51	Grid.cpp	85	85	Different object present
409b9c1d	f24	p0	2024-09-23 19:15:51	Grid.cpp	96	96	Clear  potentials
409b9c1d	f24	p0	2024-09-23 19:15:51	Grid.h	34	34	GRID_H
409b9c1d	f24	p0	2024-09-23 19:21:34	Grid.cpp	31	31	Deallocate potentials array
409b9c1d	f24	p0	2024-09-23 19:21:34	Grid.cpp	34	34	Deallocate objects
409b9c1d	f24	p0	2024-09-23 19:21:34	Grid.cpp	74	74	Object is already present, do nothing
409b9c1d	f24	p0	2024-09-23 19:21:34	Grid.cpp	79	79	No object preset, update and calculate potential impact
409b9c1d	f24	p0	2024-09-23 19:21:34	Grid.cpp	85	85	Different object present
409b9c1d	f24	p0	2024-09-23 19:21:34	Grid.cpp	96	96	Clear  potentials
409b9c1d	f24	p0	2024-09-23 19:21:34	Grid.h	34	34	GRID_H
409b9c1d	f24	p0	2024-09-23 19:27:30	Grid.cpp	31	31	Deallocate potentials array
409b9c1d	f24	p0	2024-09-23 19:27:30	Grid.cpp	34	34	Deallocate objects
409b9c1d	f24	p0	2024-09-23 19:27:30	Grid.cpp	74	74	Object is already present, do nothing
409b9c1d	f24	p0	2024-09-23 19:27:30	Grid.cpp	79	79	No object preset, update and calculate potential impact
409b9c1d	f24	p0	2024-09-23 19:27:30	Grid.cpp	85	85	Different object present
409b9c1d	f24	p0	2024-09-23 19:27:30	Grid.cpp	96	96	Clear  potentials
409b9c1d	f24	p0	2024-09-23 19:27:30	Grid.h	34	34	GRID_H
4609f88b	f24	p0	2024-09-20 20:18:27	field.cpp	6	6	Initialize otherField so there is no deletion when the first Field is created
4609f88b	f24	p0	2024-09-20 20:18:27	field.cpp	88	88	Set otherField to current object for future reference
4609f88b	f24	p0	2024-09-22 17:22:59	field.cpp	6	6	Initialize otherField so there is no deletion when the first Field is created
4609f88b	f24	p0	2024-09-22 17:22:59	field.cpp	14	14	Populate array with pointers to "Potential" objects
4609f88b	f24	p0	2024-09-22 17:22:59	field.cpp	17	17	Populate each subarray with "Potential" objects
4609f88b	f24	p0	2024-09-22 17:22:59	field.cpp	27	27	Deallocate each subarray
4609f88b	f24	p0	2024-09-22 17:22:59	field.cpp	36	36	Deallocate main array and reset member variables
4609f88b	f24	p0	2024-09-22 17:22:59	field.cpp	80	80	Set otherField to current object for future reference
4609f88b	f24	p0	2024-09-22 17:22:59	main.cpp	7	8	Instantiate field pointer that will be used\nSet to nullptr so that only CREATE will work first
4609f88b	f24	p0	2024-09-22 22:07:52	field.cpp	6	6	Initialize otherField so there is no deletion when the first Field is created
4609f88b	f24	p0	2024-09-22 22:07:52	field.cpp	14	14	Populate array with pointers to "Potential" objects
4609f88b	f24	p0	2024-09-22 22:07:52	field.cpp	17	17	Populate each subarray with "Potential" objects
4609f88b	f24	p0	2024-09-22 22:07:52	field.cpp	27	27	Deallocate each subarray
4609f88b	f24	p0	2024-09-22 22:07:52	field.cpp	36	36	Deallocate main array and reset member variables
4609f88b	f24	p0	2024-09-22 22:07:52	field.cpp	80	80	Set otherField to current object for future reference
4609f88b	f24	p0	2024-09-22 22:07:52	main.cpp	7	8	Instantiate field pointer that will be used\nSet to nullptr so that only CREATE will work first
470bc3d5	f24	p0	2024-09-22 12:23:32	myGrid.cpp	5	5	construct object myGrid and initialize 2d array based on user input
470bc3d5	f24	p0	2024-09-22 12:23:32	myGrid.cpp	84	84	defining getter functions
470bc3d5	f24	p0	2024-09-22 12:23:32	myGrid.hpp	17	17	helper functions
470bc3d5	f24	p0	2024-09-22 12:23:32	myGrid.hpp	20	20	assigned functions
470bc3d5	f24	p0	2024-09-22 12:23:32	myPoint.cpp	5	5	defining variables
470bc3d5	f24	p0	2024-09-22 12:23:32	myPoint.cpp	14	14	defining getter functions
470bc3d5	f24	p0	2024-09-22 12:23:32	myPoint.cpp	20	20	defining setter functions
470bc3d5	f24	p0	2024-09-22 12:23:32	myPoint.hpp	6	6	constructor
470bc3d5	f24	p0	2024-09-22 12:23:32	myPoint.hpp	9	9	defining variables
470bc3d5	f24	p0	2024-09-22 12:23:32	myPoint.hpp	15	15	defining getter functions
470bc3d5	f24	p0	2024-09-22 12:23:32	myPoint.hpp	21	21	defining setter functions
470bc3d5	f24	p0	2024-09-22 12:23:32	myPoint.hpp	26	26	helper functions
470bc3d5	f24	p0	2024-09-22 12:29:06	myGrid.cpp	5	5	construct object myGrid and initialize 2d array based on user input
470bc3d5	f24	p0	2024-09-22 12:29:06	myGrid.cpp	84	84	defining getter functions
470bc3d5	f24	p0	2024-09-22 12:29:06	myGrid.hpp	17	17	helper functions
470bc3d5	f24	p0	2024-09-22 12:29:06	myGrid.hpp	20	20	assigned functions
470bc3d5	f24	p0	2024-09-22 12:29:06	myPoint.cpp	5	5	defining variables
470bc3d5	f24	p0	2024-09-22 12:29:06	myPoint.cpp	14	14	defining getter functions
470bc3d5	f24	p0	2024-09-22 12:29:06	myPoint.cpp	20	20	defining setter functions
470bc3d5	f24	p0	2024-09-22 12:29:06	myPoint.hpp	6	6	constructor
470bc3d5	f24	p0	2024-09-22 12:29:06	myPoint.hpp	9	9	defining variables
470bc3d5	f24	p0	2024-09-22 12:29:06	myPoint.hpp	15	15	defining getter functions
470bc3d5	f24	p0	2024-09-22 12:29:06	myPoint.hpp	21	21	defining setter functions
470bc3d5	f24	p0	2024-09-22 12:29:06	myPoint.hpp	26	26	helper functions
470bc3d5	f24	p0	2024-09-22 17:20:23	myGrid.cpp	5	5	construct object myGrid and initialize 2d array based on user input
470bc3d5	f24	p0	2024-09-22 17:20:23	myGrid.cpp	84	84	defining getter functions
470bc3d5	f24	p0	2024-09-22 17:20:23	myGrid.hpp	17	17	helper functions
470bc3d5	f24	p0	2024-09-22 17:20:23	myGrid.hpp	20	20	assigned functions
470bc3d5	f24	p0	2024-09-22 17:20:23	myPoint.cpp	5	5	defining variables
470bc3d5	f24	p0	2024-09-22 17:20:23	myPoint.cpp	14	14	defining getter functions
470bc3d5	f24	p0	2024-09-22 17:20:23	myPoint.cpp	20	20	defining setter functions
470bc3d5	f24	p0	2024-09-22 17:20:23	myPoint.hpp	6	6	constructor
470bc3d5	f24	p0	2024-09-22 17:20:23	myPoint.hpp	9	9	defining variables
470bc3d5	f24	p0	2024-09-22 17:20:23	myPoint.hpp	15	15	defining getter functions
470bc3d5	f24	p0	2024-09-22 17:20:23	myPoint.hpp	21	21	defining setter functions
470bc3d5	f24	p0	2024-09-22 17:20:23	myPoint.hpp	26	26	helper functions
470bc3d5	f24	p0	2024-09-22 17:25:05	myGrid.cpp	5	5	construct object myGrid and initialize 2d array based on user input
470bc3d5	f24	p0	2024-09-22 17:25:05	myGrid.cpp	84	84	defining getter functions
470bc3d5	f24	p0	2024-09-22 17:25:05	myGrid.hpp	17	17	helper functions
470bc3d5	f24	p0	2024-09-22 17:25:05	myGrid.hpp	20	20	assigned functions
470bc3d5	f24	p0	2024-09-22 17:25:05	myPoint.cpp	5	5	defining variables
470bc3d5	f24	p0	2024-09-22 17:25:05	myPoint.cpp	14	14	defining getter functions
470bc3d5	f24	p0	2024-09-22 17:25:05	myPoint.cpp	20	20	defining setter functions
470bc3d5	f24	p0	2024-09-22 17:25:05	myPoint.hpp	6	6	constructor
470bc3d5	f24	p0	2024-09-22 17:25:05	myPoint.hpp	9	9	defining variables
470bc3d5	f24	p0	2024-09-22 17:25:05	myPoint.hpp	15	15	defining getter functions
470bc3d5	f24	p0	2024-09-22 17:25:05	myPoint.hpp	21	21	defining setter functions
470bc3d5	f24	p0	2024-09-22 17:25:05	myPoint.hpp	26	26	helper functions
470bc3d5	f24	p0	2024-09-22 17:27:57	myGrid.cpp	5	5	construct object myGrid and initialize 2d array based on user input
470bc3d5	f24	p0	2024-09-22 17:27:57	myGrid.cpp	84	84	defining helper functions
470bc3d5	f24	p0	2024-09-22 17:27:57	myGrid.hpp	18	18	helper functions
470bc3d5	f24	p0	2024-09-22 17:27:57	myGrid.hpp	21	21	assigned functions
470bc3d5	f24	p0	2024-09-22 17:27:57	myPoint.cpp	5	5	defining variables
470bc3d5	f24	p0	2024-09-22 17:27:57	myPoint.cpp	14	14	defining getter functions
470bc3d5	f24	p0	2024-09-22 17:27:57	myPoint.cpp	20	20	defining setter functions
470bc3d5	f24	p0	2024-09-22 17:27:57	myPoint.hpp	6	6	constructor
470bc3d5	f24	p0	2024-09-22 17:27:57	myPoint.hpp	9	9	defining variables
470bc3d5	f24	p0	2024-09-22 17:27:57	myPoint.hpp	15	15	defining getter functions
470bc3d5	f24	p0	2024-09-22 17:27:57	myPoint.hpp	21	21	defining setter functions
470bc3d5	f24	p0	2024-09-22 17:27:57	myPoint.hpp	26	26	helper functions
470bc3d5	f24	p0	2024-09-23 11:21:59	myGrid.cpp	5	5	construct object myGrid and initialize 2d array based on user input
470bc3d5	f24	p0	2024-09-23 11:21:59	myGrid.cpp	84	84	defining helper functions
470bc3d5	f24	p0	2024-09-23 11:21:59	myGrid.hpp	16	16	helper functions
470bc3d5	f24	p0	2024-09-23 11:21:59	myGrid.hpp	19	19	assigned functions
470bc3d5	f24	p0	2024-09-23 11:21:59	myPoint.cpp	5	5	defining variables
470bc3d5	f24	p0	2024-09-23 11:21:59	myPoint.cpp	14	14	defining getter functions
470bc3d5	f24	p0	2024-09-23 11:21:59	myPoint.cpp	20	20	defining setter functions
470bc3d5	f24	p0	2024-09-23 11:21:59	myPoint.hpp	6	6	constructor
470bc3d5	f24	p0	2024-09-23 11:21:59	myPoint.hpp	9	9	defining variables
470bc3d5	f24	p0	2024-09-23 11:21:59	myPoint.hpp	15	15	defining getter functions
470bc3d5	f24	p0	2024-09-23 11:21:59	myPoint.hpp	21	21	defining setter functions
470bc3d5	f24	p0	2024-09-23 11:21:59	myPoint.hpp	26	26	helper functions
470bc3d5	f24	p0	2024-09-23 11:28:01	myGrid.cpp	5	5	construct object myGrid and initialize 2d array based on user input
470bc3d5	f24	p0	2024-09-23 11:28:01	myGrid.cpp	84	84	defining helper functions
470bc3d5	f24	p0	2024-09-23 11:28:01	myGrid.hpp	16	16	helper functions
470bc3d5	f24	p0	2024-09-23 11:28:01	myGrid.hpp	19	19	assigned functions
470bc3d5	f24	p0	2024-09-23 11:28:01	myPoint.cpp	5	5	defining variables
470bc3d5	f24	p0	2024-09-23 11:28:01	myPoint.cpp	14	14	defining getter functions
470bc3d5	f24	p0	2024-09-23 11:28:01	myPoint.cpp	20	20	defining setter functions
470bc3d5	f24	p0	2024-09-23 11:28:01	myPoint.hpp	6	6	constructor
470bc3d5	f24	p0	2024-09-23 11:28:01	myPoint.hpp	9	9	defining variables
470bc3d5	f24	p0	2024-09-23 11:28:01	myPoint.hpp	15	15	defining getter functions
470bc3d5	f24	p0	2024-09-23 11:28:01	myPoint.hpp	21	21	defining setter functions
470bc3d5	f24	p0	2024-09-23 11:28:01	myPoint.hpp	26	26	helper functions
4c675185	f24	p0	2024-09-20 20:07:44	Grid.cpp	8	9	Constructor\n
4c675185	f24	p0	2024-09-20 20:07:44	Grid.cpp	79	79	Calc(X, Y);
4c675185	f24	p0	2024-09-20 20:07:44	Grid.cpp	127	131	void Grid::Print()\n{\nstd::cout << length_x << std::endl;\nstd::cout << length_y << std::endl;\nstd::cout << K << std::endl;
4c675185	f24	p0	2024-09-20 20:07:44	Grid.cpp	133	143	for (int i = 0; i < length_x; i++)\n{\nfor (int j = 0; j < length_y; j++)\n{\nCalc(i, j);\nstd::cout << i << ", " << j << ", " << a_a_locs[i][j].getPx() << ", " << a_a_locs[i][j].getPy() << ", " << a_a_locs[i][j].object << std::endl;\n}\n}\n}\nDestructor\n
4c675185	f24	p0	2024-09-20 20:07:44	Grid.hpp	18	18	void Print();
4c675185	f24	p0	2024-09-20 20:07:44	main.cpp	54	57	else if (command == "s")\n{\ngrid.Print();\n}
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	8	8	Constructor
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	11	11	Initialize the dimensions to 0 and the 2D array to null
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	17	17	Create method
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	20	20	Deallocate the 2D array if it has been created before
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	31	31	Set the new dimensions of the 2D array
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	35	35	Allocate the X dimension of the 2D array
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	38	38	Allocate the Y dimension of the 2D array
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	43	43	For every element in the array, create an instance of Loc
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	50	50	Set the factor to 1 and print out success
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	56	56	Point method
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	59	59	Create a point only if location is in the bounds of array
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	62	62	Store the previous object at the location and the magnitude
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	66	66	Set the new object
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	69	69	Update the potential for all locations except where the point is placed
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	76	76	Calculate the magnitude of potential (same for both x and y directions and same magnitude for both goal and obstacle)
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	79	80	If the previous object was a goal/obstacle, respectively add/subtract back the magnitude\nso the contribution due to the point from before the point update is zero (superposition principle)
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	90	90	Add the negative/positive magnitude if point is updated to goal/obstacle respectively
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	103	103	Print out success
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	109	109	Print out failure
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	115	115	Move method
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	118	118	Print out failure if the location is outside the 2D array's dimensions
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	125	125	Print out the x and y potential (they are always equal)
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	129	129	Clear method
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	132	132	Print out failure if the 2D array has not been created
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	139	139	For every location in the grid, clear the potentials and set the goal/obstacle to nothing
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	149	149	Print out success
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	155	155	Only update the K factor only if it's greater than 0
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	158	158	Store the old factor and set the new factor
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	162	162	Change the potential multiplier for every location in the grid
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	171	171	Print out success
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	177	177	Print out failure
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	183	183	Destructor method
4c675185	f24	p0	2024-09-22 22:39:53	Grid.cpp	186	186	Only deallocate the 2D array and set its pointer to NULL if it has been allocated before
4c675185	f24	p0	2024-09-22 22:39:53	Loc.cpp	6	6	Constructor
4c675185	f24	p0	2024-09-22 22:39:53	Loc.cpp	9	9	Initialize the potential and object
4c675185	f24	p0	2024-09-22 22:39:53	Loc.cpp	14	14	Getter for potential (same value for both x and y potentials)
4c675185	f24	p0	2024-09-22 22:39:53	Loc.cpp	20	20	Add potential method. This allows superposition to be used to update the x and y potential
4c675185	f24	p0	2024-09-22 22:39:53	Loc.cpp	26	26	Change potential multiplier constant method
4c675185	f24	p0	2024-09-22 22:39:53	Loc.cpp	29	29	This changes the potential by multiplying the potential by the new multiplier and dividing by an old multiplier
4c675185	f24	p0	2024-09-22 22:39:53	Loc.cpp	33	33	Clear potential method
4c675185	f24	p0	2024-09-22 22:39:53	main.cpp	8	8	Store an instance of the grid, the command, the input values, and the running state
4c675185	f24	p0	2024-09-22 22:39:53	main.cpp	19	19	Parse the input command
4c675185	f24	p0	2024-09-22 22:39:53	main.cpp	24	24	Call the create method
4c675185	f24	p0	2024-09-22 22:39:53	main.cpp	31	31	Call the point method
4c675185	f24	p0	2024-09-22 22:39:53	main.cpp	39	39	Call the move method
4c675185	f24	p0	2024-09-22 22:39:53	main.cpp	46	46	Call the clear method
4c675185	f24	p0	2024-09-22 22:39:53	main.cpp	51	51	Call the update method
4c675185	f24	p0	2024-09-22 22:39:53	main.cpp	57	57	Deallocate the grid and stop the running loop
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	8	8	Constructor
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	11	11	Initialize the dimensions to 0 and the 2D array to null
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	17	17	Create method
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	20	20	Deallocate the 2D array if it has been created before
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	31	31	Set the new dimensions of the 2D array
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	35	35	Allocate the X dimension of the 2D array
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	38	38	Allocate the Y dimension of the 2D array
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	43	43	For every element in the array, create an instance of Loc
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	50	50	Set the factor to 1 and print out success
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	56	56	Point method
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	59	59	Create a point only if location is in the bounds of array
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	62	62	Store the previous object at the location and the magnitude
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	66	66	Set the new object
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	69	69	Update the potential for all locations except where the point is placed
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	76	76	Calculate the magnitude of potential (same for both x and y directions and same magnitude for both goal and obstacle)
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	79	80	If the previous object was a goal/obstacle, respectively add/subtract back the magnitude\nso the contribution due to the point from before the point update is zero (superposition principle)
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	90	90	Add the negative/positive magnitude if point is updated to goal/obstacle respectively
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	103	103	Print out success
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	109	109	Print out failure
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	115	115	Move method
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	118	118	Print out failure if the location is outside the 2D array's dimensions
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	125	125	Print out the x and y potential (they are always equal)
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	129	129	Clear method
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	132	132	Print out failure if the 2D array has not been created
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	139	139	For every location in the grid, clear the potentials and set the goal/obstacle to nothing
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	149	149	Print out success
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	155	155	Only update the K factor only if it's greater than 0
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	158	158	Store the old factor and set the new factor
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	162	162	Change the potential multiplier for every location in the grid
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	171	171	Print out success
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	177	177	Print out failure
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	183	183	Destructor method
4c675185	f24	p0	2024-09-23 20:59:16	Grid.cpp	186	186	Only deallocate the 2D array and set its pointer to NULL if it has been allocated before
4c675185	f24	p0	2024-09-23 20:59:16	Loc.cpp	6	6	Constructor
4c675185	f24	p0	2024-09-23 20:59:16	Loc.cpp	9	9	Initialize the potential and object
4c675185	f24	p0	2024-09-23 20:59:16	Loc.cpp	14	14	Getter for potential (same value for both x and y potentials)
4c675185	f24	p0	2024-09-23 20:59:16	Loc.cpp	20	20	Add potential method. This allows superposition to be used to update the x and y potential
4c675185	f24	p0	2024-09-23 20:59:16	Loc.cpp	26	26	Change potential multiplier constant method
4c675185	f24	p0	2024-09-23 20:59:16	Loc.cpp	29	29	This changes the potential by multiplying the potential by the new multiplier and dividing by an old multiplier
4c675185	f24	p0	2024-09-23 20:59:16	Loc.cpp	33	33	Clear potential method
4c675185	f24	p0	2024-09-23 20:59:16	main.cpp	8	8	Store an instance of the grid, the command, the input values, and the running state
4c675185	f24	p0	2024-09-23 20:59:16	main.cpp	21	21	Parse the input command
4c675185	f24	p0	2024-09-23 20:59:16	main.cpp	26	26	Call the create method
4c675185	f24	p0	2024-09-23 20:59:16	main.cpp	33	33	Call the point method
4c675185	f24	p0	2024-09-23 20:59:16	main.cpp	41	41	Call the move method
4c675185	f24	p0	2024-09-23 20:59:16	main.cpp	48	48	Call the clear method
4c675185	f24	p0	2024-09-23 20:59:16	main.cpp	53	53	Call the update method
4c675185	f24	p0	2024-09-23 20:59:16	main.cpp	59	59	Deallocate the grid and stop the running loop
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	8	8	Constructor
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	11	11	Initialize the dimensions to 0 and the 2D array to null
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	17	17	Create method
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	20	20	Deallocate the 2D array if it has been created before
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	31	31	Set the new dimensions of the 2D array
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	35	35	Allocate the X dimension of the 2D array
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	38	38	Allocate the Y dimension of the 2D array
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	43	43	For every element in the array, create an instance of Loc
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	50	50	Set the factor to 1 and print out success
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	56	56	Point method
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	59	59	Create a point only if location is in the bounds of array
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	62	62	Store the previous object at the location and the magnitude
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	66	66	Set the new object
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	69	69	Update the potential for all locations except where the point is placed
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	76	76	Calculate the magnitude of potential (same for both x and y directions and same magnitude for both goal and obstacle)
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	79	80	If the previous object was a goal/obstacle, respectively add/subtract back the magnitude\nso the contribution due to the point from before the point update is zero (superposition principle)
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	90	90	Add the negative/positive magnitude if point is updated to goal/obstacle respectively
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	103	103	Print out success
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	109	109	Print out failure
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	115	115	Move method
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	118	118	Print out failure if the location is outside the 2D array's dimensions
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	125	125	Print out the x and y potential (they are always equal)
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	129	129	Clear method
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	132	132	Print out failure if the 2D array has not been created
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	139	139	For every location in the grid, clear the potentials and set the goal/obstacle to nothing
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	149	149	Print out success
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	155	155	Only update the K factor only if it's greater than 0
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	158	158	Store the old factor and set the new factor
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	162	162	Change the potential multiplier for every location in the grid
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	171	171	Print out success
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	177	177	Print out failure
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	183	183	Destructor method
4c675185	f24	p0	2024-10-02 09:13:42	Grid.cpp	186	186	Only deallocate the 2D array and set its pointer to NULL if it has been allocated before
4c675185	f24	p0	2024-10-02 09:13:42	Loc.cpp	6	6	Constructor
4c675185	f24	p0	2024-10-02 09:13:42	Loc.cpp	9	9	Initialize the potential and object
4c675185	f24	p0	2024-10-02 09:13:42	Loc.cpp	14	14	Getter for potential (same value for both x and y potentials)
4c675185	f24	p0	2024-10-02 09:13:42	Loc.cpp	20	20	Add potential method. This allows superposition to be used to update the x and y potential
4c675185	f24	p0	2024-10-02 09:13:42	Loc.cpp	26	26	Change potential multiplier constant method
4c675185	f24	p0	2024-10-02 09:13:42	Loc.cpp	29	29	This changes the potential by multiplying the potential by the new multiplier and dividing by an old multiplier
4c675185	f24	p0	2024-10-02 09:13:42	Loc.cpp	33	33	Clear potential method
4c675185	f24	p0	2024-10-02 09:13:42	main.cpp	8	8	Store an instance of the grid, the command, the input values, and the running state
4c675185	f24	p0	2024-10-02 09:13:42	main.cpp	21	21	Parse the input command
4c675185	f24	p0	2024-10-02 09:13:42	main.cpp	26	26	Call the create method
4c675185	f24	p0	2024-10-02 09:13:42	main.cpp	33	33	Call the point method
4c675185	f24	p0	2024-10-02 09:13:42	main.cpp	41	41	Call the move method
4c675185	f24	p0	2024-10-02 09:13:42	main.cpp	48	48	Call the clear method
4c675185	f24	p0	2024-10-02 09:13:42	main.cpp	53	53	Call the update method
4c675185	f24	p0	2024-10-02 09:13:42	main.cpp	59	59	Deallocate the grid and stop the running loop
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	8	8	Constructor
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	11	11	Initialize the dimensions to 0 and the 2D array to null
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	17	17	Create method
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	20	20	Deallocate the 2D array if it has been created before
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	31	31	Set the new dimensions of the 2D array
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	35	35	Allocate the X dimension of the 2D array
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	38	38	Allocate the Y dimension of the 2D array
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	43	43	For every element in the array, create an instance of Loc
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	50	50	Set the factor to 1 and print out success
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	56	56	Point method
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	59	59	Create a point only if location is in the bounds of array
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	62	62	Store the previous object at the location and the magnitude
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	66	66	Set the new object
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	69	69	Update the potential for all locations except where the point is placed
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	76	76	Calculate the magnitude of potential (same for both x and y directions and same magnitude for both goal and obstacle)
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	79	80	If the previous object was a goal/obstacle, respectively add/subtract back the magnitude\nso the contribution due to the point from before the point update is zero (superposition principle)
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	90	90	Add the negative/positive magnitude if point is updated to goal/obstacle respectively
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	103	103	Print out success
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	109	109	Print out failure
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	115	115	Move method
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	118	118	Print out failure if the location is outside the 2D array's dimensions
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	125	125	Print out the x and y potential (they are always equal)
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	129	129	Clear method
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	132	132	Print out failure if the 2D array has not been created
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	139	139	For every location in the grid, clear the potentials and set the goal/obstacle to nothing
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	149	149	Print out success
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	155	155	Only update the K factor only if it's greater than 0
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	158	158	Store the old factor and set the new factor
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	162	162	Change the potential multiplier for every location in the grid
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	171	171	Print out success
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	177	177	Print out failure
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	183	183	Destructor method
4c675185	f24	p0	2024-10-02 11:40:52	Grid.cpp	186	186	Only deallocate the 2D array and set its pointer to NULL if it has been allocated before
4c675185	f24	p0	2024-10-02 11:40:52	Loc.cpp	6	6	Constructor
4c675185	f24	p0	2024-10-02 11:40:52	Loc.cpp	9	9	Initialize the potential and object
4c675185	f24	p0	2024-10-02 11:40:52	Loc.cpp	14	14	Getter for potential (same value for both x and y potentials)
4c675185	f24	p0	2024-10-02 11:40:52	Loc.cpp	20	20	Add potential method. This allows superposition to be used to update the x and y potential
4c675185	f24	p0	2024-10-02 11:40:52	Loc.cpp	26	26	Change potential multiplier constant method
4c675185	f24	p0	2024-10-02 11:40:52	Loc.cpp	29	29	This changes the potential by multiplying the potential by the new multiplier and dividing by an old multiplier
4c675185	f24	p0	2024-10-02 11:40:52	Loc.cpp	33	33	Clear potential method
4c675185	f24	p0	2024-10-02 11:40:52	main.cpp	8	8	Store an instance of the grid, the command, the input values, and the running state
4c675185	f24	p0	2024-10-02 11:40:52	main.cpp	21	21	Parse the input command
4c675185	f24	p0	2024-10-02 11:40:52	main.cpp	26	26	Call the create method
4c675185	f24	p0	2024-10-02 11:40:52	main.cpp	33	33	Call the point method
4c675185	f24	p0	2024-10-02 11:40:52	main.cpp	41	41	Call the move method
4c675185	f24	p0	2024-10-02 11:40:52	main.cpp	48	48	Call the clear method
4c675185	f24	p0	2024-10-02 11:40:52	main.cpp	53	53	Call the update method
4c675185	f24	p0	2024-10-02 11:40:52	main.cpp	59	59	Deallocate the grid and stop the running loop
4c675185	f24	p0	2024-10-03 12:03:59	Core.cpp	6	6	Constructor
4c675185	f24	p0	2024-10-03 12:03:59	Core.cpp	9	9	Initialize the potential and object
4c675185	f24	p0	2024-10-03 12:03:59	Core.cpp	16	16	Destructor
4c675185	f24	p0	2024-10-03 12:03:59	Core.cpp	132	132	std::cout << "resize: ";
4c675185	f24	p0	2024-10-03 12:03:59	Core.cpp	141	141	std::cout << queue[cur] << ", ";
4c675185	f24	p0	2024-10-03 12:03:59	Core.cpp	147	147	std::cout << "rear" << rear << std::endl;
4c675185	f24	p0	2024-10-03 12:03:59	Core.cpp	160	160	std::cout << "resize: ";
4c675185	f24	p0	2024-10-03 12:03:59	Core.cpp	168	168	std::cout << queue[cur] << ", ";
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	6	6	Constructor
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	9	9	Initialize the cpu
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	16	16	Getter for potential (same value for both x and y potentials)
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	51	51	Add potential method. This allows superposition to be used to update the x and y potential
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	108	108	Change potential multiplier constant method
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	152	152	f();
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	173	173	Clear potential method
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	195	195	Clear potential method
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	208	208	Clear potential method
4c675185	f24	p0	2024-10-03 12:03:59	Cpu.cpp	221	221	Clear potential method
4c675185	f24	p0	2024-10-03 12:03:59	main.cpp	11	11	Store an instance of the grid, the command, the input values, and the running state
4c675185	f24	p0	2024-10-03 12:03:59	main.cpp	18	18	Parse the input command
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	2	2	Include the correct header file for GridCell
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	7	10	Pointer to a 2D array of GridCell objects\nNumber of rows in the grid\nNumber of columns in the grid\nk is same for all elements so this class
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	12	12	Constructor to initialize grid with given dimensions
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	14	14	Allocate memory for rows
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	17	17	Allocate memory for each column in the row
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	21	21	Destructor to clean up allocated memory
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	24	24	Deallocate memory for each row
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	26	26	Deallocate the array of GridCell objects in each row
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	28	28	Deallocate memory for the array of row pointers
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	35	35	Getter functions for the grid and size of the array
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	37	37	returns the address in memory of the first element of the grid, which is a pointer to an array of GridCells.
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	42	42	Clear function to reset cells
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	45	45	sets all cells to empty and resets potential
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	50	51	Set cell type to "E" for empty\nReset potential values to zero
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	69	69	compute potential here on all others
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	74	74	use & to compare memory address to make sure not comparing the same values in array
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	100	100	updates grid by cleading old values
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	102	102	first need to clear potentials from old calculations
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	107	107	Reset potential values to zero
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.cpp	110	110	re-compute values
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	4	7	private variables\nPointer to a 2D array of GridCell objects\nNumber of rows\nNumber of columns
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	10	10	constructor
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	12	12	destructor
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	14	14	update k function
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	16	16	getter function to get grid in main
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	19	19	getter functions for rows and cols
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	23	23	Clear function to reset cells
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	26	26	function to compute potential from one point onto another
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	29	29	function to compute potentials for entire grid
4d22c360	f24	p0	2024-09-18 18:38:07	GridArray.h	32	32	function that clears old values and recomputes them
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.cpp	5	7	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.cpp	10	10	Constructor, initializes everything to type empty with no potential
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.cpp	12	13	set potntial x,y protects from random change of one and not the other, thats why private and no public bc want to change at same time\nsetter for potential
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.cpp	18	18	setter for potential
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.cpp	23	23	setter function to set as type obstacle
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.cpp	26	26	call an update here to update values
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.cpp	32	32	Setters function to set as type goal
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.cpp	36	36	call update here to update values
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.cpp	38	38	Getters to access values of a specific gridcell
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.h	4	6	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.h	10	10	constructor
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.h	12	12	setter functions
4d22c360	f24	p0	2024-09-18 18:38:07	GridCell.h	19	19	getters
4d22c360	f24	p0	2024-09-18 18:38:07	project0_main.cpp	15	15	create a pointer to a grid array, initialize to null ptr because constructor will create array in class
4d22c360	f24	p0	2024-09-18 18:38:07	project0_main.cpp	18	18	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-18 18:38:07	project0_main.cpp	20	21	deletes pointer to grid array using my deconstructor\nSet pointer to nullptr to restart the grid
4d22c360	f24	p0	2024-09-18 18:38:07	project0_main.cpp	30	30	gets number of rows and cols
4d22c360	f24	p0	2024-09-18 18:38:07	project0_main.cpp	37	37	updates calculations when goal is placed
4d22c360	f24	p0	2024-09-18 18:38:07	project0_main.cpp	43	43	updates calculations when obstacle is placed
4d22c360	f24	p0	2024-09-18 18:38:07	project0_main.cpp	62	62	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	2	2	Include the correct header file for GridCell
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	7	10	Pointer to a 2D array of GridCell objects\nNumber of rows in the grid\nNumber of columns in the grid\nk is same for all elements so this class
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	12	12	Constructor to initialize grid with given dimensions
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	15	15	Allocate memory for rows
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	18	18	Allocate memory for each column in the row
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	22	22	Destructor to clean up allocated memory
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	25	25	Deallocate memory for each row
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	27	27	Deallocate the array of GridCell objects in each row
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	29	29	Deallocate memory for the array of row pointers
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	36	36	Getter functions for the grid and size of the array
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	38	38	returns the address in memory of the first element of the grid, which is a pointer to an array of GridCells.
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	43	43	Clear function to reset cells
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	46	46	sets all cells to empty and resets potential
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	51	52	Set cell type to "E" for empty\nReset potential values to zero
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	70	70	compute potential here on all others
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	75	75	use & to compare memory address to make sure not comparing the same values in array
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	101	101	updates grid by cleading old values
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	103	103	first need to clear potentials from old calculations
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	108	108	Reset potential values to zero
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.cpp	111	111	re-compute values
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	4	7	private variables\nPointer to a 2D array of GridCell objects\nNumber of rows\nNumber of columns
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	10	10	constructor
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	12	12	destructor
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	14	14	update k function
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	16	16	getter function to get grid in main
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	19	19	getter functions for rows and cols
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	23	23	Clear function to reset cells
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	26	26	function to compute potential from one point onto another
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	29	29	function to compute potentials for entire grid
4d22c360	f24	p0	2024-09-18 20:31:26	GridArray.h	32	32	function that clears old values and recomputes them
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.cpp	5	7	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.cpp	10	10	Constructor, initializes everything to type empty with no potential
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.cpp	12	13	set potntial x,y protects from random change of one and not the other, thats why private and no public bc want to change at same time\nsetter for potential
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.cpp	18	18	setter for potential
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.cpp	23	23	setter function to set as type obstacle
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.cpp	26	26	call an update here to update values
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.cpp	32	32	Setters function to set as type goal
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.cpp	36	36	call update here to update values
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.cpp	38	38	Getters to access values of a specific gridcell
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.h	4	6	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.h	10	10	constructor
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.h	12	12	setter functions
4d22c360	f24	p0	2024-09-18 20:31:26	GridCell.h	19	19	getters
4d22c360	f24	p0	2024-09-18 20:31:26	project0_main.cpp	17	17	create a pointer to a grid array, initialize to null ptr because constructor will create array in class
4d22c360	f24	p0	2024-09-18 20:31:26	project0_main.cpp	20	20	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-18 20:31:26	project0_main.cpp	22	23	deletes pointer to grid array using my deconstructor\nSet pointer to nullptr to restart the grid
4d22c360	f24	p0	2024-09-18 20:31:26	project0_main.cpp	32	32	gets number of rows and cols
4d22c360	f24	p0	2024-09-18 20:31:26	project0_main.cpp	39	39	updates calculations when goal is placed
4d22c360	f24	p0	2024-09-18 20:31:26	project0_main.cpp	45	45	updates calculations when obstacle is placed
4d22c360	f24	p0	2024-09-18 20:31:26	project0_main.cpp	57	57	gets number of rows and cols
4d22c360	f24	p0	2024-09-18 20:31:26	project0_main.cpp	74	74	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-18 20:31:26	project0_main.cpp	100	100	deletes pointer to grid array using my deconstructor
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	2	2	Include the correct header file for GridCell
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	7	10	Pointer to a 2D array of GridCell objects\nNumber of rows in the grid\nNumber of columns in the grid\nk is same for all elements so this class
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	12	12	Constructor to initialize grid with given dimensions
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	15	15	Allocate memory for rows
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	18	18	Allocate memory for each column in the row
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	22	22	Destructor to clean up allocated memory
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	25	25	Deallocate memory for each row
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	27	27	Deallocate the array of GridCell objects in each row
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	29	29	Deallocate memory for the array of row pointers
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	36	36	Getter functions for the grid and size of the array
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	38	38	returns the address in memory of the first element of the grid, which is a pointer to an array of GridCells.
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	43	43	Clear function to reset cells
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	46	46	sets all cells to empty and resets potential
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	51	52	Set cell type to "E" for empty\nReset potential values to zero
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	70	70	compute potential here on all others
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	75	75	use & to compare memory address to make sure not comparing the same values in array
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	101	101	updates grid by cleading old values
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	103	103	first need to clear potentials from old calculations
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	108	108	Reset potential values to zero
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.cpp	111	111	re-compute values
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	4	7	private variables\nPointer to a 2D array of GridCell objects\nNumber of rows\nNumber of columns
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	10	10	constructor
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	12	12	destructor
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	14	14	update k function
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	16	16	getter function to get grid in main
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	19	19	getter functions for rows and cols
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	23	23	Clear function to reset cells
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	26	26	function to compute potential from one point onto another
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	29	29	function to compute potentials for entire grid
4d22c360	f24	p0	2024-09-18 21:04:34	GridArray.h	32	32	function that clears old values and recomputes them
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.cpp	5	7	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.cpp	10	10	Constructor, initializes everything to type empty with no potential
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.cpp	12	13	set potntial x,y protects from random change of one and not the other, thats why private and no public bc want to change at same time\nsetter for potential
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.cpp	18	18	setter for potential
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.cpp	23	23	setter function to set as type obstacle
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.cpp	26	26	call an update here to update values
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.cpp	32	32	Setters function to set as type goal
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.cpp	36	36	call update here to update values
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.cpp	38	38	Getters to access values of a specific gridcell
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.h	4	6	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.h	10	10	constructor
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.h	12	12	setter functions
4d22c360	f24	p0	2024-09-18 21:04:34	GridCell.h	19	19	getters
4d22c360	f24	p0	2024-09-18 21:04:34	project0_main.cpp	17	17	create a pointer to a grid array, initialize to null ptr because constructor will create array in class
4d22c360	f24	p0	2024-09-18 21:04:34	project0_main.cpp	20	20	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-18 21:04:34	project0_main.cpp	22	23	deletes pointer to grid array using my deconstructor\nSet pointer to nullptr to restart the grid
4d22c360	f24	p0	2024-09-18 21:04:34	project0_main.cpp	32	32	gets number of rows and cols
4d22c360	f24	p0	2024-09-18 21:04:34	project0_main.cpp	39	39	updates calculations when goal is placed
4d22c360	f24	p0	2024-09-18 21:04:34	project0_main.cpp	45	45	updates calculations when obstacle is placed
4d22c360	f24	p0	2024-09-18 21:04:34	project0_main.cpp	57	57	gets number of rows and cols
4d22c360	f24	p0	2024-09-18 21:04:34	project0_main.cpp	73	73	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-18 21:04:34	project0_main.cpp	99	99	deletes pointer to grid array using my deconstructor
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	2	2	Include the correct header file for GridCell
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	7	10	Pointer to a 2D array of GridCell objects\nNumber of rows in the grid\nNumber of columns in the grid\nk is same for all elements so this class
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	12	12	Constructor to initialize grid with given dimensions
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	15	15	Allocate memory for rows
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	18	18	Allocate memory for each column in the row
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	22	22	Destructor to clean up allocated memory
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	25	25	Deallocate memory for each row
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	27	27	Deallocate the array of GridCell objects in each row
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	29	29	Deallocate memory for the array of row pointers
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	36	36	Getter functions for the grid and size of the array
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	38	38	returns the address in memory of the first element of the grid, which is a pointer to an array of GridCells.
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	43	43	Clear function to reset cells
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	46	46	sets all cells to empty and resets potential
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	51	52	Set cell type to "E" for empty\nReset potential values to zero
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	70	70	compute potential here on all others
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	75	75	use & to compare memory address to make sure not comparing the same values in array
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	101	101	updates grid by cleading old values
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	103	103	first need to clear potentials from old calculations
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	108	108	Reset potential values to zero
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.cpp	111	111	re-compute values
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	4	7	private variables\nPointer to a 2D array of GridCell objects\nNumber of rows\nNumber of columns
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	10	10	constructor
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	12	12	destructor
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	14	14	update k function
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	16	16	getter function to get grid in main
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	19	19	getter functions for rows and cols
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	23	23	Clear function to reset cells
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	26	26	function to compute potential from one point onto another
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	29	29	function to compute potentials for entire grid
4d22c360	f24	p0	2024-09-19 00:41:22	GridArray.h	32	32	function that clears old values and recomputes them
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.cpp	5	7	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.cpp	10	10	Constructor, initializes everything to type empty with no potential
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.cpp	12	13	set potntial x,y protects from random change of one and not the other, thats why private and no public bc want to change at same time\nsetter for potential
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.cpp	18	18	setter for potential
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.cpp	23	23	setter function to set as type obstacle
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.cpp	26	26	call an update here to update values
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.cpp	32	32	Setters function to set as type goal
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.cpp	36	36	call update here to update values
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.cpp	38	38	Getters to access values of a specific gridcell
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.h	4	6	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.h	10	10	constructor
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.h	12	12	setter functions
4d22c360	f24	p0	2024-09-19 00:41:22	GridCell.h	19	19	getters
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	17	17	create a pointer to a grid array, initialize to null ptr because constructor will create array in class
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	20	20	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	22	23	deletes pointer to grid array using my deconstructor\nSet pointer to nullptr to restart the grid
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	32	32	gets number of rows and cols
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	39	39	updates calculations when goal is placed
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	45	45	updates calculations when obstacle is placed
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	61	61	gets number of rows and cols
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	77	77	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	95	95	remove k from output only for debug purposes
4d22c360	f24	p0	2024-09-19 00:41:22	project0_main.cpp	105	105	deletes pointer to grid array using my deconstructor
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	2	2	Include the correct header file for GridCell
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	7	10	Pointer to a 2D array of GridCell objects\nNumber of rows in the grid\nNumber of columns in the grid\nk is same for all elements so this class
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	12	12	Constructor to initialize grid with given dimensions
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	15	15	Allocate memory for rows
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	18	18	Allocate memory for each column in the row
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	22	22	Destructor to clean up allocated memory
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	25	25	Deallocate memory for each row
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	27	27	Deallocate the array of GridCell objects in each row
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	29	29	Deallocate memory for the array of row pointers
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	36	36	Getter functions for the grid and size of the array
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	38	38	returns the address in memory of the first element of the grid, which is a pointer to an array of GridCells.
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	43	43	Clear function to reset cells
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	46	46	sets all cells to empty and resets potential
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	51	52	Set cell type to "E" for empty\nReset potential values to zero
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	70	70	compute potential here on all others
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	75	75	use & to compare memory address to make sure not comparing the same values in array
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	101	101	updates grid by cleading old values
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	103	103	first need to clear potentials from old calculations
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	108	108	Reset potential values to zero
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.cpp	111	111	re-compute values
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	4	7	private variables\nPointer to a 2D array of GridCell objects\nNumber of rows\nNumber of columns
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	10	10	constructor
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	12	12	destructor
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	14	14	update k function
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	16	16	getter function to get grid in main
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	19	19	getter functions for rows and cols
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	23	23	Clear function to reset cells
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	26	26	function to compute potential from one point onto another
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	29	29	function to compute potentials for entire grid
4d22c360	f24	p0	2024-09-19 00:48:54	GridArray.h	32	32	function that clears old values and recomputes them
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.cpp	5	7	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.cpp	10	10	Constructor, initializes everything to type empty with no potential
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.cpp	12	13	set potntial x,y protects from random change of one and not the other, thats why private and no public bc want to change at same time\nsetter for potential
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.cpp	18	18	setter for potential
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.cpp	23	23	setter function to set as type obstacle
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.cpp	26	26	call an update here to update values
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.cpp	32	32	Setters function to set as type goal
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.cpp	36	36	call update here to update values
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.cpp	38	38	Getters to access values of a specific gridcell
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.h	4	6	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.h	10	10	constructor
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.h	12	12	setter functions
4d22c360	f24	p0	2024-09-19 00:48:54	GridCell.h	19	19	getters
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	17	17	create a pointer to a grid array, initialize to null ptr because constructor will create array in class
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	20	20	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	22	23	deletes pointer to grid array using my deconstructor\nSet pointer to nullptr to restart the grid
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	32	32	gets number of rows and cols
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	39	39	updates calculations when goal is placed
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	45	45	updates calculations when obstacle is placed
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	61	61	gets number of rows and cols
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	77	77	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	95	95	remove k from output only for debug purposes
4d22c360	f24	p0	2024-09-19 00:48:54	project0_main.cpp	105	105	deletes pointer to grid array using my deconstructor
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	2	2	Include the correct header file for GridCell
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	7	10	Pointer to a 2D array of GridCell objects\nNumber of rows in the grid\nNumber of columns in the grid\nk is same for all elements so this class
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	12	12	Constructor to initialize grid with given dimensions
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	15	15	Allocate memory for rows
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	18	18	Allocate memory for each column in the row
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	22	22	Destructor to clean up allocated memory
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	25	25	stackoverflow.com/questions/28935944/how-to-properly-deallocate-2d-array-c)
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	30	30	Deallocate memory for each row
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	32	32	Deallocate the array of GridCell objects in each row
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	34	34	Deallocate memory for the array of row pointers
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	41	41	Getter functions for the grid and size of the array
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	43	43	returns the address in memory of the first element of the grid, which is a pointer to an array of GridCells.
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	48	48	Clear function to reset cells
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	51	51	sets all cells to empty and resets potential
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	56	57	Set cell type to "E" for empty\nReset potential values to zero
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	76	76	compute potential here on all others
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	81	81	use & to compare memory address to make sure not comparing the same values in array
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	107	107	updates grid by cleading old values
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	109	109	first need to clear potentials from old calculations
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	114	114	Reset potential values to zero
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.cpp	117	117	re-compute values
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	5	8	private variables\nPointer to a 2D array of GridCell objects\nNumber of rows\nNumber of columns
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	11	11	constructor
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	13	13	destructor
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	15	15	update k function
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	17	17	getter function to get grid in main
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	20	20	getter functions for rows and cols
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	24	24	Clear function to reset cells
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	27	27	function to compute potential from one point onto another
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	30	30	function to compute potentials for entire grid
4d22c360	f24	p0	2024-09-21 16:06:17	GridArray.h	33	33	function that clears old values and recomputes them
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.cpp	5	7	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.cpp	10	10	Constructor, initializes everything to type empty with no potential
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.cpp	12	13	set potntial x,y protects from random change of one and not the other, thats why private and no public bc want to change at same time\nsetter for potential
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.cpp	18	18	setter for potential
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.cpp	23	23	setter function to set as type obstacle
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.cpp	26	26	call an update here to update values
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.cpp	32	32	Setters function to set as type goal
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.cpp	36	36	call update here to update values
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.cpp	38	38	Getters to access values of a specific gridcell
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.h	5	7	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.h	11	13	constructor\ndeclare default constructor that sets every cell to empty\nsetter functions
4d22c360	f24	p0	2024-09-21 16:06:17	GridCell.h	20	20	getters
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	17	17	create a pointer to a grid array, initialize to null ptr because constructor will create array in class
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	20	20	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	22	23	deletes pointer to grid array using my deconstructor\nSet pointer to nullptr to restart the grid
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	32	32	gets number of rows and cols
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	39	39	updates calculations when goal is placed
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	45	45	updates calculations when obstacle is placed
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	61	61	gets number of rows and cols
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	77	77	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	95	95	remove k from output only for debug purposes
4d22c360	f24	p0	2024-09-21 16:06:17	project0_main.cpp	111	111	deletes pointer to grid array using my deconstructor
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	2	2	Include the correct header file for GridCell
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	6	13	class GridArray {\nprivate:\nGridCell** grid;  // Pointer to a 2D array of GridCell objects\nint rows;        // Number of rows in the grid\nint cols;        // Number of columns in the grid\ndouble k =1; // k is same for all elements so this class\npublic:\nConstructor to initialize grid with given dimensions
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	16	16	Allocate memory for rows
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	19	19	Allocate memory for each column in the row
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	23	23	Destructor to clean up allocated memory
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	26	26	stackoverflow.com/questions/28935944/how-to-properly-deallocate-2d-array-c)
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	31	31	Deallocate memory for each row
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	33	33	Deallocate the array of GridCell objects in each row
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	35	35	Deallocate memory for the array of row pointers
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	42	42	Getter functions for the grid and size of the array
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	44	44	returns the address in memory of the first element of the grid, which is a pointer to an array of GridCells.
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	49	49	Clear function to reset cells
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	52	52	sets all cells to empty and resets potential
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	57	58	Set cell type to "E" for empty\nReset potential values to zero
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	77	77	compute potential here on all others
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	82	82	use & to compare memory address to make sure not comparing the same values in array
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	108	108	updates grid by cleading old values
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	110	110	first need to clear potentials from old calculations
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	115	115	Reset potential values to zero
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	118	118	re-compute values
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.cpp	122	122	};
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	8	11	private variables\nPointer to a 2D array of GridCell objects\nNumber of rows\nNumber of columns
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	14	14	constructor
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	16	16	destructor
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	18	18	update k function
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	20	20	getter function to get grid in main
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	23	23	getter functions for rows and cols
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	27	27	Clear function to reset cells
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	30	30	function to compute potential from one point onto another
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	33	33	function to compute potentials for entire grid
4d22c360	f24	p0	2024-09-21 16:29:50	GridArray.h	36	36	function that clears old values and recomputes them
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	4	8	class GridCell {\nprivate:\ndouble potentialX;       // Potential in the x direction\ndouble potentialY;       // Potential in the y direction\nstd::string type;        // Cell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	10	11	public:\nConstructor, initializes everything to type empty with no potential
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	13	14	set potntial x,y protects from random change of one and not the other, thats why private and no public bc want to change at same time\nsetter for potential
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	19	19	setter for potential
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	24	24	setter function to set as type obstacle
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	27	27	call an update here to update values
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	33	33	Setters function to set as type goal
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	37	37	call update here to update values
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	39	39	Getters to access values of a specific gridcell
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.cpp	43	43	};
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.h	6	8	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.h	12	14	constructor\ndeclare default constructor that sets every cell to empty\nsetter functions
4d22c360	f24	p0	2024-09-21 16:29:50	GridCell.h	21	21	getters
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	17	17	create a pointer to a grid array, initialize to null ptr because constructor will create array in class
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	20	20	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	22	23	deletes pointer to grid array using my deconstructor\nSet pointer to nullptr to restart the grid
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	32	32	gets number of rows and cols
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	39	39	updates calculations when goal is placed
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	45	45	updates calculations when obstacle is placed
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	61	61	gets number of rows and cols
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	77	77	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	95	95	remove k from output only for debug purposes
4d22c360	f24	p0	2024-09-21 16:29:50	project0_main.cpp	111	111	deletes pointer to grid array using my deconstructor
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	2	2	Include the correct header file for GridCell
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	6	6	Constructor to initialize grid with given dimensions
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	9	9	Allocate memory for rows
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	12	12	Allocate memory for each column in the row
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	16	16	Destructor to clean up allocated memory
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	19	19	stackoverflow.com/questions/28935944/how-to-properly-deallocate-2d-array-c)
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	24	24	Deallocate memory for each row
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	26	26	Deallocate the array of GridCell objects in each row
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	28	28	Deallocate memory for the array of row pointers
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	35	35	Getter functions for the grid and size of the array
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	37	37	returns the address in memory of the first element of the grid, which is a pointer to an array of GridCells.
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	42	42	Clear function to reset cells
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	45	45	sets all cells to empty and resets potential
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	50	51	Set cell type to "E" for empty\nReset potential values to zero
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	70	70	compute potential here on all others
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	75	75	use & to compare memory address to make sure not comparing the same values in array
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	101	101	updates grid by cleading old values
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	103	103	first need to clear potentials from old calculations
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	108	108	Reset potential values to zero
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.cpp	111	111	re-compute values
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	8	11	private variables\nPointer to a 2D array of GridCell objects\nNumber of rows\nNumber of columns
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	14	14	constructor
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	16	16	destructor
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	18	18	update k function
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	20	20	getter function to get grid in main
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	23	23	getter functions for rows and cols
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	27	27	Clear function to reset cells
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	30	30	function to compute potential from one point onto another
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	33	33	function to compute potentials for entire grid
4d22c360	f24	p0	2024-09-23 19:08:51	GridArray.h	36	36	function that clears old values and recomputes them
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.cpp	4	4	Constructor, initializes everything to type empty with no potential
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.cpp	6	7	set potntial x,y protects from random change of one and not the other, thats why private and no public bc want to change at same time\nsetter for potential
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.cpp	12	12	setter for potential
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.cpp	17	17	setter function to set as type obstacle
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.cpp	20	20	call an update here to update values
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.cpp	26	26	Setters function to set as type goal
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.cpp	30	30	call update here to update values
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.cpp	32	32	Getters to access values of a specific gridcell
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.h	6	8	Potential in the x direction\nPotential in the y direction\nCell type: "E", "G", or "O"
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.h	12	14	constructor\ndeclare default constructor that sets every cell to empty\nsetter functions
4d22c360	f24	p0	2024-09-23 19:08:51	GridCell.h	21	21	getters
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	16	16	create a pointer to a grid array, initialize to null ptr because constructor will create array in class
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	19	19	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	21	22	deletes pointer to grid array using my deconstructor\nSet pointer to nullptr to restart the grid
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	31	31	gets number of rows and cols
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	38	38	updates calculations when goal is placed
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	44	44	updates calculations when obstacle is placed
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	60	60	gets number of rows and cols
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	76	76	checks if grid has been instantiated in create fcn
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	94	94	remove k from output only for debug purposes
4d22c360	f24	p0	2024-09-23 19:08:51	project0_main.cpp	105	105	deletes pointer to grid array using my deconstructor
4e856d0a	f24	p0	2024-09-22 11:57:15	main.cpp	9	9	Read commands from standard input
4e856d0a	f24	p0	2024-09-22 11:57:15	main.cpp	46	46	Stop the program
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	4	4	Constructor: Initialize default values
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	7	7	Destructor: Clean up dynamically allocated memory
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	11	12	Delete each row in the x-component grid\nDelete each row in the y-component grid
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	14	15	Delete the grid for x-components\nDelete the grid for y-components
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	19	19	Recalculate potentials across the grid
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	23	24	Reset x-component to 0\nReset y-component to 0
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	29	29	Helper function to calculate potential at (x, y) due to a goal or obstacle
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	34	36	Obstacles have a repulsive force\nUpdate x-component\nUpdate y-component
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	40	40	Manually round a float to two decimal places
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	45	45	Create a new grid with the given dimensions
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	47	47	Clean up existing grid if necessary
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	57	57	Set new dimensions
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	61	63	Allocate memory for the new grid\nAllocate rows for x-component grid\nAllocate rows for y-component grid
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	65	66	Allocate columns for each row\nAllocate columns for each row
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	69	69	Initialize all values to 0
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	72	72	Add a goal or obstacle at the given position
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	75	75	Invalid position
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	78	80	Recalculate the potential at the point and for the entire grid\nReset all potentials first\nUpdate potential at the given point
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	84	84	Output the potential vector at the robot's current position
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	87	87	Invalid position
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	90	90	Manually round the x and y components to 2 decimal places
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	95	95	Clear all goals and obstacles from the grid
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	98	98	No grid to clear
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	101	101	Reset all values to 0
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	105	105	Update the constant K for potential calculations
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	108	108	Invalid value for K
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.cpp	112	112	Recalculate potentials with the new constant
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.h	9	10	Dimensions of the grid\nThe constant K for potential calculations
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.h	12	12	Separate 2D arrays for x and y components of the potential field
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.h	18	18	Helper function to calculate potential at (x, y) due to a goal or obstacle
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.h	21	21	Function to round the float to 2 decimal places
4e856d0a	f24	p0	2024-09-22 11:57:15	potential_field.h	25	31	Constructor\nDestructor to clean up memory\nCreate a grid\nAdd a goal or obstacle\nGet the potential at a given position\nClear the grid\nUpdate the constant K
4e856d0a	f24	p0	2024-09-22 12:00:58	main.cpp	9	9	Read commands from standard input
4e856d0a	f24	p0	2024-09-22 12:00:58	main.cpp	46	46	Stop the program
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	4	4	Constructor: Initialize default values
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	7	7	Destructor: Clean up dynamically allocated memory
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	11	12	Delete each row in the x-component grid\nDelete each row in the y-component grid
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	14	15	Delete the grid for x-components\nDelete the grid for y-components
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	19	19	Recalculate potentials across the grid
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	23	24	Reset x-component to 0\nReset y-component to 0
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	29	29	Helper function to calculate potential at (x, y) due to a goal or obstacle
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	34	36	Obstacles have a repulsive force\nUpdate x-component\nUpdate y-component
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	40	40	Manually round a float to two decimal places
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	45	45	Create a new grid with the given dimensions
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	47	47	Clean up existing grid if necessary
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	57	57	Set new dimensions
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	61	63	Allocate memory for the new grid\nAllocate rows for x-component grid\nAllocate rows for y-component grid
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	65	66	Allocate columns for each row\nAllocate columns for each row
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	69	69	Initialize all values to 0
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	72	72	Add a goal or obstacle at the given position
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	75	75	Invalid position
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	78	80	Recalculate the potential at the point and for the entire grid\nReset all potentials first\nUpdate potential at the given point
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	84	84	Output the potential vector at the robot's current position
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	87	87	Invalid position
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	90	90	Manually round the x and y components to 2 decimal places
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	95	95	Clear all goals and obstacles from the grid
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	98	98	No grid to clear
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	101	101	Reset all values to 0
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	105	105	Update the constant K for potential calculations
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	108	108	Invalid value for K
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.cpp	112	112	Recalculate potentials with the new constant
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.h	9	10	Dimensions of the grid\nThe constant K for potential calculations
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.h	12	12	Separate 2D arrays for x and y components of the potential field
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.h	18	18	Helper function to calculate potential at (x, y) due to a goal or obstacle
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.h	21	21	Function to round the float to 2 decimal places
4e856d0a	f24	p0	2024-09-22 12:00:58	potential_field.h	25	31	Constructor\nDestructor to clean up memory\nCreate a grid\nAdd a goal or obstacle\nGet the potential at a given position\nClear the grid\nUpdate the constant K
4e856d0a	f24	p0	2024-09-22 12:05:19	main.cpp	9	9	Read commands from standard input
4e856d0a	f24	p0	2024-09-22 12:05:19	main.cpp	46	46	Stop the program
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	4	4	Constructor: Initialize default values
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	7	7	Destructor: Clean up dynamically allocated memory
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	11	12	Delete each row in the x-component grid\nDelete each row in the y-component grid
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	14	15	Delete the grid for x-components\nDelete the grid for y-components
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	19	19	Recalculate potentials across the grid
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	23	24	Reset x-component to 0\nReset y-component to 0
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	29	29	Helper function to calculate potential at (x, y) due to a goal or obstacle
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	34	36	Obstacles have a repulsive force\nUpdate x-component\nUpdate y-component
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	40	40	Manually round a float to two decimal places
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	45	45	Create a new grid with the given dimensions
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	47	47	Clean up existing grid if necessary
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	57	57	Set new dimensions
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	61	63	Allocate memory for the new grid\nAllocate rows for x-component grid\nAllocate rows for y-component grid
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	65	66	Allocate columns for each row\nAllocate columns for each row
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	69	69	Initialize all values to 0
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	72	72	Add a goal or obstacle at the given position
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	75	75	Invalid position
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	78	80	Recalculate the potential at the point and for the entire grid\nReset all potentials first\nUpdate potential at the given point
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	84	84	Output the potential vector at the robot's current position
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	87	87	Invalid position
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	90	90	Manually round the x and y components to 2 decimal places
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	95	95	Clear all goals and obstacles from the grid
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	98	98	No grid to clear
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	101	101	Reset all values to 0
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	105	105	Update the constant K for potential calculations
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	108	108	Invalid value for K
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.cpp	112	112	Recalculate potentials with the new constant
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.h	9	10	Dimensions of the grid\nThe constant K for potential calculations
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.h	12	12	Separate 2D arrays for x and y components of the potential field
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.h	18	18	Helper function to calculate potential at (x, y) due to a goal or obstacle
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.h	21	21	Function to round the float to 2 decimal places
4e856d0a	f24	p0	2024-09-22 12:05:19	potential_field.h	25	31	Constructor\nDestructor to clean up memory\nCreate a grid\nAdd a goal or obstacle\nGet the potential at a given position\nClear the grid\nUpdate the constant K
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.cpp	5	5	construcor to initilZIe VALUES
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.cpp	16	16	destrcutor
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.cpp	35	35	create a new grid
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.cpp	59	59	Initialize grid to zeros
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.cpp	73	73	calcultae potential
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.cpp	97	97	fuction to add the goal or obstracle to any givne point.
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.cpp	154	154	fuction to return the potiential vector at the robot's current position
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.cpp	168	168	fuction to clear grid
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.cpp	191	191	fuction to update value of K for future calculations.
4e856d0a	f24	p0	2024-09-22 12:22:58	potential_field.h	34	34	fuction to calculate the potential given
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	5	5	construcor to initilZIe VALUES
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	16	16	destrcutor
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	35	35	create a new grid
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	59	59	Initialize grid to zeros
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	80	80	Calculate potential based on the distance
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	83	83	Attractive for goals
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	86	86	Accumulate the potential instead of overwriting it
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	100	100	Check if there's an existing goal or obstacle at this position
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	103	103	Check if this location already has a goal
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	107	107	Subtract the existing goal's potential (it should have been negative)
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	110	110	Subtract attractive potential of the goal
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	113	113	Remove the goal from the list (shifting the remaining goals down)
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	123	123	Check if this location already has an obstacle
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	127	127	Subtract the existing obstacle's potential (it should have been positive)
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	130	130	Subtract repulsive potential of the obstacle
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	133	133	Remove the obstacle from the list (shifting the remaining obstacles down)
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	143	143	Now add the new goal or obstacle
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	164	164	Recalculate potential with the new point
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	168	168	Add attractive potential for goal (negative)
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	170	170	Add repulsive potential for obstacle (positive)
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	180	180	fuction to return the potiential vector at the robot's current position
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	196	196	No grid to clear
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	216	216	Invalid value for K
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	219	219	Calculate the ratio between the new and old constant
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	223	224	Scale gridX by the ratio\nScale gridY by the same ratio
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.cpp	228	228	Update the constant to the new value
4e856d0a	f24	p0	2024-09-22 23:33:59	potential_field.h	34	34	fuction to calculate the potential given
4e856d0a	f24	p0	2024-09-23 20:02:46	potential_field.cpp	5	5	construcor to initilZIe VALUES
4e856d0a	f24	p0	2024-09-23 20:02:46	potential_field.cpp	16	16	destrcutor
4e856d0a	f24	p0	2024-09-23 20:02:46	potential_field.cpp	35	35	create a new grid
4e856d0a	f24	p0	2024-09-23 20:02:46	potential_field.cpp	59	59	Initialize grid to zeros
4e856d0a	f24	p0	2024-09-23 20:02:46	potential_field.cpp	73	73	fuction to calcute potential field
4e856d0a	f24	p0	2024-09-23 20:02:46	potential_field.cpp	209	209	fuction to return the potiential vector at the robot's current position and returns true if the coordiantes are thin the bounds and false
4e856d0a	f24	p0	2024-09-23 20:02:46	potential_field.cpp	223	223	fuction to clear the grid
4e856d0a	f24	p0	2024-09-23 20:02:46	potential_field.cpp	247	247	upodates the valuye of K consytantly for calculations
4e856d0a	f24	p0	2024-09-23 20:02:46	potential_field.h	34	34	fuction to calculate the potential given
4e856d0a	f24	p0	2024-09-23 20:03:29	potential_field.cpp	5	5	construcor to initilZIe VALUES
4e856d0a	f24	p0	2024-09-23 20:03:29	potential_field.cpp	16	16	destrcutor
4e856d0a	f24	p0	2024-09-23 20:03:29	potential_field.cpp	35	35	create a new grid
4e856d0a	f24	p0	2024-09-23 20:03:29	potential_field.cpp	59	59	Initialize grid to zeros
4e856d0a	f24	p0	2024-09-23 20:03:29	potential_field.cpp	73	73	fuction to calcute potential field
4e856d0a	f24	p0	2024-09-23 20:03:29	potential_field.cpp	209	209	fuction to return the potiential vector at the robot's current position and returns true if the coordiantes are thin the bounds and false
4e856d0a	f24	p0	2024-09-23 20:03:29	potential_field.cpp	223	223	fuction to clear the grid
4e856d0a	f24	p0	2024-09-23 20:03:29	potential_field.cpp	247	247	upodates the valuye of K consytantly for calculations
4e856d0a	f24	p0	2024-09-23 20:03:29	potential_field.h	34	34	fuction to calculate the potential given
4e856d0a	f24	p0	2024-09-23 20:03:47	potential_field.cpp	5	5	construcor to initilZIe VALUES
4e856d0a	f24	p0	2024-09-23 20:03:47	potential_field.cpp	16	16	destrcutor
4e856d0a	f24	p0	2024-09-23 20:03:47	potential_field.cpp	35	35	create a new grid
4e856d0a	f24	p0	2024-09-23 20:03:47	potential_field.cpp	59	59	Initialize grid to zeros
4e856d0a	f24	p0	2024-09-23 20:03:47	potential_field.cpp	73	73	fuction to calcute potential field
4e856d0a	f24	p0	2024-09-23 20:03:47	potential_field.cpp	209	209	fuction to return the potiential vector at the robot's current position and returns true if the coordiantes are thin the bounds and false
4e856d0a	f24	p0	2024-09-23 20:03:47	potential_field.cpp	223	223	fuction to clear the grid
4e856d0a	f24	p0	2024-09-23 20:03:47	potential_field.cpp	247	247	upodates the valuye of K consytantly for calculations
4e856d0a	f24	p0	2024-09-23 20:03:47	potential_field.h	34	34	fuction to calculate the potential given
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	9	10	take in input\nbased on command, take in next few args and call fns!
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	16	16	check if started
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	25	25	read the commands
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	27	27	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	32	32	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	34	34	take input
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	39	39	create array
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	68	68	leaves input loop
4e85f139	f24	p0	2024-09-18 19:48:05	main.cpp	73	73	no memory leaks!
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	5	5	Constructor
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	8	8	Set the dimensions
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	12	12	Set default value for K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	15	15	Dynamically allocate a 2D array
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	22	22	Initialize all potentials to 0
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	34	34	Destructor
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	37	37	Deallocate the 2D array
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	47	47	Add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	50	50	Logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	54	54	invalid
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	59	59	check
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	72	72	Find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	75	75	Logic to calculate movement direction
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	88	88	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	91	91	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	97	97	print and return
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	101	101	Clear the entire grid
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	104	105	Logic to reset the grid\n2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	116	116	Set the value of K
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.cpp	119	119	Logic to set the constant K
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.h	11	11	Constructor
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.h	14	14	Destructor
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.h	17	17	Member functions
4e85f139	f24	p0	2024-09-18 19:48:05	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	9	10	take in input\nbased on command, take in next few args and call fns!
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	16	16	check if started
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	25	25	read the commands
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	27	27	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	32	32	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	34	34	take input
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	39	39	create array
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	68	68	leaves input loop
4e85f139	f24	p0	2024-09-18 19:53:32	main.cpp	73	73	no memory leaks!
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	5	5	Constructor
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	8	8	Set the dimensions
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	12	12	Set default value for K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	15	15	Dynamically allocate a 2D array
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	22	22	Initialize all potentials to 0
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	34	34	Destructor
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	37	37	Deallocate the 2D array
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	47	47	Add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	50	50	Logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	54	54	invalid
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	59	59	check
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	72	72	Find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	75	75	Logic to calculate movement direction
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	88	88	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	91	91	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	97	97	print and return
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	101	101	Clear the entire grid
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	104	105	Logic to reset the grid\n2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	116	116	Set the value of K
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.cpp	119	119	Logic to set the constant K
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.h	11	11	Constructor
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.h	14	14	Destructor
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.h	17	17	Member functions
4e85f139	f24	p0	2024-09-18 19:53:32	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	9	10	take in input\nbased on command, take in next few args and call fns!
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	16	16	check if started
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	25	25	read the commands
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	27	27	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	32	32	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	34	34	take input
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	39	39	create array
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	68	68	leaves input loop
4e85f139	f24	p0	2024-09-18 19:53:36	main.cpp	73	73	no memory leaks!
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	5	5	Constructor
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	8	8	Set the dimensions
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	12	12	Set default value for K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	15	15	Dynamically allocate a 2D array
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	22	22	Initialize all potentials to 0
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	34	34	Destructor
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	37	37	Deallocate the 2D array
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	47	47	Add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	50	50	Logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	54	54	invalid
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	59	59	check
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	72	72	Find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	75	75	Logic to calculate movement direction
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	88	88	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	91	91	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	97	97	print and return
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	101	101	Clear the entire grid
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	104	105	Logic to reset the grid\n2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	116	116	Set the value of K
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.cpp	119	119	Logic to set the constant K
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.h	11	11	Constructor
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.h	14	14	Destructor
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.h	17	17	Member functions
4e85f139	f24	p0	2024-09-18 19:53:36	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	9	10	take in input\nbased on command, take in next few args and call fns!
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	16	16	check if started
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	25	25	read the commands
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	27	27	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	32	32	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	34	34	take input
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	39	39	create array
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	68	68	leaves input loop
4e85f139	f24	p0	2024-09-18 19:53:57	main.cpp	73	73	no memory leaks!
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	5	5	Constructor
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	8	8	Set the dimensions
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	12	12	Set default value for K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	15	15	Dynamically allocate a 2D array
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	22	22	Initialize all potentials to 0
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	34	34	Destructor
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	37	37	Deallocate the 2D array
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	47	47	Add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	50	50	Logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	54	54	invalid
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	59	59	check
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	72	72	Find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	75	75	Logic to calculate movement direction
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	88	88	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	91	91	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	97	97	print and return
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	101	101	Clear the entire grid
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	104	105	Logic to reset the grid\n2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	116	116	Set the value of K
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.cpp	119	119	Logic to set the constant K
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.h	11	11	Constructor
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.h	14	14	Destructor
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.h	17	17	Member functions
4e85f139	f24	p0	2024-09-18 19:53:57	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	9	10	take in input\nbased on command, take in next few args and call fns!
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	16	16	check if started
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	25	25	read the commands
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	27	27	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	32	32	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	34	34	take input
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	39	39	create array
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	68	68	leaves input loop
4e85f139	f24	p0	2024-09-18 19:56:11	main.cpp	73	73	no memory leaks!
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	5	5	Constructor
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	8	8	Set the dimensions
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	12	12	Set default value for K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	15	15	Dynamically allocate a 2D array
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	22	22	Initialize all potentials to 0
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	34	34	Destructor
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	37	37	Deallocate the 2D array
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	47	47	Add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	50	50	Logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	54	54	invalid
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	59	59	check
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	72	72	Find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	75	75	Logic to calculate movement direction
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	88	88	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	91	91	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	97	97	print and return
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	101	101	Clear the entire grid
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	104	105	Logic to reset the grid\n2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	116	116	Set the value of K
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.cpp	119	119	Logic to set the constant K
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.h	11	11	Constructor
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.h	14	14	Destructor
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.h	17	17	Member functions
4e85f139	f24	p0	2024-09-18 19:56:11	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	9	10	take in input\nbased on command, take in next few args and call fns!
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	16	16	check if started
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	25	25	read the commands
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	27	27	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	32	32	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	34	34	take input
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	39	39	create array
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	68	68	leaves input loop
4e85f139	f24	p0	2024-09-19 13:53:02	main.cpp	73	73	no memory leaks!
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	5	5	Constructor
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	8	8	Set the dimensions
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	12	12	Set default value for K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	15	15	Dynamically allocate a 2D array
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	22	22	Initialize all potentials to 0
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	34	34	Destructor
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	37	37	Deallocate the 2D array
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	47	47	Add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	50	50	Logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	54	54	invalid
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	59	59	check
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	72	72	Find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	75	75	Logic to calculate movement direction
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	88	88	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	91	91	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	97	97	print and return
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	101	101	Clear the entire grid
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	104	105	Logic to reset the grid\n2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	116	116	Set the value of K
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.cpp	119	119	Logic to set the constant K
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.h	11	11	Constructor
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.h	14	14	Destructor
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.h	17	17	Member functions
4e85f139	f24	p0	2024-09-19 13:53:02	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	9	10	take in input\nbased on command, take in next few args and call functios!
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	14	14	instantiate object
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	18	18	check if started
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	27	27	read the commands
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	29	29	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	34	34	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	36	36	take input
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	41	41	create array
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	70	70	leaves input loop
4e85f139	f24	p0	2024-09-20 02:00:45	main.cpp	75	75	prevents memory leaks!
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	5	5	constructor
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	11	11	default constant K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	20	20	initialize all potentials to 0
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	32	32	destructor
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	35	35	deallocate the 2D array
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	46	46	add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	49	49	logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	53	53	invalid
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	58	58	check
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	72	72	find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	75	75	logic to calculate movement direction
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	89	89	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	93	93	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	99	99	print
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	103	103	clear grid
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	106	106	2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.cpp	117	117	set K value
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.h	11	11	Constructor
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.h	14	14	Destructor
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.h	17	17	Member functions
4e85f139	f24	p0	2024-09-20 02:00:45	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	9	10	take in input\nbased on command, take in next few args and call functios!
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	14	14	instantiate object
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	18	18	check if started
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	27	27	read the commands
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	29	29	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	34	34	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	36	36	take input
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	41	41	create array
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	70	70	exits input loop
4e85f139	f24	p0	2024-09-22 23:41:23	main.cpp	75	75	prevents memory leaks!
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	11	11	constructor
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	17	17	default constant K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	26	26	initialize all potentials to 0
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	38	38	destructor
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	41	41	deallocate the 2D array
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	52	52	add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	55	55	logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	59	59	invalid
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	64	64	check
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	78	78	find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	81	81	logic to calculate movement direction
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	95	95	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	99	99	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	105	105	print
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	109	109	clear grid
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	112	112	2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.cpp	123	123	set K value
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.h	11	11	Constructor
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.h	14	14	Destructor
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.h	17	17	Member functions
4e85f139	f24	p0	2024-09-22 23:41:23	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	9	10	take in input\nbased on command, take in next few args and call functios!
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	14	14	instantiate object
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	18	18	check if started
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	27	27	read the commands
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	29	29	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	34	34	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	36	36	take input
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	41	41	create array
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	70	70	exits input loop
4e85f139	f24	p0	2024-09-23 09:38:01	main.cpp	75	75	prevents memory leaks!
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	11	11	constructor
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	17	17	default constant K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	26	26	initialize all potentials to 0
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	38	38	destructor
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	41	41	deallocate the 2D array
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	52	52	add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	55	55	logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	59	59	invalid
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	64	64	check
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	78	78	find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	81	81	logic to calculate movement direction
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	95	95	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	99	99	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	105	105	print
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	109	109	clear grid
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	112	112	2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.cpp	123	123	set K value
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.h	11	11	constructor
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.h	14	14	destructor
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.h	17	17	member functions
4e85f139	f24	p0	2024-09-23 09:38:01	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	9	10	take in input\nbased on command, take in next few args and call functios!
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	14	14	instantiate object
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	18	18	check if started
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	27	27	read the commands
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	29	29	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	34	34	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	36	36	take input
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	41	41	create array
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	70	70	exits input loop
4e85f139	f24	p0	2024-09-23 09:59:38	main.cpp	75	75	prevents memory leaks!
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	11	11	constructor
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	17	17	default constant K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	26	26	initialize all potentials to 0
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	38	38	destructor
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	41	41	deallocate the 2D array
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	52	52	add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	55	55	logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	59	59	invalid
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	64	64	check
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	78	78	find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	81	81	logic to calculate movement direction
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	95	95	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	99	99	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	105	105	print
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	109	109	clear grid
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	112	112	2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.cpp	123	123	set K value
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.h	11	11	constructor
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.h	14	14	destructor
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.h	17	17	member functions
4e85f139	f24	p0	2024-09-23 09:59:38	potential_field.h	24	24	POTENTIAL_FIELD_H
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	1	1	library imports
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	5	5	file imports
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	9	10	take in input\nbased on command, take in next few args and call functios!
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	14	14	instantiate object
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	18	18	check if started
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	27	27	read the commands
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	29	29	if input fails, clear and move on to next line
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	34	34	take in appropriate amount of args!
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	36	36	take input
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	41	41	create array
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	70	70	exits input loop
4e85f139	f24	p0	2024-09-23 17:20:47	main.cpp	75	75	prevents memory leaks!
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	11	11	constructor
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	17	17	default constant K (assume default as 1.0, can be changed later via set_k)
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	26	26	initialize all potentials to 0
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	38	38	destructor
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	41	41	deallocate the 2D array
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	52	52	add a goal or obstacle at (x, y)
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	55	55	logic to add a point (goal or obstacle)
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	59	59	invalid
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	64	64	check
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	78	78	find the direction the robot should move from (x, y)
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	81	81	logic to calculate movement direction
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	95	95	preventing divide-by-0 error
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	99	99	if goal, obstacle_map[x][y] = -1, else 1
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	105	105	print
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	109	109	clear grid
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	112	112	2 for loops; for each element, set to 0 and move on
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.cpp	123	123	set K value
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.h	11	11	constructor
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.h	14	14	destructor
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.h	17	17	member functions
4e85f139	f24	p0	2024-09-23 17:20:47	potential_field.h	24	24	POTENTIAL_FIELD_H
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	7	7	reading env is expensive, store rather than doing on every debug print
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	27	27	internal, printf only if env "DEBUG=1"
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	37	37	internal, check if position is in the field
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	42	42	internal, recompute all potentials from scratch
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	44	44	Set all potentials to zero
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	52	52	Calculate potentials for each point
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	56	56	if current pos is a goal, ignore
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	59	59	sqrt( (x - xG)^2 + (y - yG)^2 )
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	61	61	goals are negative
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	89	89	maximum possible points
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	100	100	overwrite existing points
515fac27	f24	p0	2024-09-21 16:04:07	PotentialField.cpp	110	110	only add if not overwritten
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	7	7	reading env is expensive, store rather than doing on every debug print
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	27	27	internal, printf only if env "DEBUG=1"
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	37	37	internal, check if position is in the field
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	42	42	internal, recompute all potentials from scratch
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	44	44	Set all potentials to zero
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	52	52	Calculate potentials for each point
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	56	56	if current pos is a goal, ignore
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	59	59	sqrt( (x - xG)^2 + (y - yG)^2 )
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	61	61	goals are negative
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	89	89	maximum possible points
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	100	100	overwrite existing points
515fac27	f24	p0	2024-09-21 16:07:28	PotentialField.cpp	110	110	only add if not overwritten
515fac27	f24	p0	2024-09-22 11:58:27	Point.cpp	8	8	sqrt( (x - xG)^2 + (y - yG)^2 )
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	7	7	reading env is expensive, store rather than doing on every debug print
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	27	27	internal, printf only if env "DEBUG=1"
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	37	37	internal, check if position is in the field
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	42	42	internal, recompute all potentials from scratch
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	44	44	Set all potentials to zero
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	52	52	Calculate potentials for each point
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	56	59	if current pos is a goal, ignore\ndouble dx = i - points[p].x;\ndouble dy = j - points[p].y;\ndouble distance = std::sqrt(dx*dx + dy*dy); // sqrt( (x - xG)^2 + (y - yG)^2 )
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	61	61	goals are negative
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	89	89	maximum possible points
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	100	100	overwrite existing points
515fac27	f24	p0	2024-09-22 11:58:27	PotentialField.cpp	110	110	only add if not overwritten
55173694	f24	p0	2024-09-23 13:23:36	Environment.cpp	63	63	DOUBT: ASK ABOUT THE FAILURE CASE
55173694	f24	p0	2024-09-23 13:23:36	Environment.h	18	18	what exactly is EXIT() supposed to do?
55173694	f24	p0	2024-09-23 13:28:21	Environment.cpp	63	63	DOUBT: ASK ABOUT THE FAILURE CASE
55173694	f24	p0	2024-09-23 13:28:21	Environment.h	18	18	what exactly is EXIT() supposed to do?
55173694	f24	p0	2024-09-23 16:00:31	Environment.cpp	64	64	DOUBT: ASK ABOUT THE FAILURE CASE
55173694	f24	p0	2024-09-23 16:00:31	Environment.h	18	18	what exactly is EXIT() supposed to do?
55173694	f24	p0	2024-09-23 16:05:37	Environment.cpp	64	64	DOUBT: ASK ABOUT THE FAILURE CASE
55173694	f24	p0	2024-09-23 16:05:37	Environment.h	18	18	what exactly is EXIT() supposed to do?
55173694	f24	p0	2024-09-23 18:34:36	Environment.h	18	18	what exactly is EXIT() supposed to do?
55173694	f24	p0	2024-09-23 22:09:08	Environment.h	18	18	what exactly is EXIT() supposed to do?
575598a6	f24	p0	2024-09-19 18:58:35	RobotNav.cpp	6	7	N is rows and M is columns\nIn each element, index 0 is Px, index 1 is Py
575598a6	f24	p0	2024-09-19 18:58:35	RobotNav.cpp	85	85	std::cout << navMap << " " << X << " " << Y << " " << T << std::endl;
575598a6	f24	p0	2024-09-19 18:58:35	RobotNav.cpp	93	93	std::cout << "[j: " << j << ", i: " << i << ", increment: " << incrementX << " T: " << elementType[i][j] << " sign: " << short(sign) <<"] ";
575598a6	f24	p0	2024-09-19 18:58:35	RobotNav.cpp	103	103	std::cout << std::endl;
575598a6	f24	p0	2024-09-19 18:58:35	RobotNav.hpp	23	23	添加到 public 区域
575598a6	f24	p0	2024-09-19 19:04:04	RobotNav.cpp	6	7	N is rows and M is columns\nIn each element, index 0 is Px, index 1 is Py
575598a6	f24	p0	2024-09-19 19:04:04	RobotNav.cpp	85	85	std::cout << navMap << " " << X << " " << Y << " " << T << std::endl;
575598a6	f24	p0	2024-09-19 19:04:04	RobotNav.cpp	93	93	std::cout << "[j: " << j << ", i: " << i << ", increment: " << incrementX << " T: " << elementType[i][j] << " sign: " << short(sign) <<"] ";
575598a6	f24	p0	2024-09-19 19:04:04	RobotNav.cpp	103	103	std::cout << std::endl;
575598a6	f24	p0	2024-09-19 19:04:04	RobotNav.hpp	23	23	添加到 public 区域
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	10	10	Create an instance of the RobotNav class
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	12	12	The program continuously reads user commands until the "EXIT" command is entered
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	15	15	Command to create a new navigation map with specified rows (N) and columns (M)
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	19	19	Output success if map creation is successful
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	21	21	Output failure if map creation fails
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	24	24	Command to set a point with a specific type (T) at coordinates (X, Y)
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	29	29	Output success if the point is set successfully
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	31	31	Output failure if the point setting fails
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	34	34	Command to get the potential values at a specific point (X, Y)
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	39	39	Output the potential values Px and Py
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	41	41	Output failure if the move command fails
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	44	44	Command to clear the entire navigation map
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	46	46	Output success if the map is cleared successfully
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	48	48	Output failure if the map clearing fails
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	51	51	Command to update the potential values across the map with a new scaling factor K
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	55	55	Output success if the update is successful
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	57	57	Output failure if the update fails
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	60	60	Command to exit the program
575598a6	f24	p0	2024-09-20 19:18:47	main.cpp	64	64	End of the program
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	6	7	N represents the number of rows and M represents the number of columns.\nEach element of navMap is a double pointer where index 0 represents Px and index 1 represents Py.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	9	9	Releases dynamically allocated memory for navMap and elementType arrays.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	12	12	Loop through each row
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	15	15	Loop through each column and delete the third dimension array
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	20	20	Delete the second dimension array
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	24	24	Delete the first dimension array and set pointer to null
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	30	30	Loop through each row and delete the elementType array
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	35	35	Delete the first dimension array and set pointer to null
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	41	41	Computes the potential values Px and Py between the current point (x, y) and destination point (Dx, Dy).
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	43	43	Since the formula is the same for Px and Py, we compute once and assign to both.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	47	47	Constructor initializes K, M, N to zero and pointers to nullptr.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	50	50	Destructor releases allocated memory by calling releaseMap.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	55	55	Creates the navMap and elementType arrays with given dimensions M (columns) and N (rows).
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	57	57	Clear any existing map data
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	62	62	Allocate memory for navMap and elementType arrays.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	69	70	Allocate memory for potential vectors Px and Py\nInitialize elementType with 0
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	72	72	Initialize Px and Py with 0
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	76	76	Memory allocation successful
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	80	81	Release any allocated memory in case of failure\nAllocation failed
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	85	85	Retrieves the potential values Px and Py for the specified point (X, Y).
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	90	90	Successfully retrieved potential values
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	92	92	Point (X, Y) is out of bounds or navMap is uninitialized
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	95	95	Sets the element type at point (X, Y) to T and updates the navMap with potential values.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	98	98	Assign sign based on the element type (O: positive, G: negative)
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	105	105	Update navMap based on the existing and new element type
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	116	116	Set the new element type
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	120	120	Invalid coordinates or element type
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	123	123	Clears all the potential values and resets elementType in the navMap.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	128	129	Reset Px and Py\nReset element type
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	134	134	navMap is uninitialized
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	137	137	Updates all potential values in navMap by scaling with the new value of K.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	142	142	Scale Px and Py values with the new K
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	147	147	Update the K value
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	150	150	Invalid K value
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	153	153	Prints the current state of navMap to the console.
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	159	159	Print the potential values for each point
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.cpp	164	164	Example print statement for a specific point
575598a6	f24	p0	2024-09-20 19:18:47	RobotNav.hpp	23	23	添加到 public 区域
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	10	10	Create an instance of the RobotNav class
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	12	12	The program continuously reads user commands until the "EXIT" command is entered
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	15	15	Command to create a new navigation map with specified rows (N) and columns (M)
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	19	19	Output success if map creation is successful
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	21	21	Output failure if map creation fails
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	24	24	Command to set a point with a specific type (T) at coordinates (X, Y)
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	29	29	Output success if the point is set successfully
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	31	31	Output failure if the point setting fails
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	34	34	Command to get the potential values at a specific point (X, Y)
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	39	39	Output the potential values Px and Py
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	41	41	Output failure if the move command fails
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	44	44	Command to clear the entire navigation map
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	46	46	Output success if the map is cleared successfully
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	48	48	Output failure if the map clearing fails
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	51	51	Command to update the potential values across the map with a new scaling factor K
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	55	55	Output success if the update is successful
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	57	57	Output failure if the update fails
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	60	60	Command to exit the program
575598a6	f24	p0	2024-09-23 17:17:59	main.cpp	64	64	End of the program
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	6	7	N represents the number of rows and M represents the number of columns.\nEach element of navMap is a double pointer where index 0 represents Px and index 1 represents Py.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	9	9	Releases dynamically allocated memory for navMap and elementType arrays.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	12	12	Loop through each row
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	15	15	Loop through each column and delete the third dimension array
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	20	20	Delete the second dimension array
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	24	24	Delete the first dimension array and set pointer to null
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	30	30	Loop through each row and delete the elementType array
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	35	35	Delete the first dimension array and set pointer to null
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	41	41	Computes the potential values Px and Py between the current point (x, y) and destination point (Dx, Dy).
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	43	43	Since the formula is the same for Px and Py, we compute once and assign to both.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	47	47	Constructor initializes K, M, N to zero and pointers to nullptr.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	50	50	Destructor releases allocated memory by calling releaseMap.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	55	55	Creates the navMap and elementType arrays with given dimensions M (columns) and N (rows).
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	57	57	Clear any existing map data
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	62	62	Allocate memory for navMap and elementType arrays.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	69	70	Allocate memory for potential vectors Px and Py\nInitialize elementType with 0
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	72	72	Initialize Px and Py with 0
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	76	76	Memory allocation successful
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	80	81	Release any allocated memory in case of failure\nAllocation failed
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	85	85	Retrieves the potential values Px and Py for the specified point (X, Y).
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	90	90	Successfully retrieved potential values
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	92	92	Point (X, Y) is out of bounds or navMap is uninitialized
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	95	95	Sets the element type at point (X, Y) to T and updates the navMap with potential values.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	98	98	Assign sign based on the element type (O: positive, G: negative)
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	105	105	Update navMap based on the existing and new element type
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	116	116	Set the new element type
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	120	120	Invalid coordinates or element type
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	123	123	Clears all the potential values and resets elementType in the navMap.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	128	129	Reset Px and Py\nReset element type
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	134	134	navMap is uninitialized
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	137	137	Updates all potential values in navMap by scaling with the new value of K.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	142	142	Scale Px and Py values with the new K
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	147	147	Update the K value
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	150	150	Invalid K value
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	153	153	Prints the current state of navMap to the console.
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	159	159	Print the potential values for each point
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.cpp	164	164	Example print statement for a specific point
575598a6	f24	p0	2024-09-23 17:17:59	RobotNav.hpp	23	23	添加到 public 区域
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	16	16	constructor
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	21	21	destructor
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	32	32	clears existing grid
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	46	46	create new grid
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	54	54	N for no goal or obstacle
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	65	65	resets the influence on potential due to G/O/N at location on every point, prior to inserting new G/O
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	68	68	given formula denominator
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	71	71	type N, influence on potential = 0
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	73	73	type G, -k
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	75	75	type O, +k
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	77	77	removes any influence on total potential
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	81	82	updates the type at that position with new G/O\nrecalculates the influence on potential due to new G/O for every point on the grid
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	85	85	given formula denominator
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	88	88	type N, influence on potential = 0
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	90	90	type G, -k
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	92	92	type O, +k
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	94	94	adds to the total influence on potential on that location
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	116	116	k > 0, update k
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	118	118	recalculate potentials for the entire grid
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	125	125	recalculate potentials based on current types and new K value
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	128	128	checks if empty cell
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	134	134	-k for G
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	136	136	+k for O
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.cpp	155	163	void GridMap::printGrid() const {\nstd::cout << "Printing Grid Potentials and Types:" << std::endl;\nfor (int i = 0; i < height; i++) {\nfor (int j = 0; j < width; j++) {\nstd::cout << potentials[i][j] << "(" << types[i][j] << ") ";\n}\nstd::cout << std::endl;\n}\n}
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.h	14	14	void printGrid() const; // Add this line in the public section of your class
5982e913	f24	p0	2024-09-23 15:02:46	gridmap.h	18	19	2D array for grid and store potentials\n2D array to store G for goal or O for obstacle
5982e913	f24	p0	2024-09-23 15:02:46	main.cpp	5	5	temp values
5982e913	f24	p0	2024-09-23 15:02:46	main.cpp	11	11	gridMap.printGrid();
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.cpp	19	20	Prevent double deletion\nPrevent double deletion
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.cpp	25	25	Delete existing grid if it exists
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.cpp	35	35	Allocate memory for and create a new grid
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.cpp	41	41	Corrected from cols to rows
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.cpp	44	45	Allocate memory for each row\nAllocate memory for each row
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.cpp	47	47	Initialize each element to 0 using a loop
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.cpp	63	63	Depending on goal or obstacle
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.cpp	69	69	Prevent division by zero
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.h	9	10	2D array for x-values of the potential\n2D array for y-values of the potential
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.h	15	15	Helper function (if needed)
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.h	18	19	Constructor\nDestructor
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.h	21	25	CREATE command\nPOINT command\nMOVE command\nCLEAR command\nUPDATE command
5b601cfa	f24	p0	2024-09-23 22:06:21	gridfield.h	28	28	GRIDFIELD_H
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.cpp	19	20	Prevent double deletion\nPrevent double deletion
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.cpp	25	25	Delete existing grid if it exists
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.cpp	35	35	Allocate memory for and create a new grid
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.cpp	41	41	Corrected from cols to rows
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.cpp	44	45	Allocate memory for each row\nAllocate memory for each row
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.cpp	47	47	Initialize each element to 0 using a loop
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.cpp	63	63	Depending on goal or obstacle
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.cpp	69	69	Prevent division by zero
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.h	9	10	2D array for x-values of the potential\n2D array for y-values of the potential
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.h	15	15	Helper function (if needed)
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.h	18	19	Constructor\nDestructor
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.h	21	25	CREATE command\nPOINT command\nMOVE command\nCLEAR command\nUPDATE command
5b601cfa	f24	p0	2024-09-23 22:09:59	gridfield.h	28	28	GRIDFIELD_H
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.cpp	19	20	prevent double deletion\nprevent double deletion
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.cpp	25	25	delete existing grid if it exists
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.cpp	34	34	deallocate the memory for old grid
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.cpp	39	39	allocate memory for and create a new grid
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.cpp	45	45	corrected from cols to rows
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.cpp	48	49	allocate memory for each row\nallocate memory for each row
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.cpp	51	51	initialize each element to 0 using a loop
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.cpp	67	67	depending on goal or obstacle
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.cpp	73	73	prevent division by zero
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.h	9	10	2D array for x-values of the potential\n2D array for y-values of the potential
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.h	15	15	Helper function (if needed)
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.h	18	19	Constructor\nDestructor
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.h	21	25	CREATE command\nPOINT command\nMOVE command\nCLEAR command\nUPDATE command
5b601cfa	f24	p0	2024-09-23 22:38:00	gridfield.h	28	28	GRIDFIELD_H
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	19	20	prevent double deletion\nprevent double deletion
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	25	25	delete existing grid if it exists
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	34	34	deallocate the memory for old grid
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	39	39	allocate memory for and create a new grid
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	45	45	corrected from cols to rows
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	48	49	allocate memory for each row\nallocate memory for each row
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	51	51	initialize each element to 0 using a loop
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	67	67	clear the field to recalculate from scratch
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	75	75	depending on goal or obstacle
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.cpp	81	81	prevent division by zero
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.h	9	10	2D array for x-values of the potential\n2D array for y-values of the potential
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.h	15	15	Helper function (if needed)
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.h	18	19	Constructor\nDestructor
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.h	21	25	CREATE command\nPOINT command\nMOVE command\nCLEAR command\nUPDATE command
5b601cfa	f24	p0	2024-09-23 22:44:15	gridfield.h	28	28	GRIDFIELD_H
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.cpp	19	20	prevent double deletion\nprevent double deletion
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.cpp	25	25	delete existing grid if it exists
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.cpp	34	34	deallocate the memory for old grid
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.cpp	39	39	allocate memory for and create a new grid
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.cpp	45	45	corrected from cols to rows
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.cpp	48	49	allocate memory for each row\nallocate memory for each row
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.cpp	51	51	initialize each element to 0 using a loop
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.cpp	68	68	depending on goal or obstacle
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.cpp	74	74	prevent division by zero
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.h	9	10	2D array for x-values of the potential\n2D array for y-values of the potential
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.h	15	15	Helper function (if needed)
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.h	18	19	Constructor\nDestructor
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.h	21	25	CREATE command\nPOINT command\nMOVE command\nCLEAR command\nUPDATE command
5b601cfa	f24	p0	2024-09-23 22:45:07	gridfield.h	28	28	GRIDFIELD_H
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.cpp	19	20	prevent double deletion\nprevent double deletion
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.cpp	25	25	delete existing grid if it exists
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.cpp	34	34	deallocate the memory for old grid
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.cpp	39	39	allocate memory for and create a new grid
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.cpp	45	45	corrected from cols to rows
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.cpp	48	49	allocate memory for each row\nallocate memory for each row
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.cpp	51	51	initialize each element to 0 using a loop
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.cpp	68	68	depending on goal or obstacle
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.cpp	74	74	prevent division by zero
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.h	9	10	2D array for x-values of the potential\n2D array for y-values of the potential
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.h	18	19	Constructor\nDestructor
5b601cfa	f24	p0	2024-09-23 22:49:22	gridfield.h	21	25	CREATE command\nPOINT command\nMOVE command\nCLEAR command\nUPDATE command
5eb2f1a2	f24	p0	2024-09-22 16:18:12	main.cpp	18	18	call the function
5eb2f1a2	f24	p0	2024-09-22 16:18:12	main.cpp	25	25	call the function
5eb2f1a2	f24	p0	2024-09-22 16:18:12	main.cpp	31	31	call the function
5eb2f1a2	f24	p0	2024-09-22 16:18:12	main.cpp	35	35	call the function
5eb2f1a2	f24	p0	2024-09-22 16:18:12	main.cpp	40	40	call the function
5eb2f1a2	f24	p0	2024-09-22 16:18:12	main.cpp	43	43	call the function
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	5	5	constructor to initialize values
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	14	14	function to create the map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	16	17	check if this->map has been used since the constructor\nif it has, then delete it
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	22	22	assign values to this->
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	27	28	give new value to map and t_map\ninitialize 2D arrays
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	36	36	enter values of 0 and 'o' into arrays
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	43	44	add an obstacle or goal at certain position in grid\nthen recalculate potential for whole map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	46	46	if the x and y values given are within the map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	48	48	if they are, insert the char into the t_map at the x y index
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	50	50	update the potential with the new goal or obstacle
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	53	53	if not then output failure
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	55	56	std::cout << "X: " << X << " Y: " << Y << std::endl;\nstd::cout << "N: " << this->N << " M: " << this->M << std::endl;
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	62	62	give the potential at a certain spot in the map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	64	64	if the given X and Y are within the bounds of the map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	66	66	P is the potential at that index
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	76	76	reinitialize all the values
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	78	78	if map has already been created
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	87	87	update K value, then update potentials
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	89	89	check to make sure new_k is a positive double number
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	99	99	insert the goal or obstacle into a specific spot in the t_map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	102	103	std::cout << "goal or obstacle: " << T << std::endl;\nstd::cout << "index: (" << X << ", " << Y << std::endl;
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	106	106	update the potential for every index of the map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	108	108	for every index in the potential map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	110	110	i is x, j is y
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	112	112	reinitialize pot
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	114	114	for every index in t_map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	117	117	find if there is a goal, obstacle or nothing at that index
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	119	119	if nothing then continue
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	122	122	if goal or obstacle at same index as x y then continue
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	125	125	if it is a goal, calculate potential for a goal
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	127	127	calculate potential for specific index of map for this goal
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	129	129	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	132	132	calculate potential for specific index of map for this object
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	134	134	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	139	141	when done looping through t_map,\npot will have the sum of the potentials for that index in the value\nupdate the potential value in the map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	147	147	empty both the map and t_map 2D array
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.cpp	157	157	delete pointers to map and t_map
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.h	9	10	constructor to initialize values\ninitialize array, returns pointer to array, make this a constructor?
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.h	18	19	double pointer to map\ndouble pointer to map of obstacles/goals
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.h	21	23	put variables to calculate potential at spot depending on obstacle or goal\nfigure out what will input into this function so calculate potential\ndepending on other functions that will call it
5eb2f1a2	f24	p0	2024-09-22 16:18:12	potential.h	25	26	calculates potential, to be called from within other functions\nuse in point, move, update
5eb2f1a2	f24	p0	2024-09-22 16:22:12	main.cpp	18	18	call the function
5eb2f1a2	f24	p0	2024-09-22 16:22:12	main.cpp	25	25	call the function
5eb2f1a2	f24	p0	2024-09-22 16:22:12	main.cpp	31	31	call the function
5eb2f1a2	f24	p0	2024-09-22 16:22:12	main.cpp	35	35	call the function
5eb2f1a2	f24	p0	2024-09-22 16:22:12	main.cpp	40	40	call the function
5eb2f1a2	f24	p0	2024-09-22 16:22:12	main.cpp	43	43	call the function
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	5	5	constructor to initialize values
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	14	14	function to create the map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	16	17	check if this->map has been used since the constructor\nif it has, then delete it
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	22	22	assign values to this->
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	27	28	give new value to map and t_map\ninitialize 2D arrays
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	36	36	enter values of 0 and 'o' into arrays
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	43	44	add an obstacle or goal at certain position in grid\nthen recalculate potential for whole map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	46	46	if the x and y values given are within the map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	48	48	if they are, insert the char into the t_map at the x y index
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	50	50	update the potential with the new goal or obstacle
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	53	53	if not then output failure
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	55	56	std::cout << "X: " << X << " Y: " << Y << std::endl;\nstd::cout << "N: " << this->N << " M: " << this->M << std::endl;
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	62	62	give the potential at a certain spot in the map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	64	64	if the given X and Y are within the bounds of the map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	66	66	P is the potential at that index
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	76	76	reinitialize all the values
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	78	78	if map has already been created
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	87	87	update K value, then update potentials
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	89	89	check to make sure new_k is a positive double number
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	99	99	insert the goal or obstacle into a specific spot in the t_map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	102	103	std::cout << "goal or obstacle: " << T << std::endl;\nstd::cout << "index: (" << X << ", " << Y << std::endl;
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	106	106	update the potential for every index of the map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	108	108	for every index in the potential map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	110	110	i is x, j is y
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	112	112	reinitialize pot
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	114	114	for every index in t_map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	117	117	find if there is a goal, obstacle or nothing at that index
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	119	119	if nothing then continue
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	122	122	if goal or obstacle at same index as x y then continue
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	125	125	if it is a goal, calculate potential for a goal
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	127	127	calculate potential for specific index of map for this goal
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	129	129	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	132	132	calculate potential for specific index of map for this object
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	134	134	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	139	141	when done looping through t_map,\npot will have the sum of the potentials for that index in the value\nupdate the potential value in the map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	147	147	empty both the map and t_map 2D array
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.cpp	157	157	delete pointers to map and t_map
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.h	9	10	constructor to initialize values\ninitialize array, returns pointer to array, make this a constructor?
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.h	18	19	double pointer to map\ndouble pointer to map of obstacles/goals
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.h	21	23	put variables to calculate potential at spot depending on obstacle or goal\nfigure out what will input into this function so calculate potential\ndepending on other functions that will call it
5eb2f1a2	f24	p0	2024-09-22 16:22:12	potential.h	25	26	calculates potential, to be called from within other functions\nuse in point, move, update
5eb2f1a2	f24	p0	2024-09-22 16:55:32	main.cpp	18	18	call the function
5eb2f1a2	f24	p0	2024-09-22 16:55:32	main.cpp	25	25	call the function
5eb2f1a2	f24	p0	2024-09-22 16:55:32	main.cpp	31	31	call the function
5eb2f1a2	f24	p0	2024-09-22 16:55:32	main.cpp	35	35	call the function
5eb2f1a2	f24	p0	2024-09-22 16:55:32	main.cpp	40	40	call the function
5eb2f1a2	f24	p0	2024-09-22 16:55:32	main.cpp	43	43	call the function
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	5	5	constructor to initialize values
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	14	14	function to create the map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	16	17	check if this->map has been used since the constructor\nif it has, then delete it
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	22	22	assign values to this->
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	27	28	give new value to map and t_map\ninitialize 2D arrays
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	36	36	enter values of 0 and 'o' into arrays
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	43	44	add an obstacle or goal at certain position in grid\nthen recalculate potential for whole map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	46	46	if the x and y values given are within the map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	48	48	if they are, insert the char into the t_map at the x y index
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	50	50	update the potential with the new goal or obstacle
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	53	53	if not then output failure
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	55	56	std::cout << "X: " << X << " Y: " << Y << std::endl;\nstd::cout << "N: " << this->N << " M: " << this->M << std::endl;
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	62	62	give the potential at a certain spot in the map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	64	64	if the given X and Y are within the bounds of the map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	66	66	P is the potential at that index
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	76	76	reinitialize all the values
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	78	78	if map has already been created
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	87	87	update K value, then update potentials
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	89	89	check to make sure new_k is a positive double number
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	99	99	insert the goal or obstacle into a specific spot in the t_map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	102	103	std::cout << "goal or obstacle: " << T << std::endl;\nstd::cout << "index: (" << X << ", " << Y << std::endl;
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	106	106	update the potential for every index of the map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	108	108	for every index in the potential map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	110	110	i is x, j is y
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	112	112	reinitialize pot
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	114	114	for every index in t_map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	117	117	find if there is a goal, obstacle or nothing at that index
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	119	119	if nothing then continue
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	122	122	if goal or obstacle at same index as x y then continue
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	125	125	if it is a goal, calculate potential for a goal
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	127	127	calculate potential for specific index of map for this goal
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	129	129	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	132	132	calculate potential for specific index of map for this object
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	134	134	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	139	141	when done looping through t_map,\npot will have the sum of the potentials for that index in the value\nupdate the potential value in the map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	147	147	empty both the map and t_map 2D array
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.cpp	157	157	delete pointers to map and t_map
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.h	9	10	constructor to initialize values\ninitialize array, returns pointer to array, make this a constructor?
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.h	18	19	double pointer to map\ndouble pointer to map of obstacles/goals
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.h	21	23	put variables to calculate potential at spot depending on obstacle or goal\nfigure out what will input into this function so calculate potential\ndepending on other functions that will call it
5eb2f1a2	f24	p0	2024-09-22 16:55:32	potential.h	25	26	calculates potential, to be called from within other functions\nuse in point, move, update
5eb2f1a2	f24	p0	2024-09-22 19:00:30	main.cpp	18	18	call the function
5eb2f1a2	f24	p0	2024-09-22 19:00:30	main.cpp	25	25	call the function
5eb2f1a2	f24	p0	2024-09-22 19:00:30	main.cpp	31	31	call the function
5eb2f1a2	f24	p0	2024-09-22 19:00:30	main.cpp	35	35	call the function
5eb2f1a2	f24	p0	2024-09-22 19:00:30	main.cpp	40	40	call the function
5eb2f1a2	f24	p0	2024-09-22 19:00:30	main.cpp	44	44	call the function
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	5	5	constructor to initialize values
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	14	14	function to create the map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	16	17	check if this->map has been used since the constructor\nif it has, then delete it
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	22	22	assign values to this->
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	27	28	give new value to map and t_map\ninitialize 2D arrays
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	36	36	enter values of 0 and 'o' into arrays
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	42	43	add an obstacle or goal at certain position in grid\nthen recalculate potential for whole map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	45	45	if the x and y values given are within the map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	47	47	if they are, insert the char into the t_map at the x y index
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	49	49	update the potential with the new goal or obstacle
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	52	52	if not then output failure
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	54	55	std::cout << "X: " << X << " Y: " << Y << std::endl;\nstd::cout << "N: " << this->N << " M: " << this->M << std::endl;
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	60	60	give the potential at a certain spot in the map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	62	62	if the given X and Y are within the bounds of the map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	64	64	P is the potential at that index
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	73	73	reinitialize all the values
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	75	75	if map has already been created
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	84	84	update K value, then update potentials
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	86	86	check to make sure new_k is a positive double number
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	95	95	insert the goal or obstacle into a specific spot in the t_map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	98	99	std::cout << "goal or obstacle: " << T << std::endl;\nstd::cout << "index: (" << X << ", " << Y << std::endl;
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	102	102	update the potential for every index of the map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	104	104	for every index in the potential map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	106	106	i is x, j is y
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	108	108	reinitialize pot
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	110	110	for every index in t_map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	113	113	find if there is a goal, obstacle or nothing at that index
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	115	115	if nothing then continue
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	118	118	if goal or obstacle at same index as x y then continue
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	121	121	if it is a goal, calculate potential for a goal
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	123	123	calculate potential for specific index of map for this goal
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	125	125	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	128	128	calculate potential for specific index of map for this object
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	130	130	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	135	137	when done looping through t_map,\npot will have the sum of the potentials for that index in the value\nupdate the potential value in the map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	143	143	empty both the map and t_map 2D array
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.cpp	153	153	delete pointers to map and t_map
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.h	9	10	constructor to initialize values\ninitialize array, returns pointer to array, make this a constructor?
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.h	18	19	double pointer to map\ndouble pointer to map of obstacles/goals
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.h	21	23	put variables to calculate potential at spot depending on obstacle or goal\nfigure out what will input into this function so calculate potential\ndepending on other functions that will call it
5eb2f1a2	f24	p0	2024-09-22 19:00:30	potential.h	25	26	calculates potential, to be called from within other functions\nuse in point, move, update
5eb2f1a2	f24	p0	2024-09-23 13:01:01	main.cpp	18	18	call the function
5eb2f1a2	f24	p0	2024-09-23 13:01:01	main.cpp	25	25	call the function
5eb2f1a2	f24	p0	2024-09-23 13:01:01	main.cpp	31	31	call the function
5eb2f1a2	f24	p0	2024-09-23 13:01:01	main.cpp	35	35	call the function
5eb2f1a2	f24	p0	2024-09-23 13:01:01	main.cpp	40	40	call the function
5eb2f1a2	f24	p0	2024-09-23 13:01:01	main.cpp	44	44	call the function
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	5	5	constructor to initialize values
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	14	14	function to create the map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	16	17	check if this->map has been used since the constructor\nif it has, then delete it
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	22	22	assign values to this->
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	27	28	give new value to map and t_map\ninitialize 2D arrays
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	36	36	enter values of 0 and 'o' into arrays
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	42	43	add an obstacle or goal at certain position in grid\nthen recalculate potential for whole map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	45	45	if the x and y values given are within the map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	47	47	if they are, insert the char into the t_map at the x y index
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	49	49	update the potential with the new goal or obstacle
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	52	52	if not then output failure
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	54	55	std::cout << "X: " << X << " Y: " << Y << std::endl;\nstd::cout << "N: " << this->N << " M: " << this->M << std::endl;
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	60	60	give the potential at a certain spot in the map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	62	62	if the given X and Y are within the bounds of the map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	64	64	P is the potential at that index
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	73	73	reinitialize all the values
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	75	75	if map has already been created
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	84	84	update K value, then update potentials
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	86	86	check to make sure new_k is a positive double number
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	95	95	insert the goal or obstacle into a specific spot in the t_map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	100	101	std::cout << "goal or obstacle: " << T << std::endl;\nstd::cout << "index: (" << X << ", " << Y << std::endl;
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	104	104	update the potential for every index of the map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	106	106	for every index in the potential map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	108	108	i is x, j is y
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	110	110	reinitialize pot
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	112	112	for every index in t_map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	115	115	find if there is a goal, obstacle or nothing at that index
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	117	117	if nothing then continue
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	120	120	if goal or obstacle at same index as x y then continue
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	123	123	if it is a goal, calculate potential for a goal
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	125	125	calculate potential for specific index of map for this goal
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	127	127	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	130	130	calculate potential for specific index of map for this object
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	132	132	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	137	139	when done looping through t_map,\npot will have the sum of the potentials for that index in the value\nupdate the potential value in the map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	145	145	empty both the map and t_map 2D array
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.cpp	155	155	delete pointers to map and t_map
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.h	9	10	constructor to initialize values\ninitialize array, returns pointer to array, make this a constructor?
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.h	18	19	double pointer to map\ndouble pointer to map of obstacles/goals
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.h	21	23	put variables to calculate potential at spot depending on obstacle or goal\nfigure out what will input into this function so calculate potential\ndepending on other functions that will call it
5eb2f1a2	f24	p0	2024-09-23 13:01:01	potential.h	25	26	calculates potential, to be called from within other functions\nuse in point, move, update
5eb2f1a2	f24	p0	2024-09-23 13:06:11	main.cpp	18	18	call the function
5eb2f1a2	f24	p0	2024-09-23 13:06:11	main.cpp	25	25	call the function
5eb2f1a2	f24	p0	2024-09-23 13:06:11	main.cpp	31	31	call the function
5eb2f1a2	f24	p0	2024-09-23 13:06:11	main.cpp	35	35	call the function
5eb2f1a2	f24	p0	2024-09-23 13:06:11	main.cpp	40	40	call the function
5eb2f1a2	f24	p0	2024-09-23 13:06:11	main.cpp	44	44	call the function
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	5	5	constructor to initialize values
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	14	14	function to create the map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	16	17	check if this->map has been used since the constructor\nif it has, then delete it
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	22	22	assign values to this->
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	27	28	give new value to map and t_map\ninitialize 2D arrays
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	36	36	enter values of 0 and 'o' into arrays
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	42	43	add an obstacle or goal at certain position in grid\nthen recalculate potential for whole map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	45	45	if the x and y values given are within the map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	47	47	if they are, insert the char into the t_map at the x y index
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	49	49	update the potential with the new goal or obstacle
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	51	51	if not then output failure
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	53	54	std::cout << "X: " << X << " Y: " << Y << std::endl;\nstd::cout << "N: " << this->N << " M: " << this->M << std::endl;
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	59	59	give the potential at a certain spot in the map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	61	61	if the given X and Y are within the bounds of the map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	63	63	P is the potential at that index
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	72	72	reinitialize all the values
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	74	74	if map has already been created
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	83	83	update K value, then update potentials
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	85	85	check to make sure new_k is a positive double number
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	94	94	insert the goal or obstacle into a specific spot in the t_map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	102	103	std::cout << "goal or obstacle: " << T << std::endl;\nstd::cout << "index: (" << X << ", " << Y << std::endl;
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	106	106	update the potential for every index of the map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	108	108	for every index in the potential map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	110	110	i is x, j is y
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	112	112	reinitialize pot
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	114	114	for every index in t_map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	117	117	find if there is a goal, obstacle or nothing at that index
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	119	119	if nothing then continue
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	122	122	if goal or obstacle at same index as x y then continue
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	125	125	if it is a goal, calculate potential for a goal
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	127	127	calculate potential for specific index of map for this goal
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	129	129	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	132	132	calculate potential for specific index of map for this object
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	134	134	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	139	141	when done looping through t_map,\npot will have the sum of the potentials for that index in the value\nupdate the potential value in the map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	147	147	empty both the map and t_map 2D array
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.cpp	157	157	delete pointers to map and t_map
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.h	9	10	constructor to initialize values\ninitialize array, returns pointer to array, make this a constructor?
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.h	18	19	double pointer to map\ndouble pointer to map of obstacles/goals
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.h	21	23	put variables to calculate potential at spot depending on obstacle or goal\nfigure out what will input into this function so calculate potential\ndepending on other functions that will call it
5eb2f1a2	f24	p0	2024-09-23 13:06:11	potential.h	25	26	calculates potential, to be called from within other functions\nuse in point, move, update
5eb2f1a2	f24	p0	2024-09-23 19:31:31	main.cpp	18	18	call the function
5eb2f1a2	f24	p0	2024-09-23 19:31:31	main.cpp	25	25	call the function
5eb2f1a2	f24	p0	2024-09-23 19:31:31	main.cpp	31	31	call the function
5eb2f1a2	f24	p0	2024-09-23 19:31:31	main.cpp	35	35	call the function
5eb2f1a2	f24	p0	2024-09-23 19:31:31	main.cpp	40	40	call the function
5eb2f1a2	f24	p0	2024-09-23 19:31:31	main.cpp	44	44	call the function
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	5	5	constructor to initialize values
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	14	14	function to create the map
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	16	17	check if this->map has been used since the constructor\nif it has, then delete it
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	22	22	assign values to this->
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	27	28	give new value to map and t_map\ninitialize 2D arrays
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	36	36	enter values of 0 and 'o' into arrays
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	42	43	add an obstacle or goal at certain position in grid\nthen recalculate potential for whole map
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	45	45	if the x and y values given are within the map
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	47	47	if they are, insert the char into the t_map at the x y index
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	49	49	update the potential with the new goal or obstacle
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	53	53	if not then output failure
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	55	56	std::cout << "X: " << X << " Y: " << Y << std::endl;\nstd::cout << "N: " << this->N << " M: " << this->M << std::endl;
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	61	61	give the potential at a certain spot in the map
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	63	63	if the given X and Y are within the bounds of the map
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	65	65	P is the potential at that index
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	73	73	reinitialize all the values
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	75	75	if map has already been created
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	84	84	update K value, then update potentials
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	86	86	check to make sure new_k is a positive double number
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	95	95	update the potential for every index of the map
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	97	97	for every index in the potential map
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	99	99	i is x, j is y
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	101	101	reinitialize pot
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	103	103	for every index in t_map
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	106	106	find if there is a goal, obstacle or nothing at that index
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	108	108	if nothing then continue
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	111	111	if goal or obstacle at same index as x y then continue
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	114	114	if it is a goal, calculate potential for a goal
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	116	116	calculate potential for specific index of map for this goal
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	118	118	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	121	121	calculate potential for specific index of map for this object
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	123	123	add the value to the potential for the specific map index
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	128	130	when done looping through t_map,\npot will have the sum of the potentials for that index in the value\nupdate the potential value in the map
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	136	136	empty both the map and t_map 2D array
5eb2f1a2	f24	p0	2024-09-23 19:31:31	potential.cpp	146	146	delete pointers to map and t_map
653245a1	f24	p0	2024-09-19 19:17:42	lab0.cpp	42	42	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-19 19:17:42	lab0.cpp	51	51	increment i until a duplicate node is found or the top of the stack is reached
653245a1	f24	p0	2024-09-19 19:17:42	lab0.h	45	45	outputs potential vector at (x, y)
653245a1	f24	p0	2024-09-19 19:17:42	lab0.h	47	47	removes goals and obstacles, resets potentials
653245a1	f24	p0	2024-09-19 19:17:42	lab0.h	49	49	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-19 19:17:42	lab0.h	51	51	Updates K constant, call recalculate()
653245a1	f24	p0	2024-09-19 19:17:42	lab0.h	53	53	Recalculates potential
653245a1	f24	p0	2024-09-19 19:20:59	lab0.cpp	42	42	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-19 19:20:59	lab0.cpp	51	51	increment i until a duplicate node is found or the top of the stack is reached
653245a1	f24	p0	2024-09-19 19:20:59	lab0.h	45	45	outputs potential vector at (x, y)
653245a1	f24	p0	2024-09-19 19:20:59	lab0.h	47	47	removes goals and obstacles, resets potentials
653245a1	f24	p0	2024-09-19 19:20:59	lab0.h	49	49	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-19 19:20:59	lab0.h	51	51	Updates K constant, call recalculate()
653245a1	f24	p0	2024-09-19 19:20:59	lab0.h	53	53	Recalculates potential
653245a1	f24	p0	2024-09-19 19:27:36	lab0.cpp	42	42	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-19 19:27:36	lab0.cpp	51	51	increment i until a duplicate node is found or the top of the stack is reached
653245a1	f24	p0	2024-09-19 19:27:36	lab0.h	45	45	outputs potential vector at (x, y)
653245a1	f24	p0	2024-09-19 19:27:36	lab0.h	47	47	removes goals and obstacles, resets potentials
653245a1	f24	p0	2024-09-19 19:27:36	lab0.h	49	49	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-19 19:27:36	lab0.h	51	51	Updates K constant, call recalculate()
653245a1	f24	p0	2024-09-19 19:27:36	lab0.h	53	53	Recalculates potential
653245a1	f24	p0	2024-09-19 19:46:17	lab0.cpp	46	46	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-19 19:46:17	lab0.cpp	55	55	increment i until a duplicate node is found or the top of the stack is reached
653245a1	f24	p0	2024-09-19 19:46:17	lab0.h	45	45	outputs potential vector at (x, y)
653245a1	f24	p0	2024-09-19 19:46:17	lab0.h	47	47	removes goals and obstacles, resets potentials
653245a1	f24	p0	2024-09-19 19:46:17	lab0.h	49	49	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-19 19:46:17	lab0.h	51	51	Updates K constant, call recalculate()
653245a1	f24	p0	2024-09-19 19:46:17	lab0.h	53	53	Recalculates potential
653245a1	f24	p0	2024-09-23 16:58:57	lab0.cpp	46	46	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-23 16:58:57	lab0.cpp	55	55	increment i until a duplicate node is found or the top of the stack is reached
653245a1	f24	p0	2024-09-23 16:58:57	lab0.h	45	45	outputs potential vector at (x, y)
653245a1	f24	p0	2024-09-23 16:58:57	lab0.h	47	47	removes goals and obstacles, resets potentials
653245a1	f24	p0	2024-09-23 16:58:57	lab0.h	49	49	Add goal/obstacle, call recalculate()
653245a1	f24	p0	2024-09-23 16:58:57	lab0.h	51	51	Updates K constant, call recalculate()
653245a1	f24	p0	2024-09-23 16:58:57	lab0.h	53	53	Recalculates potential
6f4859f2	f24	p0	2024-09-23 20:28:27	PotentialFieldMap.h	27	27	POTENTIALFIELDMAP_H
6f4859f2	f24	p0	2024-09-23 20:28:27	Vector3.h	30	30	VECTOR3_H
71803a46	f24	p0	2024-09-22 13:39:32	main.cpp	2	2	#include "project0.cpp"
71803a46	f24	p0	2024-09-22 13:39:32	main.cpp	6	6	m_map.print();
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	2	2	temp
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	8	8	std::cout << "myGrid()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	15	15	std::cout << "~myGrid()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	36	36	std::cout << m_pot << std::endl;
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	54	54	Dynamic allocation
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	61	61	std::cout << "myMap(n,m)" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	72	72	std::cout << "~myMap()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	79	79	if the location is out of bounds
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	99	99	if (X,Y) are outside of the map
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	171	179	void myMap::print() {\nstd::cout << "Potential:" << std::endl;\nfor (int i = 0; i < m_dim[0]; i++) {\nfor (int j = 0; j < m_dim[1]; j++) {\ndouble* temp = m_map[i][j].getPot();\nstd::cout << "(" << temp[0] << ", " << temp[1] << ")  ";\n}\nstd::cout << std::endl;\n}
71803a46	f24	p0	2024-09-22 13:39:32	project0.cpp	181	189	std::cout << "Point:" << std::endl;\nfor (int i = 0; i < m_dim[0]; i++) {\nfor (int j = 0; j < m_dim[1]; j++) {\nint temp = m_map[i][j].getPoint();\nstd::cout << temp << " ";\n}\nstd::cout << std::endl;\n}\n}
71803a46	f24	p0	2024-09-22 13:39:32	project0.h	42	42	PROJECT0_H
71803a46	f24	p0	2024-09-22 13:47:01	main.cpp	2	2	#include "project0.cpp"
71803a46	f24	p0	2024-09-22 13:47:01	main.cpp	6	6	m_map.print();
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	2	2	temp
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	8	8	std::cout << "myGrid()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	15	15	std::cout << "~myGrid()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	36	36	std::cout << m_pot << std::endl;
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	54	54	Dynamic allocation
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	61	61	std::cout << "myMap(n,m)" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	72	72	std::cout << "~myMap()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	79	79	if the location is out of bounds
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	99	99	if (X,Y) are outside of the map
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	171	179	void myMap::print() {\nstd::cout << "Potential:" << std::endl;\nfor (int i = 0; i < m_dim[0]; i++) {\nfor (int j = 0; j < m_dim[1]; j++) {\ndouble* temp = m_map[i][j].getPot();\nstd::cout << "(" << temp[0] << ", " << temp[1] << ")  ";\n}\nstd::cout << std::endl;\n}
71803a46	f24	p0	2024-09-22 13:47:01	project0.cpp	181	189	std::cout << "Point:" << std::endl;\nfor (int i = 0; i < m_dim[0]; i++) {\nfor (int j = 0; j < m_dim[1]; j++) {\nint temp = m_map[i][j].getPoint();\nstd::cout << temp << " ";\n}\nstd::cout << std::endl;\n}\n}
71803a46	f24	p0	2024-09-22 13:47:01	project0.h	42	42	PROJECT0_H
71803a46	f24	p0	2024-09-22 13:48:01	main.cpp	2	2	#include "project0.cpp"
71803a46	f24	p0	2024-09-22 13:48:01	main.cpp	6	6	m_map.print();
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	2	2	temp
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	8	8	std::cout << "myGrid()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	15	15	std::cout << "~myGrid()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	36	36	std::cout << m_pot << std::endl;
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	54	54	Dynamic allocation
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	61	61	std::cout << "myMap(n,m)" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	72	72	std::cout << "~myMap()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	79	79	if the location is out of bounds
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	99	99	if (X,Y) are outside of the map
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	171	179	void myMap::print() {\nstd::cout << "Potential:" << std::endl;\nfor (int i = 0; i < m_dim[0]; i++) {\nfor (int j = 0; j < m_dim[1]; j++) {\ndouble* temp = m_map[i][j].getPot();\nstd::cout << "(" << temp[0] << ", " << temp[1] << ")  ";\n}\nstd::cout << std::endl;\n}
71803a46	f24	p0	2024-09-22 13:48:01	project0.cpp	181	189	std::cout << "Point:" << std::endl;\nfor (int i = 0; i < m_dim[0]; i++) {\nfor (int j = 0; j < m_dim[1]; j++) {\nint temp = m_map[i][j].getPoint();\nstd::cout << temp << " ";\n}\nstd::cout << std::endl;\n}\n}
71803a46	f24	p0	2024-09-22 13:48:01	project0.h	42	42	PROJECT0_H
71803a46	f24	p0	2024-09-22 14:04:35	main.cpp	2	2	#include "project0.cpp"
71803a46	f24	p0	2024-09-22 14:04:35	main.cpp	6	6	m_map.print();
71803a46	f24	p0	2024-09-22 14:04:35	project0.cpp	33	33	std::cout << m_pot << std::endl;
71803a46	f24	p0	2024-09-22 14:04:35	project0.cpp	51	51	Dynamic allocation
71803a46	f24	p0	2024-09-22 14:04:35	project0.cpp	58	58	std::cout << "myMap(n,m)" << std::endl; // temp
71803a46	f24	p0	2024-09-22 14:04:35	project0.cpp	69	69	std::cout << "~myMap()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 14:04:35	project0.cpp	76	76	if the location is out of bounds
71803a46	f24	p0	2024-09-22 14:04:35	project0.cpp	96	96	if (X,Y) are outside of the map
71803a46	f24	p0	2024-09-22 14:04:35	project0.h	42	42	PROJECT0_H
71803a46	f24	p0	2024-09-22 14:09:55	main.cpp	2	2	#include "project0.cpp"
71803a46	f24	p0	2024-09-22 14:09:55	main.cpp	6	6	m_map.print();
71803a46	f24	p0	2024-09-22 14:09:55	project0.cpp	33	33	std::cout << m_pot << std::endl;
71803a46	f24	p0	2024-09-22 14:09:55	project0.cpp	51	51	Dynamic allocation
71803a46	f24	p0	2024-09-22 14:09:55	project0.cpp	58	58	std::cout << "myMap(n,m)" << std::endl; // temp
71803a46	f24	p0	2024-09-22 14:09:55	project0.cpp	69	69	std::cout << "~myMap()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 14:09:55	project0.cpp	76	76	if the location is out of bounds
71803a46	f24	p0	2024-09-22 14:09:55	project0.cpp	96	96	if (X,Y) are outside of the map
71803a46	f24	p0	2024-09-22 14:09:55	project0.h	42	42	PROJECT0_H
71803a46	f24	p0	2024-09-22 23:48:24	main.cpp	2	2	#include "project0.cpp"
71803a46	f24	p0	2024-09-22 23:48:24	main.cpp	6	6	m_map.print();
71803a46	f24	p0	2024-09-22 23:48:24	project0.cpp	33	33	std::cout << m_pot << std::endl;
71803a46	f24	p0	2024-09-22 23:48:24	project0.cpp	51	51	Dynamic allocation
71803a46	f24	p0	2024-09-22 23:48:24	project0.cpp	58	58	std::cout << "myMap(n,m)" << std::endl; // temp
71803a46	f24	p0	2024-09-22 23:48:24	project0.cpp	69	69	std::cout << "~myMap()" << std::endl; // temp
71803a46	f24	p0	2024-09-22 23:48:24	project0.cpp	76	76	if the location is out of bounds
71803a46	f24	p0	2024-09-22 23:48:24	project0.cpp	96	96	if (X,Y) are outside of the map
71803a46	f24	p0	2024-09-22 23:48:24	project0.h	42	42	PROJECT0_H
71803a46	f24	p0	2024-09-23 11:07:01	main.cpp	2	2	#include "project0.cpp"
71803a46	f24	p0	2024-09-23 11:07:01	main.cpp	6	6	m_map.print();
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	33	33	std::cout << m_pot << std::endl;
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	51	51	Dynamic allocation
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	58	58	std::cout << "myMap(n,m)" << std::endl; // temp
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	69	69	std::cout << "~myMap()" << std::endl; // temp
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	72	78	void myMap::point(char t, int x, int y) {\nif (isInside(x, y, m_dim[0], m_dim[1])) {\nm_map[x][y].setPoint(t);\n} else {\nstd::cout << "failure" << std::endl; // if the location is out of bounds\n}\n}
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	87	87	if state stays same
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	89	89	if 0->O/G, add new pot
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	91	91	if O->G or G->O, cancel the original pot and add the new pot
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	103	103	if the location is out of bounds
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	112	112	if (X,Y) are outside of the map
71803a46	f24	p0	2024-09-23 11:07:01	project0.cpp	116	134	void myMap::move(int x, int y) {\nif (isInside(x, y, m_dim[0], m_dim[1])) {\nm_map[x][y].clearPot();\nfor (int i = 0; i < m_dim[0]; i++) {\nfor (int j = 0; j < m_dim[1]; j++) {\nif (i == x && j == y) {\ncontinue;\n}\nint state = m_map[i][j].getPoint();\nif (state != 0) {\nm_map[x][y].addPot(calcPot(x, y, i, j, k, state));\n}\n}\n}\nstd::cout << m_map[x][y].getPot()[0] << " " << m_map[x][y].getPot()[1] << std::endl;\n} else {\nstd::cout << "failure" << std::endl; // if (X,Y) are outside of the map\n}\n}
71803a46	f24	p0	2024-09-23 11:07:01	project0.h	42	42	PROJECT0_H
71803a46	f24	p0	2024-09-23 22:40:09	main.cpp	5	5	m_map.print();
71803a46	f24	p0	2024-09-23 22:40:09	project0.cpp	50	50	Dynamic allocation
71803a46	f24	p0	2024-09-23 22:40:09	project0.cpp	75	75	if state stays same
71803a46	f24	p0	2024-09-23 22:40:09	project0.cpp	77	77	if 0->O/G, add new pot
71803a46	f24	p0	2024-09-23 22:40:09	project0.cpp	79	79	if O->G or G->O, cancel the original pot and add the new pot
71803a46	f24	p0	2024-09-23 22:40:09	project0.cpp	91	91	if the location is out of bounds
71803a46	f24	p0	2024-09-23 22:40:09	project0.cpp	100	100	if (X,Y) are outside of the map
71803a46	f24	p0	2024-09-23 22:40:09	project0.hpp	42	42	PROJECT0_H
71eef3bf	f24	p0	2024-09-23 00:32:32	main.cpp	26	26	Creates a map of size N x M
71eef3bf	f24	p0	2024-09-23 00:32:32	main.cpp	115	115	Read parameters X and Y
71eef3bf	f24	p0	2024-09-23 00:32:32	main.cpp	120	120	Read the value of K
71eef3bf	f24	p0	2024-09-23 00:32:32	main.cpp	125	125	Clear the map
71eef3bf	f24	p0	2024-09-23 00:45:00	main.cpp	26	26	Creates a map of size N x M
71eef3bf	f24	p0	2024-09-23 00:45:00	main.cpp	115	115	Read parameters X and Y
71eef3bf	f24	p0	2024-09-23 00:45:00	main.cpp	120	120	Read the value of K
71eef3bf	f24	p0	2024-09-23 00:45:00	main.cpp	125	125	Clear the map
71eef3bf	f24	p0	2024-09-23 00:49:16	main.cpp	26	26	Creates a map of size N x M
71eef3bf	f24	p0	2024-09-23 00:49:16	main.cpp	115	115	Read parameters X and Y
71eef3bf	f24	p0	2024-09-23 00:49:16	main.cpp	120	120	Read the value of K
71eef3bf	f24	p0	2024-09-23 00:49:16	main.cpp	125	125	Clear the map
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	5	5	Constructor
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	13	13	Destructor
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	18	18	Delete the map
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	34	34	Create the map
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	46	47	Initialize potential to 0\nInitialize status
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	53	53	Set a point as goal or obstacle
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	61	61	Set goal
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	63	63	Set obstacle
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	65	65	Update potentials
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	69	69	Move to a point and output its potential
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	78	78	Update the potentials with new K
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	86	86	Reset all potentials to zero
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	93	93	Compute the total potential at each point
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	98	98	For each goal or obstacle in the map
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	101	101	There is a goal or obstacle at (gx, gy)
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	103	103	Skip if same point
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	107	107	Goal
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	109	109	Obstacle
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	123	123	Clear the map
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	130	130	Reset all values in the map
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	133	134	Reset potential\nClear obstacle/goal status
71eef3bf	f24	p0	2024-09-23 16:02:29	main.cpp	140	140	Main function
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	5	5	Constructor
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	13	13	Destructor
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	18	18	Delete the map
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	34	34	Create the map
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	46	47	Initialize potential to 0\nInitialize status
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	53	53	Set a point as goal or obstacle
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	61	61	Set goal
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	63	63	Set obstacle
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	65	65	Update potentials
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	69	69	Move to a point and output its potential
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	78	78	Update the potentials with new K
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	86	86	Reset all potentials to zero
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	93	93	Compute the total potential at each point
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	98	98	For each goal or obstacle in the map
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	101	101	There is a goal or obstacle at (gx, gy)
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	103	103	Skip if same point
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	107	107	Goal
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	109	109	Obstacle
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	123	123	Clear the map
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	130	130	Reset all values in the map
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	133	134	Reset potential\nClear obstacle/goal status
71eef3bf	f24	p0	2024-09-23 16:04:45	main.cpp	140	140	Main function
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	6	6	Constructor
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	8	8	Initialize N
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	11	11	Initialize map to nullptr
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	14	14	Destructor
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	16	16	Delete the map
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	19	19	Delete the map
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	25	25	Delete the innermost array
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	31	31	Set map to nullptr
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	35	35	Create the map
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	39	39	Set N
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	43	43	Create the map
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	47	48	Initialize potential to 0\nInitialize status
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	51	51	Print success
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	54	54	Recompute potentials without changing K
71eef3bf	f24	p0	2024-09-23 17:32:40	main.cpp	140	140	Main function
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	6	6	Constructor
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	8	8	Initialize N
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	11	11	Initialize map to nullptr
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	14	14	Destructor
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	16	16	Delete the map
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	19	19	Delete the map
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	25	25	Delete the innermost array
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	31	31	Set map to nullptr
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	35	35	Create the map
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	39	39	Set N
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	43	43	Create the map
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	47	48	Initialize potential to 0\nInitialize status
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	51	51	Print success
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	54	54	Recompute potentials without changing K
71eef3bf	f24	p0	2024-09-23 20:01:47	main.cpp	140	140	Main function
767b4db1	f24	p0	2024-09-22 17:27:32	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	10	11	destructor\ndelete the board
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	23	23	deleting goal, obstacle
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	27	27	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	31	31	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	37	37	if goal, return negative value
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	39	39	if obstacle, return positive value
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	41	41	if nothing, return 0
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	47	47	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	54	54	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	61	61	COMMANDS
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	69	70	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	74	74	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	80	81	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	89	89	if x and y is out of the board
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	111	111	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	118	118	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	121	122	if not, kConst is changed to a new k\ncall the functiom
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	127	127	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.cpp	132	132	END COMMANDS
767b4db1	f24	p0	2024-09-22 17:27:32	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-22 17:43:30	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	10	11	destructor\ndelete the board
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	23	23	deleting goal, obstacle
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	27	27	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	31	31	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	37	37	if goal, return negative value
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	39	39	if obstacle, return positive value
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	41	41	if nothing, return 0
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	47	47	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	54	54	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	61	61	COMMANDS
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	69	70	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	74	74	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	80	81	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	89	89	if x and y is out of the board
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	111	111	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	118	118	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	121	122	if not, kConst is changed to a new k\ncall the functiom
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	127	127	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.cpp	132	132	END COMMANDS
767b4db1	f24	p0	2024-09-22 17:43:30	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-22 17:44:33	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	10	11	destructor\ndelete the board
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	23	23	deleting goal, obstacle
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	27	27	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	31	31	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	37	37	if goal, return negative value
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	39	39	if obstacle, return positive value
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	41	41	if nothing, return 0
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	47	47	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	54	54	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	61	61	COMMANDS
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	69	70	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	74	74	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	80	81	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	89	89	if x and y is out of the board
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	111	111	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	118	118	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	121	122	if not, kConst is changed to a new k\ncall the functiom
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	127	127	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.cpp	132	132	END COMMANDS
767b4db1	f24	p0	2024-09-22 17:44:33	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-22 17:48:14	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	10	11	destructor\ndelete the board
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	23	23	deleting goal, obstacle
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	27	27	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	31	31	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	37	37	if goal, return negative value
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	39	39	if obstacle, return positive value
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	41	41	if nothing, return 0
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	47	47	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	54	54	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	61	61	COMMANDS
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	69	70	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	74	74	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	80	81	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	89	89	if x and y is out of the board
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	111	111	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	118	118	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	121	122	if not, kConst is changed to a new k\ncall the functiom
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	127	127	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.cpp	132	132	END COMMANDS
767b4db1	f24	p0	2024-09-22 17:48:14	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-22 17:59:46	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	10	11	destructor\ndelete the board
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	23	23	deleting goal, obstacle
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	27	27	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	31	31	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	37	37	if goal, return negative value
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	39	39	if obstacle, return positive value
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	41	41	if nothing, return 0
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	47	47	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	54	54	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	61	61	COMMANDS
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	69	70	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	74	74	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	80	81	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	89	89	if x and y is out of the board
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	111	111	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	118	118	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	121	122	if not, kConst is changed to a new k\ncall the functiom
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	127	127	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.cpp	133	133	END COMMANDS
767b4db1	f24	p0	2024-09-22 17:59:46	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-22 18:02:41	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	10	11	destructor\ndelete the board
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	23	23	deleting goal, obstacle
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	27	27	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	31	31	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	37	37	if goal, return negative value
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	39	39	if obstacle, return positive value
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	41	41	if nothing, return 0
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	47	47	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	54	54	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	61	61	COMMANDS
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	69	70	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	74	74	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	80	81	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	89	89	if x and y is out of the board
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	111	111	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	118	118	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	121	122	if not, kConst is changed to a new k\ncall the functiom
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	127	127	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.cpp	133	133	END COMMANDS
767b4db1	f24	p0	2024-09-22 18:02:41	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-22 18:27:47	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	10	11	destructor\ndelete the board
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	23	23	deleting goal, obstacle
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	27	27	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	31	31	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	37	37	if goal, return negative value
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	39	39	if obstacle, return positive value
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	41	41	if nothing, return 0
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	47	47	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	54	54	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	61	61	COMMANDS
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	77	78	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	82	82	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	88	89	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	97	97	if x and y is out of the board
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	120	120	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	130	130	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	133	134	if not, kConst is changed to a new k\ncall the functiom
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	139	139	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.cpp	144	144	END COMMANDS
767b4db1	f24	p0	2024-09-22 18:27:47	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-23 00:27:19	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	8	8	Initialize to nullptr
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	26	26	deleting goal, obstacle
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	31	31	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	35	35	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	41	41	if goal, return negative value
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	43	43	if obstacle, return positive value
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	45	45	if nothing, return 0
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	51	51	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	60	60	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	63	63	Resetting potential to 0
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	73	73	COMMANDS
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	83	84	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	88	88	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	93	94	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	102	102	if x and y is out of the board
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	123	123	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	134	134	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	137	138	if not, kConst is changed to a new k\ncall the function
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.cpp	144	144	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-23 00:27:19	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-23 00:31:27	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	8	8	Initialize to nullptr
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	29	29	deleting goal, obstacle
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	34	34	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	38	38	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	44	44	if goal, return negative value
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	46	46	if obstacle, return positive value
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	48	48	if nothing, return 0
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	54	54	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	63	63	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	66	66	Resetting potential to 0
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	76	76	COMMANDS
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	86	87	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	91	91	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	96	97	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	105	105	if x and y is out of the board
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	126	126	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	137	137	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	140	141	if not, kConst is changed to a new k\ncall the function
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.cpp	147	147	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-23 00:31:27	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-23 00:33:59	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	8	8	Initialize to nullptr
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	29	29	deleting goal, obstacle
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	34	34	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	38	38	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	44	44	if goal, return negative value
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	46	46	if obstacle, return positive value
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	48	48	if nothing, return 0
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	54	54	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	63	63	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	66	66	Resetting potential to 0
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	76	76	COMMANDS
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	86	87	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	91	91	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	96	97	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	105	105	if x and y is out of the board
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	126	126	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	137	137	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	140	141	if not, kConst is changed to a new k\ncall the function
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.cpp	147	147	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-23 00:33:59	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-23 15:03:02	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	8	8	Initialize to nullptr
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	29	29	deleting goal, obstacle
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	34	34	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	38	38	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	44	44	if goal, return negative value
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	46	46	if obstacle, return positive value
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	48	48	if nothing, return 0
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	54	54	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	63	63	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	66	66	Resetting potential to 0
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	76	76	COMMANDS
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	86	87	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	91	91	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	96	97	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	105	105	if x and y is out of the board
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	126	126	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	137	137	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	140	141	if not, kConst is changed to a new k\ncall the function
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.cpp	147	147	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-23 15:03:02	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-09-23 15:12:43	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	8	8	Initialize to nullptr
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	29	29	deleting goal, obstacle
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	34	34	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	38	38	if denominator is 0, return 0
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	44	44	if goal, return negative value
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	46	46	if obstacle, return positive value
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	48	48	if nothing, return 0
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	54	54	going through each point and changing the potential value
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	63	63	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	66	66	Resetting potential to 0
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	76	76	COMMANDS
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	86	87	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	91	91	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	96	97	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	105	105	if x and y is out of the board
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	126	126	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	137	137	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	140	141	if not, kConst is changed to a new k\ncall the function
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.cpp	147	147	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-09-23 15:12:43	robot_environment.h	4	5	constructor\ndestructor
767b4db1	f24	p0	2024-10-05 18:23:53	main.cpp	7	10	nRows and mColumns\nx and y position\nk constant\nrepresenting goal, obstacle, or nothing
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	8	8	Initialize to nullptr
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	29	29	deleting goal, obstacle
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	34	34	CALCULATING THE POTENTIAL
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	38	38	if denominator is 0, return 0
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	44	44	if goal, return negative value
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	46	46	if obstacle, return positive value
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	48	48	if nothing, return 0
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	54	54	going through each point and changing the potential value
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	63	63	calculating the whole grid with one function (it links to other calculating functions)
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	66	66	Resetting potential to 0
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	76	76	COMMANDS
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	86	87	creating new board with n values of rows, m values of column\nit is currently a 1D array; storing n pointers
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	91	91	this is to ensure that each element is pointing to an array with m elements
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	96	97	initializing the potential value to zero\nN stands for nothing, initializing the "item" at each point to nothing
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	105	105	if x and y is out of the board
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	126	126	clearing all potential values as well as the item in each point
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	137	137	if k is negative or zero, it is a fail
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	140	141	if not, kConst is changed to a new k\ncall the function
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.cpp	147	147	if this function is called then exitsign changes to true and breaks out of the loop
767b4db1	f24	p0	2024-10-05 18:23:53	robot_environment.h	4	5	constructor\ndestructor
76b519eb	f24	p0	2024-09-09 19:48:15	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:48:15	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:48:15	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:48:15	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:48:15	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:48:15	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:48:15	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:48:15	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:48:15	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:48:15	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:48:15	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:48:15	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:48:15	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:48:15	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:48:15	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 19:49:42	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:49:42	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:49:42	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:49:42	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:49:42	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:49:42	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:49:42	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:49:42	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:49:42	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:49:42	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:49:42	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:49:42	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:49:42	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:49:42	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:49:42	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 19:49:57	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:49:57	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:49:57	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:49:57	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:49:57	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:49:57	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:49:57	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:49:57	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:49:57	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:49:57	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:49:57	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:49:57	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:49:57	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:49:57	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:49:57	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 19:50:24	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:50:24	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:50:24	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:50:24	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:50:24	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:50:24	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:50:24	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:50:24	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:50:24	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:50:24	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:50:24	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:50:24	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:50:24	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:50:24	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:50:24	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 19:51:20	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:51:20	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:51:20	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:51:20	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:51:20	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:51:20	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:51:20	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:51:20	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:51:20	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:51:20	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:51:20	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:51:20	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:51:20	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:51:20	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:51:20	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 19:51:28	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:51:28	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:51:28	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:51:28	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:51:28	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:51:28	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:51:28	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:51:28	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:51:28	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:51:28	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:51:28	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:51:28	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:51:28	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:51:28	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:51:28	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 19:51:34	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:51:34	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:51:34	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:51:34	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:51:34	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:51:34	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:51:34	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:51:34	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:51:34	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:51:34	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:51:34	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:51:34	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:51:34	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:51:34	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:51:34	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 19:52:27	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:52:27	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:52:27	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:52:27	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:52:27	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:52:27	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:52:27	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:52:27	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:52:27	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:52:27	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:52:27	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:52:27	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:52:27	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:52:27	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:52:27	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 19:54:37	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:54:37	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:54:37	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:54:37	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:54:37	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:54:37	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:54:37	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:54:37	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:54:37	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:54:37	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:54:37	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:54:37	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:54:37	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:54:37	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:54:37	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 19:59:07	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 19:59:07	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 19:59:07	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 19:59:07	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 19:59:07	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 19:59:07	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 19:59:07	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 19:59:07	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 19:59:07	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 19:59:07	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 19:59:07	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 19:59:07	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 19:59:07	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 19:59:07	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 19:59:07	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 20:06:52	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 20:06:52	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 20:06:52	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 20:06:52	potentialField.cpp	40	40	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 20:06:52	potentialField.cpp	44	44	right sign
76b519eb	f24	p0	2024-09-09 20:06:52	potentialField.h	11	11	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 20:06:52	potentialField.h	13	13	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 20:06:52	potentialField.h	15	15	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 20:06:52	potentialField.h	17	17	Clears the map
76b519eb	f24	p0	2024-09-09 20:06:52	potentialField.h	19	19	Updates the constant k
76b519eb	f24	p0	2024-09-09 20:06:52	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 20:06:52	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 20:06:52	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 20:06:52	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 20:06:52	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-09 20:27:29	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-09 20:27:29	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-09 20:27:29	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-09 20:27:29	potentialField.cpp	41	41	0 distance attraction is 0
76b519eb	f24	p0	2024-09-09 20:27:29	potentialField.cpp	45	45	right sign
76b519eb	f24	p0	2024-09-09 20:27:29	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-09 20:27:29	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-09 20:27:29	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-09 20:27:29	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-09 20:27:29	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-09 20:27:29	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-09 20:27:29	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-09 20:27:29	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-09 20:27:29	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-09 20:27:29	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-10 12:52:35	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-10 12:52:35	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-10 12:52:35	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-10 12:52:35	potentialField.cpp	41	41	0 distance attraction is 0
76b519eb	f24	p0	2024-09-10 12:52:35	potentialField.cpp	45	45	right sign
76b519eb	f24	p0	2024-09-10 12:52:35	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-10 12:52:35	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-10 12:52:35	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-10 12:52:35	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-10 12:52:35	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-10 12:52:35	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-10 12:52:35	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-10 12:52:35	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-10 12:52:35	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-10 12:52:35	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-10 20:09:18	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-10 20:09:18	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-10 20:09:18	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-10 20:09:18	potentialField.cpp	26	26	check for uniqueness
76b519eb	f24	p0	2024-09-10 20:09:18	potentialField.cpp	50	50	0 distance attraction is 0
76b519eb	f24	p0	2024-09-10 20:09:18	potentialField.cpp	54	54	right sign
76b519eb	f24	p0	2024-09-10 20:09:18	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-10 20:09:18	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-10 20:09:18	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-10 20:09:18	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-10 20:09:18	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-10 20:09:18	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-10 20:09:18	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-10 20:09:18	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-10 20:09:18	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-10 20:09:18	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-10 20:12:25	main.cpp	45	45	consume the rest of the line
76b519eb	f24	p0	2024-09-10 20:12:25	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-10 20:12:25	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-10 20:12:25	potentialField.cpp	25	25	check for uniqueness
76b519eb	f24	p0	2024-09-10 20:12:25	potentialField.cpp	50	50	0 distance attraction is 0
76b519eb	f24	p0	2024-09-10 20:12:25	potentialField.cpp	54	54	right sign
76b519eb	f24	p0	2024-09-10 20:12:25	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-10 20:12:25	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-10 20:12:25	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-10 20:12:25	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-10 20:12:25	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-10 20:12:25	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-10 20:12:25	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-10 20:12:25	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-10 20:12:25	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-10 20:12:25	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-11 14:52:32	main.cpp	8	9	#define DEBUG_VISUALIZATION\n#define REPLACE
76b519eb	f24	p0	2024-09-11 14:52:32	main.cpp	47	47	consume the rest of the line
76b519eb	f24	p0	2024-09-11 14:52:32	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-11 14:52:32	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-11 14:52:32	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-11 14:52:32	potentialField.cpp	53	53	0 distance attraction is 0
76b519eb	f24	p0	2024-09-11 14:52:32	potentialField.cpp	57	57	right sign
76b519eb	f24	p0	2024-09-11 14:52:32	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-11 14:52:32	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-11 14:52:32	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-11 14:52:32	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-11 14:52:32	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-11 14:52:32	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-11 14:52:32	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-11 14:52:32	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-11 14:52:32	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-11 14:52:32	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-11 14:54:35	main.cpp	8	9	#define DEBUG_VISUALIZATION\n#define REPLACE
76b519eb	f24	p0	2024-09-11 14:54:35	main.cpp	47	47	consume the rest of the line
76b519eb	f24	p0	2024-09-11 14:54:35	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-11 14:54:35	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-11 14:54:35	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-11 14:54:35	potentialField.cpp	53	53	0 distance attraction is 0
76b519eb	f24	p0	2024-09-11 14:54:35	potentialField.cpp	57	57	right sign
76b519eb	f24	p0	2024-09-11 14:54:35	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-11 14:54:35	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-11 14:54:35	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-11 14:54:35	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-11 14:54:35	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-11 14:54:35	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-11 14:54:35	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-11 14:54:35	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-11 14:54:35	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-11 14:54:35	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-11 14:56:32	main.cpp	8	8	#define DEBUG_VISUALIZATION
76b519eb	f24	p0	2024-09-11 14:56:32	main.cpp	47	47	consume the rest of the line
76b519eb	f24	p0	2024-09-11 14:56:32	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-11 14:56:32	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-11 14:56:32	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-11 14:56:32	potentialField.cpp	53	53	0 distance attraction is 0
76b519eb	f24	p0	2024-09-11 14:56:32	potentialField.cpp	57	57	right sign
76b519eb	f24	p0	2024-09-11 14:56:32	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-11 14:56:32	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-11 14:56:32	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-11 14:56:32	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-11 14:56:32	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-11 14:56:32	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-11 14:56:32	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-11 14:56:32	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-11 14:56:32	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-11 14:56:32	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-11 14:56:52	main.cpp	8	8	#define DEBUG_VISUALIZATION
76b519eb	f24	p0	2024-09-11 14:56:52	main.cpp	47	47	consume the rest of the line
76b519eb	f24	p0	2024-09-11 14:56:52	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-11 14:56:52	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-11 14:56:52	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-11 14:56:52	potentialField.cpp	53	53	0 distance attraction is 0
76b519eb	f24	p0	2024-09-11 14:56:52	potentialField.cpp	57	57	right sign
76b519eb	f24	p0	2024-09-11 14:56:52	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-11 14:56:52	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-11 14:56:52	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-11 14:56:52	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-11 14:56:52	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-11 14:56:52	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-11 14:56:52	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-11 14:56:52	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-11 14:56:52	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-11 14:56:52	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-13 12:52:03	main.cpp	8	8	#define DEBUG_VISUALIZATION
76b519eb	f24	p0	2024-09-13 12:52:03	main.cpp	47	47	consume the rest of the line
76b519eb	f24	p0	2024-09-13 12:52:03	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-13 12:52:03	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-13 12:52:03	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-13 12:52:03	potentialField.cpp	53	53	0 distance attraction is 0
76b519eb	f24	p0	2024-09-13 12:52:03	potentialField.cpp	57	57	right sign
76b519eb	f24	p0	2024-09-13 12:52:03	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-13 12:52:03	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-13 12:52:03	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-13 12:52:03	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-13 12:52:03	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-13 12:52:03	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-13 12:52:03	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-13 12:52:03	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-13 12:52:03	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-13 12:52:03	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-13 12:54:08	main.cpp	8	8	#define DEBUG_VISUALIZATION
76b519eb	f24	p0	2024-09-13 12:54:08	main.cpp	46	46	consume the rest of the line
76b519eb	f24	p0	2024-09-13 12:54:08	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-13 12:54:08	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-13 12:54:08	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-13 12:54:08	potentialField.cpp	51	51	0 distance attraction is 0
76b519eb	f24	p0	2024-09-13 12:54:08	potentialField.cpp	55	55	right sign
76b519eb	f24	p0	2024-09-13 12:54:08	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-13 12:54:08	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-13 12:54:08	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-13 12:54:08	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-13 12:54:08	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-13 12:54:08	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-13 12:54:08	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-13 12:54:08	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-13 12:54:08	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-13 12:54:08	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-13 13:24:04	main.cpp	8	8	#define DEBUG_VISUALIZATION
76b519eb	f24	p0	2024-09-13 13:24:04	main.cpp	46	46	consume the rest of the line
76b519eb	f24	p0	2024-09-13 13:24:04	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-13 13:24:04	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-13 13:24:04	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-13 13:24:04	potentialField.cpp	51	51	0 distance attraction is 0
76b519eb	f24	p0	2024-09-13 13:24:04	potentialField.cpp	55	55	right sign
76b519eb	f24	p0	2024-09-13 13:24:04	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-13 13:24:04	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-13 13:24:04	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-13 13:24:04	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-13 13:24:04	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-13 13:24:04	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-13 13:24:04	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-13 13:24:04	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-13 13:24:04	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-13 13:24:04	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-13 13:26:34	main.cpp	44	44	consume the rest of the line
76b519eb	f24	p0	2024-09-13 13:26:34	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-13 13:26:34	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-13 13:26:34	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-13 13:26:34	potentialField.cpp	51	51	0 distance attraction is 0
76b519eb	f24	p0	2024-09-13 13:26:34	potentialField.cpp	55	55	right sign
76b519eb	f24	p0	2024-09-13 13:26:34	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-13 13:26:34	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-13 13:26:34	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-13 13:26:34	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-13 13:26:34	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-13 13:26:34	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-13 13:26:34	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-13 13:26:34	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-13 13:26:34	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-13 13:26:34	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-13 13:30:51	main.cpp	44	44	consume the rest of the line
76b519eb	f24	p0	2024-09-13 13:30:51	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-13 13:30:51	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-13 13:30:51	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-13 13:30:51	potentialField.cpp	51	51	0 distance attraction is 0
76b519eb	f24	p0	2024-09-13 13:30:51	potentialField.cpp	55	55	right sign
76b519eb	f24	p0	2024-09-13 13:30:51	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-13 13:30:51	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-13 13:30:51	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-13 13:30:51	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-13 13:30:51	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-13 13:30:51	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-13 13:30:51	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-13 13:30:51	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-13 13:30:51	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-13 13:30:51	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
76b519eb	f24	p0	2024-09-13 13:46:15	main.cpp	44	44	consume the rest of the line
76b519eb	f24	p0	2024-09-13 13:46:15	oirt.h	3	3	God's worst trio implementation that is also not just a naked struct for some reason
76b519eb	f24	p0	2024-09-13 13:46:15	oirt.h	10	10	https://thedailywtf.com/articles/What_Is_Truth_0x3f_
76b519eb	f24	p0	2024-09-13 13:46:15	potentialField.cpp	26	26	check if the spot is occupied
76b519eb	f24	p0	2024-09-13 13:46:15	potentialField.cpp	51	51	0 distance attraction is 0
76b519eb	f24	p0	2024-09-13 13:46:15	potentialField.cpp	55	55	right sign
76b519eb	f24	p0	2024-09-13 13:46:15	potentialField.h	12	12	Creates (or refreshes) the map
76b519eb	f24	p0	2024-09-13 13:46:15	potentialField.h	14	14	Adds an obstacle or a goal to the map
76b519eb	f24	p0	2024-09-13 13:46:15	potentialField.h	16	16	Returns the potential field value at the given point
76b519eb	f24	p0	2024-09-13 13:46:15	potentialField.h	18	18	Clears the map
76b519eb	f24	p0	2024-09-13 13:46:15	potentialField.h	20	20	Updates the constant k
76b519eb	f24	p0	2024-09-13 13:46:15	rotcev.h	37	37	allocate space for the first time
76b519eb	f24	p0	2024-09-13 13:46:15	rotcev.h	45	45	easy street just add the element bro
76b519eb	f24	p0	2024-09-13 13:46:15	rotcev.h	48	49	now we're in deep shit and gotta move everything\nallocation strategy is doubling every time (mimicing default vector)
76b519eb	f24	p0	2024-09-13 13:46:15	rotcev.h	76	78	this tricks the container into overwriting existing data without reallocating\ngod's worst safeguard against spamming creates\nalso faster to recover from a clear
76b519eb	f24	p0	2024-09-13 13:46:15	rotcev.h	84	86	technically this is only called on program end so there's no point\nbut I wrote deallocate() before thinking of empty() so I might as well\nuse it somewhere
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	25	25	which xvalue to use?
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	30	30	if statement
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	43	44	yvalue\nxvalue
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	47	47	end of Create
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	58	58	skips O or G point
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	72	72	Statements to ensure that obstacles or goals are overwritten
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	74	74	if a goal is being overwritten
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	78	78	if an obstacle is being overwritten
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	85	85	end of Point
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	101	101	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	115	115	end update
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	117	117	See if coordinates are within map
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	120	120	end of function
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	122	122	Checks if there was a previous map
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	130	130	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields_helper.cpp	133	133	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	18	18	Constructor
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	21	21	Destructor
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	24	24	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	27	27	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	30	30	Move to value to speficic area
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	33	33	Clear the board
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	36	36	Update the K value
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	39	39	Check if point is in array
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	42	42	Check if the board is filled or not
79f03c23	f24	p0	2024-09-22 12:06:06	PotentialFields.h	45	45	Calculate potential between points
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	25	25	which xvalue to use?
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	30	30	if statement
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	43	44	yvalue\nxvalue
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	47	47	end of Create
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	58	58	skips O or G point
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	72	72	Statements to ensure that obstacles or goals are overwritten
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	74	74	if a goal is being overwritten
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	78	78	if an obstacle is being overwritten
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	85	85	end of Point
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	101	101	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	115	115	end update
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	117	117	See if coordinates are within map
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	120	120	end of function
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	122	122	Checks if there was a previous map
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	130	130	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields_helper.cpp	133	133	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	18	18	Constructor
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	21	21	Destructor
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	24	24	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	27	27	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	30	30	Move to value to speficic area
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	33	33	Clear the board
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	36	36	Update the K value
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	39	39	Check if point is in array
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	42	42	Check if the board is filled or not
79f03c23	f24	p0	2024-09-22 12:31:02	PotentialFields.h	45	45	Calculate potential between points
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	25	25	which xvalue to use?
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	30	30	if statement
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	43	44	yvalue\nxvalue
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	47	47	end of Create
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	58	58	skips O or G point
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	72	72	Statements to ensure that obstacles or goals are overwritten
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	74	74	if a goal is being overwritten
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	78	78	if an obstacle is being overwritten
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	85	85	end of Point
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	101	101	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	115	115	end update
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	117	117	See if coordinates are within map
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	120	120	end of function
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	122	122	Checks if there was a previous map
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	130	130	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields_helper.cpp	133	133	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	18	18	Constructor
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	21	21	Destructor
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	24	24	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	27	27	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	30	30	Move to value to speficic area
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	33	33	Clear the board
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	36	36	Update the K value
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	39	39	Check if point is in array
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	42	42	Check if the board is filled or not
79f03c23	f24	p0	2024-09-22 17:17:10	PotentialFields.h	45	45	Calculate potential between points
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	25	25	which xvalue to use?
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	30	30	if statement
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	43	44	yvalue\nxvalue
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	47	47	end of Create
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	58	58	skips O or G point
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	72	72	Statements to ensure that obstacles or goals are overwritten
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	74	76	If a goal is being set\nCheck if there's already an obstacle\nOverwrite with goal potential
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	78	78	Add goal potential
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	82	84	If an obstacle is being set\nCheck if there's already a goal\nKeep the obstacle
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	86	86	Add obstacle potential
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	93	93	end of Point
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	109	109	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	123	123	end update
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	125	125	See if coordinates are within map
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	128	128	end of function
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	130	130	Checks if there was a previous map
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	138	138	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields_helper.cpp	141	141	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	18	18	Constructor
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	21	21	Destructor
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	24	24	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	27	27	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	30	30	Move to value to speficic area
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	33	33	Clear the board
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	36	36	Update the K value
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	39	39	Check if point is in array
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	42	42	Check if the board is filled or not
79f03c23	f24	p0	2024-09-22 19:29:50	PotentialFields.h	45	45	Calculate potential between points
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	7	7	Default constructor
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	25	25	delete xvalue
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	28	30	delete remaining elements\nset pointer to nullptr\nend if statement
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	32	32	setting parameters with respective member variables
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	36	36	Creating new board with respect to new dimensions
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	45	46	yvalue\nxvalue
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	49	49	end of Create
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	53	53	create new array to account for "G" or "O"
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	56	56	Determines if specified coordinate is valid or not
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	58	58	Remove potential contribution of the old object
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	63	63	skips the specified coordinate
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	66	66	Add back the removed goal potential
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	71	71	Remove potential of old obstacle
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	74	74	skips the specified coordinate
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	76	76	Subtract the obstacle's potential
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	81	81	Update board with new potential values once updated
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	84	84	skips the specified coordinate
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	101	101	if point is within array, outputs the potential field value <X,Y> as a string, if not return failure
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	112	112	If board contains any values, clear the entire board and initalize to 0 and return success, otherwise return failure
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	116	116	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	126	126	Updates kvalue with given K if K is greater than 0 and returns success otherwise return failure
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	132	132	end update
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	134	134	See if coordinates are within map
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	137	137	end of function
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	139	139	Checks if there was a previous array with values
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	147	147	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields_helper.cpp	150	150	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	17	17	Constructor
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	20	20	Destructor
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	23	23	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	26	26	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	29	29	Move to value to speficic area
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	32	32	Clear the board
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	35	35	Update the K value
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	38	38	Check if point is in array
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	41	41	Check if the board is filled or not
79f03c23	f24	p0	2024-09-23 14:32:31	PotentialFields.h	44	44	Calculate potential between points
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	7	7	Default constructor
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	25	25	delete xvalue
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	28	30	delete remaining elements\nset pointer to nullptr\nend if statement
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	32	32	setting parameters with respective member variables
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	36	36	Creating new board with respect to new dimensions
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	45	46	yvalue\nxvalue
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	49	49	end of Create
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	53	53	Checks if the coordinate is within the array
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	62	62	skips O or G point
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	76	76	Statements to ensure that obstacles or goals are overwritten
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	78	78	if a goal is being overwritten
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	82	82	if an obstacle is being overwritten
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	89	89	end of Point
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	93	93	if point is within array, outputs the potential field value <X,Y> as a string, if not return failure
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	104	104	If board contains any values, clear the entire board and initalize to 0 and return success, otherwise return failure
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	108	108	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	118	118	Updates kvalue with given K if K is greater than 0 and returns success otherwise return failure
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	124	124	end update
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	126	126	See if coordinates are within map
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	129	129	end of function
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	131	131	Checks if there was a previous array with values
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	139	139	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields_helper.cpp	142	142	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	17	17	Constructor
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	20	20	Destructor
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	23	23	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	26	26	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	29	29	Move to value to speficic area
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	32	32	Clear the board
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	35	35	Update the K value
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	38	38	Check if point is in array
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	41	41	Check if the board is filled or not
79f03c23	f24	p0	2024-09-23 14:51:50	PotentialFields.h	44	44	Calculate potential between points
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	7	7	Default constructor
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	25	25	delete xvalue
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	28	30	delete remaining elements\nset pointer to nullptr\nend if statement
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	32	32	setting parameters with respective member variables
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	36	36	Creating new board with respect to new dimensions
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	45	46	yvalue\nxvalue
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	49	49	end of Create
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	53	53	Checks if the coordinate is within the array
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	62	62	skips O or G point
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	76	76	Statements to ensure that obstacles or goals are overwritten
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	78	78	if a goal is being overwritten
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	82	82	if an obstacle is being overwritten
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	89	89	end of Point
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	93	93	if point is within array, outputs the potential field value <X,Y> as a string, if not return failure
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	104	104	If board contains any values, clear the entire board and initalize to 0 and return success, otherwise return failure
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	108	108	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	118	118	Updates kvalue with given K if K is greater than 0 and returns success otherwise return failure
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	124	124	end update
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	126	126	See if coordinates are within map
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	129	129	end of function
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	131	131	Checks if there was a previous array with values
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	139	139	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields_helper.cpp	142	142	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	17	17	Constructor
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	20	20	Destructor
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	23	23	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	26	26	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	29	29	Move to value to speficic area
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	32	32	Clear the board
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	35	35	Update the K value
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	38	38	Check if point is in array
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	41	41	Check if the board is filled or not
79f03c23	f24	p0	2024-09-23 16:12:22	PotentialFields.h	44	44	Calculate potential between points
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	7	7	Default constructor
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	25	25	delete xvalue
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	28	30	delete remaining elements\nset pointer to nullptr\nend if statement
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	32	32	setting parameters with respective member variables
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	36	36	Creating new board with respect to new dimensions
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	45	46	yvalue\nxvalue
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	49	49	end of Create
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	53	53	Checks if the coordinate is within the array
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	62	62	skips O or G point
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	76	76	Statements to ensure that obstacles or goals are overwritten
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	78	78	if a goal is being overwritten
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	82	82	if an obstacle is being overwritten
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	89	89	end of Point
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	93	93	if point is within array, outputs the potential field value <X,Y> as a string, if not return failure
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	104	104	If board contains any values, clear the entire board and initalize to 0 and return success, otherwise return failure
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	108	108	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	118	118	Updates kvalue with given K if K is greater than 0 and returns success otherwise return failure
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	124	124	end update
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	126	126	See if coordinates are within map
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	129	129	end of function
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	131	131	Checks if there was a previous array with values
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	139	139	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields_helper.cpp	142	142	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	17	17	Constructor
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	20	20	Destructor
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	23	23	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	26	26	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	29	29	Move to value to speficic area
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	32	32	Clear the board
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	35	35	Update the K value
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	38	38	Check if point is in array
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	41	41	Check if the board is filled or not
79f03c23	f24	p0	2024-09-23 16:17:09	PotentialFields.h	44	44	Calculate potential between points
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	7	7	Default constructor
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	25	25	delete xvalue
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	28	30	delete remaining elements\nset pointer to nullptr\nend if statement
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	32	32	setting parameters with respective member variables
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	36	36	Creating new board with respect to new dimensions
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	45	46	yvalue\nxvalue
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	49	49	end of Create
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	53	53	Checks if the coordinate is within the array
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	62	62	skips O or G point
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	76	76	Statements to ensure that obstacles or goals are overwritten
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	78	78	if a goal is being overwritten
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	82	82	if an obstacle is being overwritten
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	89	89	end of Point
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	93	93	if point is within array, outputs the potential field value <X,Y> as a string, if not return failure
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	104	104	If board contains any values, clear the entire board and initalize to 0 and return success, otherwise return failure
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	108	108	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	118	118	Updates kvalue with given K if K is greater than 0 and returns success otherwise return failure
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	124	124	end update
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	126	126	See if coordinates are within map
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	129	129	end of function
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	131	131	Checks if there was a previous array with values
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	139	139	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields_helper.cpp	142	142	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	17	17	Constructor
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	20	20	Destructor
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	23	23	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	26	26	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	29	29	Move to value to speficic area
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	32	32	Clear the board
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	35	35	Update the K value
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	38	38	Check if point is in array
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	41	41	Check if the board is filled or not
79f03c23	f24	p0	2024-09-23 16:19:49	PotentialFields.h	44	44	Calculate potential between points
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	7	7	Default constructor
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	11	11	destructor
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	14	14	delete xvalue
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	16	16	delete remaining elements
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	18	18	end of destructor
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	23	23	If the array was filled we want to delete it completely
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	25	25	delete xvalue
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	28	30	delete remaining elements\nset pointer to nullptr\nend if statement
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	32	32	setting parameters with respective member variables
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	36	36	Creating new board with respect to new dimensions
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	45	46	yvalue\nxvalue
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	49	49	end of Create
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	53	53	Checks if the coordinate is within the array
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	62	62	skips O or G point
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	76	76	Statements to ensure that obstacles or goals are overwritten
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	78	78	if a goal is being overwritten
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	82	82	if an obstacle is being overwritten
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	89	89	end of Point
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	93	93	if point is within array, outputs the potential field value <X,Y> as a string, if not return failure
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	104	104	If board contains any values, clear the entire board and initalize to 0 and return success, otherwise return failure
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	108	108	Resetting the potential values to 0
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	118	118	Updates kvalue with given K if K is greater than 0 and returns success otherwise return failure
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	124	124	end update
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	126	126	See if coordinates are within map
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	129	129	end of function
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	131	131	Checks if there was a previous array with values
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	139	139	Calculates potential value due to a point
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields_helper.cpp	142	142	Accounting for the case of the Robot being in the same square as G or O
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	17	17	Constructor
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	20	20	Destructor
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	23	23	Create a new board with specified dimensions
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	26	26	Modify the goals and obstacles
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	29	29	Move to value to speficic area
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	32	32	Clear the board
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	35	35	Update the K value
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	38	38	Check if point is in array
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	41	41	Check if the board is filled or not
79f03c23	f24	p0	2024-09-23 16:21:51	PotentialFields.h	44	44	Calculate potential between points
7a993ceb	f24	p0	2024-09-23 18:44:22	robotgrid.cpp	10	10	need to alloc enough mem for a grid of dimx * dim y elements. treat like a 1d array
7a993ceb	f24	p0	2024-09-23 18:44:22	robotgrid.cpp	14	14	initialize all elements to 'N', for "none" meaning there is no goal or obstacle there
7a993ceb	f24	p0	2024-09-23 22:04:48	robotgrid.cpp	10	10	need to alloc enough mem for a grid of dimx * dim y elements. treat like a 1d array
7a993ceb	f24	p0	2024-09-23 22:04:48	robotgrid.cpp	14	14	initialize all elements to 'N', for "none" meaning there is no goal or obstacle there
7ac753b9	f24	p0	2024-09-22 13:50:56	p0.cpp	140	141	if(potentialType[x][y] != ' ')\n{
7ac753b9	f24	p0	2024-09-22 13:50:56	p0.cpp	143	143	}
7ac753b9	f24	p0	2024-09-22 13:54:15	p0.cpp	140	141	if(potentialType[x][y] != ' ')\n{
7ac753b9	f24	p0	2024-09-22 13:54:15	p0.cpp	143	143	}
7ac753b9	f24	p0	2024-09-22 14:32:17	p0.cpp	140	141	if(potentialType[x][y] != ' ')\n{
7ac753b9	f24	p0	2024-09-22 14:32:17	p0.cpp	143	143	}
7ac753b9	f24	p0	2024-09-22 23:10:34	p0.cpp	140	141	if(potentialType[x][y] != ' ')\n{
7ac753b9	f24	p0	2024-09-22 23:10:34	p0.cpp	143	143	}
7ac753b9	f24	p0	2024-09-23 19:42:09	main.cpp	15	15	This while loop allows the user to type a series of commands that perform different operations on the 2D grid.
7ac753b9	f24	p0	2024-09-23 19:42:09	main.cpp	19	19	If user inputs CREATE it will create a grid of size N*M of what the user inputted.
7ac753b9	f24	p0	2024-09-23 19:42:09	main.cpp	32	32	If the user inputs POINT, it will ask which point on the grid they want to add a goal or obstacle.
7ac753b9	f24	p0	2024-09-23 19:42:09	main.cpp	52	52	If the user inputs MOVE, they will have to input the coordinates they want the robot to move, and it will then ouput the potential there.
7ac753b9	f24	p0	2024-09-23 19:42:09	main.cpp	70	70	If the user inputs CLEAR, it will clear the grid of goals and obstacles.
7ac753b9	f24	p0	2024-09-23 19:42:09	main.cpp	85	85	If the user inputs UPDATE, they will be allowed to update the constant value of k to calculate the potential at each box.
7ac753b9	f24	p0	2024-09-23 19:42:09	main.cpp	97	97	If the user inputs EXIT, it will break out of the while loop.
7ac753b9	f24	p0	2024-09-23 19:42:09	main.cpp	105	105	After the while loop is broken, if there was a grid created, it will delete it.
7ac753b9	f24	p0	2024-09-23 19:42:09	p0.cpp	3	3	This constructor initializes the variales of the Grid class.
7ac753b9	f24	p0	2024-09-23 19:42:09	p0.cpp	67	67	Adds a goal or obstacle to the grid at the inputted position and recalculates the potentials of all points.
7ac753b9	f24	p0	2024-09-23 19:42:09	p0.cpp	74	74	Clears the grid by resetting the potential values and types to their default values
7ac753b9	f24	p0	2024-09-23 19:42:09	p0.cpp	87	87	Returns the potential value at the inputted position the user wants the robot to move.
7ac753b9	f24	p0	2024-09-23 19:42:09	p0.cpp	93	93	Updates the constant k and recalculates the potentials based on the new value of k.
7ac753b9	f24	p0	2024-09-23 19:42:09	p0.cpp	116	116	Calculates the potential of each point on the grid based on its distance from goals and obstacles.
7ac753b9	f24	p0	2024-09-23 19:42:09	p0.cpp	147	147	Recalculates all the potentials in the grid by calling calculateBoxPotential().
7f42780e	f24	p0	2024-09-21 18:50:40	main.cpp	7	9	The 2D grid for storing potential values\nRows and columns of the grid\nThe constant K used in the potential calculation
7f42780e	f24	p0	2024-09-21 20:39:51	main.cpp	7	9	The 2D grid for storing potential values\nRows and columns of the grid\nThe constant K used in the potential calculation
7f42780e	f24	p0	2024-09-21 20:39:51	main.cpp	118	118	Ensure we clear the grid before exiting
7f42780e	f24	p0	2024-09-21 20:53:44	main.cpp	7	9	The 2D grid for storing potential values\nRows and columns of the grid\nThe constant K used in the potential calculation
7f42780e	f24	p0	2024-09-21 20:53:44	main.cpp	19	19	Ensure previous grid is cleared
7f42780e	f24	p0	2024-09-21 20:53:44	main.cpp	119	119	Ensure we clear the grid before exiting
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	7	9	The 2D grid for storing potential values\nRows and columns of the grid\nThe constant K used in the potential calculation
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	15	15	Ensure we clear the grid before destruction
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	19	19	Validate input to prevent invalid grid creation
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	25	25	Ensure previous grid is cleared properly
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	30	30	Allocate memory for the grid and initialize values to 0.0
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	39	39	Check if grid exists
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	45	45	Validate coordinates
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	51	51	Validate point type
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	62	62	Update potential field based on the point's influence
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	67	67	No potential at the source point itself
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	78	78	Check if grid exists
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	84	84	Validate coordinates
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	90	90	Get the potential value at the specified location
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	96	96	If grid exists, free memory
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	102	103	Reset grid pointer to avoid dangling pointer issues\nReset dimensions
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	108	108	Validate K value to be positive
7f42780e	f24	p0	2024-09-21 20:57:43	main.cpp	144	144	Ensure we clear the grid before exiting
7f42780e	f24	p0	2024-09-21 21:54:18	main.cpp	7	9	The 2D grid for storing potential values\nRows and columns of the grid\nThe constant K used in the potential calculation
7f42780e	f24	p0	2024-09-21 21:54:18	main.cpp	15	15	Ensure we clear the grid before destruction
7f42780e	f24	p0	2024-09-21 21:54:18	main.cpp	57	57	Assume potential is scalar and same for simplicity
7f42780e	f24	p0	2024-09-22 11:19:02	main.cpp	7	9	The 2D grid for storing potential values\nRows and columns of the grid\nThe constant K used in the potential calculation
7f42780e	f24	p0	2024-09-22 11:19:02	main.cpp	15	15	Ensure we clear the grid before destruction
7f42780e	f24	p0	2024-09-22 11:24:49	main.cpp	7	9	The 2D grid for storing potential values\nRows and columns of the grid\nThe constant K used in the potential calculation
7f42780e	f24	p0	2024-09-22 11:24:49	main.cpp	15	15	Ensure we clear the grid before destruction
7f42780e	f24	p0	2024-09-22 11:24:49	main.cpp	68	68	Assume potential is scalar and same for simplicity
7f42780e	f24	p0	2024-09-22 11:27:12	main.cpp	7	9	The 2D grid for storing potential values\nRows and columns of the grid\nThe constant K used in the potential calculation
7f42780e	f24	p0	2024-09-22 11:27:12	main.cpp	15	15	Ensure we clear the grid before destruction
7f42780e	f24	p0	2024-09-22 11:27:12	main.cpp	52	52	(USED GENERATIVE AI) to come up with a line to assign each grid in the 2d array the correct potential value
7f42780e	f24	p0	2024-09-22 11:27:12	main.cpp	63	63	Assume potential is scalar and same for simplicity
7f42780e	f24	p0	2024-09-22 11:39:53	main.cpp	7	9	The 2D grid for storing potential values\nRows and columns of the grid\nThe constant K used in the potential calculation
7f42780e	f24	p0	2024-09-22 11:39:53	main.cpp	15	15	Ensure we clear the grid before destruction
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	5	5	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	9	9	allocate space for 2 potential value
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	11	11	potential value for x
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	13	13	potential value for y
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	15	15	initialze cellStatus to 0
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	26	26	create a list of operation, useful for reduce duplicate code
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	60	60	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	72	73	check whether a grid has been created or not\nif grid is not null, deallocate the memory
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	91	91	allcate an array of row pointers
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	96	96	allcoate each row as an array of Cell pointers
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	104	104	clear map if map exists
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	111	111	reset potential vlaue to 0
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	113	113	reset cellStatus to 0
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	124	124	if the current cell is the goal or the object, the effect from itself should be 0
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	134	134	if target cell is an obstancle, the potential should be positive, it repel the robot
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	140	140	if target cell is a goal, the potential should be negative, it attract the robot
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	146	146	update the calculated potentials to current cell's potential
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	152	152	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	158	158	update the cell status of the goal
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	165	165	DO NOT compare the point itself
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	168	168	recalculate potential for every cell in the grid
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	179	179	if there is no grid, do not update the k
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	189	189	reset the k value to 1
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	191	191	update the new k
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	196	196	update variabel k to new value
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	203	203	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.cpp	209	209	get potential value from the target cell
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.h	4	4	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 19:16:15	potentialField.h	21	21	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	5	5	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	9	9	allocate space for 2 potential value
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	11	11	potential value for x
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	13	13	potential value for y
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	15	15	initialze cellStatus to 0
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	26	26	create a list of operation, useful for reduce duplicate code
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	60	60	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	72	73	check whether a grid has been created or not\nif grid is not null, deallocate the memory
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	91	91	allcate an array of row pointers
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	96	96	allcoate each row as an array of Cell pointers
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	104	104	clear map if map exists
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	111	111	reset potential vlaue to 0
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	113	113	reset cellStatus to 0
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	124	124	if the current cell is the goal or the object, the effect from itself should be 0
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	134	134	if target cell is an obstancle, the potential should be positive, it repel the robot
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	140	140	if target cell is a goal, the potential should be negative, it attract the robot
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	146	146	update the calculated potentials to current cell's potential
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	152	152	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	158	158	update the cell status of the goal
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	165	165	DO NOT compare the point itself
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	168	168	recalculate potential for every cell in the grid
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	179	179	if there is no grid, do not update the k
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	189	189	reset the k value to 1
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	191	191	update the new k
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	196	196	update variabel k to new value
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	203	203	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.cpp	209	209	get potential value from the target cell
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.h	4	4	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 21:51:19	potentialField.h	21	21	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	5	5	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	9	9	allocate space for 2 potential value
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	11	11	potential value for x
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	13	13	potential value for y
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	15	15	initialze cellStatus to 0
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	26	26	create a list of operation, useful for reduce duplicate code
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	60	60	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	72	73	check whether a grid has been created or not\nif grid is not null, deallocate the memory
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	91	91	allcate an array of row pointers
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	96	96	allcoate each row as an array of Cell pointers
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	104	104	clear map if map exists
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	111	111	reset potential vlaue to 0
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	113	113	reset cellStatus to 0
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	124	124	if the current cell is the goal or the object, the effect from itself should be 0
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	134	134	if target cell is an obstancle, the potential should be positive, it repel the robot
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	140	140	if target cell is a goal, the potential should be negative, it attract the robot
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	146	146	update the calculated potentials to current cell's potential
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	152	152	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	158	158	update the cell status of the goal
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	165	165	DO NOT compare the point itself
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	168	168	recalculate potential for every cell in the grid
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	179	179	if there is no grid, do not update the k
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	189	189	reset the k value to 1
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	191	191	update the new k
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	196	196	update variabel k to new value
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	203	203	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.cpp	209	209	get potential value from the target cell
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.h	4	4	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 23:00:07	potentialField.h	21	21	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	5	5	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	9	9	allocate space for 2 potential value
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	11	11	potential value for x
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	13	13	potential value for y
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	15	15	initialze cellStatus to 0
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	26	26	create a list of operation, useful for reduce duplicate code
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	60	60	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	72	73	check whether a grid has been created or not\nif grid is not null, deallocate the memory
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	91	91	allcate an array of row pointers
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	96	96	allcoate each row as an array of Cell pointers
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	104	104	clear map if map exists
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	111	111	reset potential vlaue to 0
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	113	113	reset cellStatus to 0
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	124	124	if the current cell is the goal or the object, the effect from itself should be 0
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	134	134	if target cell is an obstancle, the potential should be positive, it repel the robot
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	140	140	if target cell is a goal, the potential should be negative, it attract the robot
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	146	146	update the calculated potentials to current cell's potential
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	152	152	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	158	158	update the cell status of the goal
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	165	165	DO NOT compare the point itself
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	168	168	recalculate potential for every cell in the grid
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	179	179	if there is no grid, do not update the k
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	189	189	reset the k value to 1
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	191	191	update the new k
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	196	196	update variabel k to new value
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	203	203	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.cpp	209	209	get potential value from the target cell
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.h	4	4	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-21 23:52:44	potentialField.h	21	21	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	5	5	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	9	9	allocate space for 2 potential value
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	11	11	potential value for x
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	13	13	potential value for y
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	15	15	initialze cellStatus to 0
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	27	27	create a list of operation, useful for reduce duplicate code
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	61	61	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	73	74	check whether a grid has been created or not\nif grid is not null, deallocate the memory
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	89	89	Clear the existing grid if already allocated
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	103	103	Allocate a new array of row pointers
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	108	108	Allocate each row as an array of Cell objects
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	116	116	clear map if map exists
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	123	123	reset potential vlaue to 0
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	135	135	if the current cell is the goal or the object, the effect from itself should be 0
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	145	145	if target cell is an obstancle, the potential should be positive, it repel the robot
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	151	151	if target cell is a goal, the potential should be negative, it attract the robot
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	157	157	update the calculated potentials to current cell's potential
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	163	163	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	172	172	calculate old potential
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	179	179	undo the potential effect of the current point
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	186	186	update the cell status with the new goal or obstacle
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	189	189	Recalculate potentials to add the new potential
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	196	196	Recalculate and add the new potential
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	207	207	if there is no grid, do not update the k
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	217	217	reset the k value to 1
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	219	219	update the new k
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	224	224	update variabel k to new value
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	231	231	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.cpp	237	237	get potential value from the target cell
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.h	4	4	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-22 00:05:40	potentialField.h	21	21	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	5	5	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	9	9	allocate space for 2 potential value
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	11	11	potential value for x
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	13	13	potential value for y
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	15	15	initialze cellStatus to 0
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	21	21	deallocate memory
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	28	28	create a list of operation, useful for reduce duplicate code
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	58	58	return the potential of x (0), or the potential of y (1), depends on the index number.
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	62	62	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	74	75	check whether a grid has been created or not\nif grid is not null, deallocate the memory
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	90	90	clean the existing grid only if already allocated
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	104	104	allocate a new array of row pointers
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	109	109	Allocate each row as an array of Cell objects
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	117	117	clear map if map exists
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	124	124	reset potential vlaue to 0
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	136	136	if the current cell is the goal or the object, the effect from itself should be 0
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	143	143	initialize variable
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	147	147	if target cell is an obstancle, the potential should be positive, it repel the robot
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	153	153	if target cell is a goal, the potential should be negative, it attract the robot
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	159	159	update the calculated potentials to current cell's potential
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	165	165	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	174	174	calculate old potential
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	179	179	avoid calculate the potential of the cell itself
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	182	182	undo the potential effect of the current point
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	189	189	update the cell status with the new goal or obstacle
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	192	192	Recalculate potentials to add the new potential
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	199	199	Recalculate and add the new potential
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	210	210	if there is no grid, do not update the k
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	220	220	reset the k value to 1
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	222	222	update the new k
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	227	227	update variabel k to new value
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	234	234	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.cpp	240	240	get potential value from the target cell
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.h	4	4	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-22 23:22:03	potentialField.h	21	21	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	5	5	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	9	9	allocate space for 2 potential value
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	11	11	potential value for x
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	13	13	potential value for y
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	15	15	initialze cellStatus to 0
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	21	21	deallocate memory
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	28	28	create a list of operation, useful for reduce duplicate code
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	58	58	return the potential of x (0), or the potential of y (1), depends on the index number.
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	62	62	------------------------------------------ Map class -----------------------------------------------
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	74	75	check whether a grid has been created or not\nif grid is not null, deallocate the memory
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	90	90	clean the existing grid only if already allocated
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	104	104	allocate a new array of row pointers
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	109	109	Allocate each row as an array of Cell objects
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	117	117	clear map if map exists
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	124	124	reset potential vlaue to 0
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	136	136	if the current cell is the goal or the object, the effect from itself should be 0
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	143	143	initialize variable
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	147	147	if target cell is an obstancle, the potential should be positive, it repel the robot
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	153	153	if target cell is a goal, the potential should be negative, it attract the robot
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	159	159	update the calculated potentials to current cell's potential
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	165	165	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	174	174	calculate old potential
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	179	179	avoid calculate the potential of the cell itself
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	182	182	undo the potential effect of the current point
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	189	189	update the cell status with the new goal or obstacle
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	192	192	Recalculate potentials to add the new potential
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	199	199	Recalculate and add the new potential
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	210	210	if there is no grid, do not update the k
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	220	220	reset the k value to 1
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	222	222	update the new k
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	227	227	update variabel k to new value
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	234	234	check if the user input coordiante is out of bounds
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.cpp	240	240	get potential value from the target cell
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.h	4	4	------------------------------------------ Cell class -----------------------------------------------
7fa6449d	f24	p0	2024-09-23 12:16:39	potentialField.h	21	21	------------------------------------------ Map class -----------------------------------------------
802116b6	f24	p0	2024-09-23 18:07:55	Map_F.cpp	8	8	reset and clear out the map
802116b6	f24	p0	2024-09-23 18:07:55	Map_F.cpp	18	19	reset the map after it's already created\nfree out the initial map
802116b6	f24	p0	2024-09-23 18:07:55	Map_F.cpp	32	33	creating map, starting with rows\nstoring the address of rows into PotentialField
802116b6	f24	p0	2024-09-23 18:07:55	Map_F.cpp	46	46	failure : the location is out of bound
802116b6	f24	p0	2024-09-23 18:07:55	Map_F.cpp	53	54	success : insertion of G and O into the Map is successful\nRecomputes the potential value of all points in the Map
802116b6	f24	p0	2024-09-23 18:07:55	Map.hpp	17	17	bool Map_initialized;
802116b6	f24	p0	2024-09-23 18:07:55	Map.hpp	23	24	constructor - should be defined in source file\ndeconstructor - need to be defined in source file - avoid the memory leak
802116b6	f24	p0	2024-09-23 18:07:55	Robot_F.cpp	8	8	Setting robot's initial location
802116b6	f24	p0	2024-09-23 18:07:55	Robot_F.cpp	15	15	Map reference
802116b6	f24	p0	2024-09-23 18:07:55	Robot.hpp	12	12	Reference to the map the robot navigates through
802116b6	f24	p0	2024-09-23 18:07:55	Robot.hpp	16	16	Constructor to initilize the robot's position with (0,0)
802116b6	f24	p0	2024-09-23 21:47:49	Map_F.cpp	8	8	reset and clear out the map
802116b6	f24	p0	2024-09-23 21:47:49	Map_F.cpp	18	19	reset the map after it's already created\nfree out the initial map
802116b6	f24	p0	2024-09-23 21:47:49	Map_F.cpp	32	33	creating map, starting with rows\nstoring the address of rows into PotentialField
802116b6	f24	p0	2024-09-23 21:47:49	Map_F.cpp	46	46	failure : the location is out of bound
802116b6	f24	p0	2024-09-23 21:47:49	Map_F.cpp	53	54	success : insertion of G and O into the Map is successful\nRecomputes the potential value of all points in the Map
802116b6	f24	p0	2024-09-23 21:47:49	Map.hpp	17	17	bool Map_initialized;
802116b6	f24	p0	2024-09-23 21:47:49	Map.hpp	23	24	constructor - should be defined in source file\ndeconstructor - need to be defined in source file - avoid the memory leak
802116b6	f24	p0	2024-09-23 21:47:49	Robot_F.cpp	8	8	Setting robot's initial location
802116b6	f24	p0	2024-09-23 21:47:49	Robot_F.cpp	15	15	Map reference
802116b6	f24	p0	2024-09-23 21:47:49	Robot.hpp	12	12	Reference to the map the robot navigates through
802116b6	f24	p0	2024-09-23 21:47:49	Robot.hpp	16	16	Constructor to initilize the robot's position with (0,0)
802116b6	f24	p0	2024-09-23 22:38:29	Map_F.cpp	8	8	reset and clear out the map
802116b6	f24	p0	2024-09-23 22:38:29	Map_F.cpp	19	20	reset the map after it's already created\nfree out the initial map
802116b6	f24	p0	2024-09-23 22:38:29	Map_F.cpp	33	34	creating map, starting with rows\nstoring the address of rows into PotentialField
802116b6	f24	p0	2024-09-23 22:38:29	Map_F.cpp	47	47	failure : the location is out of bound
802116b6	f24	p0	2024-09-23 22:38:29	Map_F.cpp	54	55	success : insertion of G and O into the Map is successful\nRecomputes the potential value of all points in the Map
802116b6	f24	p0	2024-09-23 22:38:29	Map_F.cpp	85	85	update the k with the input value
802116b6	f24	p0	2024-09-23 22:38:29	Map.hpp	17	17	bool Map_initialized;
802116b6	f24	p0	2024-09-23 22:38:29	Map.hpp	23	24	constructor - should be defined in source file\ndeconstructor - need to be defined in source file - avoid the memory leak
802116b6	f24	p0	2024-09-23 22:38:29	Robot_F.cpp	8	8	Setting robot's initial location
802116b6	f24	p0	2024-09-23 22:38:29	Robot_F.cpp	15	15	Map reference
802116b6	f24	p0	2024-09-23 22:38:29	Robot.hpp	12	12	Reference to the map the robot navigates through
802116b6	f24	p0	2024-09-23 22:38:29	Robot.hpp	16	16	Constructor to initilize the robot's position with (0,0)
802116b6	f24	p0	2024-09-23 22:44:45	Map_F.cpp	8	8	reset and clear out the map
802116b6	f24	p0	2024-09-23 22:44:45	Map_F.cpp	20	21	reset the map after it's already created\nfree out the initial map
802116b6	f24	p0	2024-09-23 22:44:45	Map_F.cpp	34	35	creating map, starting with rows\nstoring the address of rows into PotentialField
802116b6	f24	p0	2024-09-23 22:44:45	Map_F.cpp	48	48	failure : the location is out of bound
802116b6	f24	p0	2024-09-23 22:44:45	Map_F.cpp	55	56	success : insertion of G and O into the Map is successful\nRecomputes the potential value of all points in the Map
802116b6	f24	p0	2024-09-23 22:44:45	Map_F.cpp	86	86	update the k with the input value
802116b6	f24	p0	2024-09-23 22:44:45	Map.hpp	17	17	bool Map_initialized;
802116b6	f24	p0	2024-09-23 22:44:45	Map.hpp	23	24	constructor - should be defined in source file\ndeconstructor - need to be defined in source file - avoid the memory leak
802116b6	f24	p0	2024-09-23 22:44:45	Robot_F.cpp	8	8	Setting robot's initial location
802116b6	f24	p0	2024-09-23 22:44:45	Robot_F.cpp	15	15	Map reference
802116b6	f24	p0	2024-09-23 22:44:45	Robot.hpp	12	12	Reference to the map the robot navigates through
802116b6	f24	p0	2024-09-23 22:44:45	Robot.hpp	16	16	Constructor to initilize the robot's position with (0,0)
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	6	6	initializing
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	10	10	dynamically allocating 2d array
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	31	31	delete the array
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	46	46	-1 for goal
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	48	48	1 for obstacle
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	65	65	iterate over the entire grid to compute the potential
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	68	68	prevent division by zero
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	73	73	just checking
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	75	75	if grid[i][j] == 1, it's a goal, if grid[i][j] == -1, it's an obstacle
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	81	81	print and return the calculated potential
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	112	112	ensure K is positive
82aff432	f24	p0	2024-09-23 13:25:31	grid.cpp	117	117	update the scaling factor K
82aff432	f24	p0	2024-09-23 13:25:31	grid.h	13	15	constructor\ndestructor\ndeclarations
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	6	6	initializing
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	10	10	dynamically allocating 2d array
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	31	31	delete the array
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	46	46	-1 for goal
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	48	48	1 for obstacle
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	65	65	iterate over the entire grid to compute the potential
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	68	68	prevent division by zero
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	73	73	just checking
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	75	75	if grid[i][j] == 1, it's a goal, if grid[i][j] == -1, it's an obstacle
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	81	81	print and return the calculated potential
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	112	112	ensure K is positive
82aff432	f24	p0	2024-09-23 13:55:14	grid.cpp	117	117	update the scaling factor K
82aff432	f24	p0	2024-09-23 13:55:14	grid.h	13	15	constructor\ndestructor\ndeclarations
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	17	17	initializing
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	21	21	dynamically allocating 2d array
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	42	42	delete the array
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	57	57	-1 for goal
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	59	59	1 for obstacle
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	76	76	iterate over the entire grid to compute the potential
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	79	79	prevent division by zero
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	84	84	just checking
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	86	86	using grid value
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	92	92	print and return the calculated potential
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	112	112	setting grid values to 0
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	123	123	ensure K is positive
82aff432	f24	p0	2024-09-23 19:45:33	grid.cpp	128	128	update the scaling factor K
82aff432	f24	p0	2024-09-23 19:45:33	grid.h	13	15	constructor\ndestructor\ndeclarations
831f2897	f24	p0	2024-09-22 03:28:09	main.cpp	60	61	char oldType = map->getCordCell(x, y).getType();\nmap->updateCordValue(x, y, 'N');
831f2897	f24	p0	2024-09-22 03:28:09	main.cpp	65	65	map->updateCordValue(x, y, oldType);
831f2897	f24	p0	2024-09-22 03:28:09	mapArray.cpp	8	9	m = x\nn = y
831f2897	f24	p0	2024-09-22 03:28:09	mapArray.cpp	82	82	if a position is being overwritten, undo its effect from every square
831f2897	f24	p0	2024-09-22 03:28:09	mapArray.cpp	104	104	commpute the value for each square
831f2897	f24	p0	2024-09-22 14:50:41	main.cpp	60	61	char oldType = map->getCordCell(x, y).getType();\nmap->updateCordValue(x, y, 'N');
831f2897	f24	p0	2024-09-22 14:50:41	main.cpp	65	65	map->updateCordValue(x, y, oldType);
831f2897	f24	p0	2024-09-22 14:50:41	mapArray.cpp	8	9	m = x\nn = y
831f2897	f24	p0	2024-09-22 14:50:41	mapArray.cpp	82	82	if a position is being overwritten, undo its effect from every square
831f2897	f24	p0	2024-09-22 14:50:41	mapArray.cpp	104	104	commpute the value for each square
831f2897	f24	p0	2024-09-22 15:07:10	mapArray.cpp	8	9	m = x\nn = y
831f2897	f24	p0	2024-09-22 15:07:10	mapArray.cpp	74	74	if a position is being overwritten, undo its effect from every square
831f2897	f24	p0	2024-09-22 15:07:10	mapArray.cpp	85	85	opposite multiplyer
831f2897	f24	p0	2024-09-22 15:07:10	mapArray.cpp	100	100	multiplier is zero if n
831f2897	f24	p0	2024-09-22 15:07:10	mapArray.cpp	109	109	commpute the value for each square
831f2897	f24	p0	2024-09-22 15:19:08	mapArray.cpp	8	9	m = x\nn = y
831f2897	f24	p0	2024-09-22 15:19:08	mapArray.cpp	75	75	opposite multiplyer
831f2897	f24	p0	2024-09-22 15:19:08	mapArray.cpp	84	84	if a position is being overwritten, undo its effect from every square
831f2897	f24	p0	2024-09-22 15:19:08	mapArray.cpp	102	102	multiplier is zero if n
831f2897	f24	p0	2024-09-22 15:19:08	mapArray.cpp	111	111	commpute the value for each square
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	7	7	www.youtube.com/watch?v=DUZHe1nz6bs.
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	12	12	Constructor
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	15	15	Member initialization list
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	19	19	Allocate memory for the rows in the grid
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	22	22	Allocate memory for the columns in the grid
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	27	27	Set all of the values in the grid to 0.0
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	36	36	Destructor
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	39	39	Free the memory allocated for the rows
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	41	41	Delete the individual elements
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	44	45	Free the memory allocated for the grid\nDelete the array of pointers
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	49	49	Setter Function: Set the potential of a specific element in the grid (coordinate comes from the PotentialField class)
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	54	54	Getter Function: Get the value of a specific element in the grid
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	63	63	Iterate through all goals and obstacles to compute the potential components
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	67	67	Check if it's a goal or obstacle
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	69	70	Avoid division by zero\nGoal
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	73	73	Obstacle
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	83	83	Reset Function: Resets the value of the potential of each element in the grid to 0.0
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.cpp	92	92	Print the grid for debugging -- TO BE REMOVED
86654dd9	f24	p0	2024-09-18 19:08:59	Grid.h	16	16	REMOVE LATER
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	5	5	Constructor
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	14	14	resetPotential();
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	17	17	Destructor
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	25	25	Set goal
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	30	30	Set obstacle
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	36	36	Initialize all cells in the potential grid to 0.0
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	39	40	Reset goals and obstacles\nReset potential values
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	46	46	Use the Grid class's getPotential method
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	62	62	Initialize for each cell
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	65	65	Robot's cell; set potential to 0
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	70	70	Loop through all cells in goalObstacleGrid
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	77	77	Goal
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	79	79	Obstacle
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	87	87	Update the potential in the grid
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	94	94	Update K to the new value
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	96	96	Recalculate the potentials for all cells in the grid
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	100	100	Skip goals and obstacles
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.cpp	103	103	Recalculate potential for this cell
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	8	8	Constructor
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	11	11	Destructor
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	14	14	Add a goal to the grid
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	17	17	Add an obstacle to the grid
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	20	20	Reset the potential grid and goal/obstacle grid
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	23	23	Gets the potential from the Grid class
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	26	26	Sets the constant k
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	29	29	Function to update potentials using a new K value
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	34	34	void move(int x, int y, double &Px, double &Py);
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	36	36	TO BE DELETED
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	39	39	Update the potential of the grid based on the current goals and obstacles
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	42	42	Grid dimensions
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	46	46	Constant used for potential calculation
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	49	49	Grid to keep track of goals and obstacles
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	52	52	Grid to store potential values
86654dd9	f24	p0	2024-09-18 19:08:59	PotentialField.h	56	56	POTENTIALFIELD_H
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	16	16	Delete old field if it exists
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	19	19	Create new field with initial K=1
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	31	31	Add goal
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	34	34	Add obstacle
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	39	39	Out of bounds or no field created
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	50	50	Output Px and Py
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	58	58	Reset the grid
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	62	62	No map created yet
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	71	71	Recalculate potential field
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	75	75	Invalid K or no field created
86654dd9	f24	p0	2024-09-18 19:08:59	test.cpp	83	83	Clean up before exit
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	7	7	www.youtube.com/watch?v=DUZHe1nz6bs.
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	12	12	Constructor
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	15	15	Member initialization list
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	19	19	Allocate memory for the rows in the grid
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	22	22	Allocate memory for the columns in the grid
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	27	27	Set all of the values in the grid to 0.0
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	36	36	Destructor
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	39	39	Free the memory allocated for the rows
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	41	41	Delete the individual elements
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	44	45	Free the memory allocated for the grid\nDelete the array of pointers
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	49	49	Setter Function: Set the potential of a specific element in the grid (coordinate comes from the PotentialField class)
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	54	54	Getter Function: Get the value of a specific element in the grid
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	63	63	Iterate through all goals and obstacles to compute the potential components
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	67	67	Check if it's a goal or obstacle
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	69	70	Avoid division by zero\nGoal
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	73	73	Obstacle
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	83	83	Reset Function: Resets the value of the potential of each element in the grid to 0.0
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.cpp	92	92	Print the grid for debugging -- TO BE REMOVED
86654dd9	f24	p0	2024-09-21 01:59:01	Grid.h	16	16	REMOVE LATER
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	5	5	Constructor
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	14	14	resetPotential();
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	17	17	Destructor
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	25	25	Set goal
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	30	30	Set obstacle
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	36	36	Initialize all cells in the potential grid to 0.0
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	39	40	Reset goals and obstacles\nReset potential values
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	46	46	Use the Grid class's getPotential method
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	62	62	Initialize for each cell
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	65	65	Robot's cell; set potential to 0
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	70	70	Loop through all cells in goalObstacleGrid
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	77	77	Goal
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	79	79	Obstacle
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	87	87	Update the potential in the grid
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	94	94	Update K to the new value
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	96	96	Recalculate the potentials for all cells in the grid
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	100	100	Skip goals and obstacles
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.cpp	103	103	Recalculate potential for this cell
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	8	8	Constructor
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	11	11	Destructor
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	14	14	Add a goal to the grid
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	17	17	Add an obstacle to the grid
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	20	20	Reset the potential grid and goal/obstacle grid
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	23	23	Gets the potential from the Grid class
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	26	26	Sets the constant k
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	29	29	Function to update potentials using a new K value
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	34	34	void move(int x, int y, double &Px, double &Py);
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	36	36	TO BE DELETED
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	39	39	Update the potential of the grid based on the current goals and obstacles
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	42	42	Grid dimensions
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	46	46	Constant used for potential calculation
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	49	49	Grid to keep track of goals and obstacles
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	52	52	Grid to store potential values
86654dd9	f24	p0	2024-09-21 01:59:01	PotentialField.h	56	56	POTENTIALFIELD_H
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	16	16	Delete old field if it exists
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	19	19	Create new field with initial K=1
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	31	31	Add goal
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	34	34	Add obstacle
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	39	39	Out of bounds or no field created
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	50	50	Output Px and Py
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	58	58	Reset the grid
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	62	62	No map created yet
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	71	71	Recalculate potential field
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	75	75	Invalid K or no field created
86654dd9	f24	p0	2024-09-21 01:59:01	test.cpp	83	83	Clean up before exit
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	7	7	www.youtube.com/watch?v=DUZHe1nz6bs.
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	12	12	Constructor
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	15	15	Member initialization list
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	19	19	Allocate memory for the rows in the grid
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	22	22	Allocate memory for the columns in the grid
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	27	27	Set all of the values in the grid to 0.0
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	36	36	Destructor
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	39	39	Free the memory allocated for the rows
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	41	41	Delete the individual elements
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	44	45	Free the memory allocated for the grid\nDelete the array of pointers
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	49	49	Setter Function: Set the potential of a specific element in the grid (coordinate comes from the PotentialField class)
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	54	54	Getter Function: Get the value of a specific element in the grid
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	63	63	Iterate through all goals and obstacles to compute the potential components
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	67	67	Check if it's a goal or obstacle
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	69	70	Avoid division by zero\nGoal
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	73	73	Obstacle
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	83	83	Reset Function: Resets the value of the potential of each element in the grid to 0.0
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.cpp	92	92	Print the grid for debugging -- TO BE REMOVED
86654dd9	f24	p0	2024-09-21 16:54:01	Grid.h	16	16	REMOVE LATER
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	5	5	Constructor
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	14	14	resetPotential();
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	17	17	Destructor
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	25	25	Set goal
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	30	30	Set obstacle
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	36	36	Initialize all cells in the potential grid to 0.0
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	39	40	Reset goals and obstacles\nReset potential values
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	46	46	Use the Grid class's getPotential method
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	62	62	Initialize for each cell
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	65	65	Robot's cell; set potential to 0
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	70	70	Loop through all cells in goalObstacleGrid
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	77	77	Goal
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	79	79	Obstacle
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	87	87	Update the potential in the grid
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	94	94	Update K to the new value
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	96	96	Recalculate the potentials for all cells in the grid
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	100	100	Skip goals and obstacles
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.cpp	103	103	Recalculate potential for this cell
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	8	8	Constructor
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	11	11	Destructor
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	14	14	Add a goal to the grid
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	17	17	Add an obstacle to the grid
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	20	20	Reset the potential grid and goal/obstacle grid
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	23	23	Gets the potential from the Grid class
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	26	26	Sets the constant k
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	29	29	Function to update potentials using a new K value
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	34	34	void move(int x, int y, double &Px, double &Py);
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	36	36	TO BE DELETED
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	39	39	Update the potential of the grid based on the current goals and obstacles
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	42	42	Grid dimensions
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	46	46	Constant used for potential calculation
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	49	49	Grid to keep track of goals and obstacles
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	52	52	Grid to store potential values
86654dd9	f24	p0	2024-09-21 16:54:01	PotentialField.h	56	56	POTENTIALFIELD_H
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	16	16	Delete old field if it exists
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	19	19	Create new field with initial K=1
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	31	31	Add goal
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	34	34	Add obstacle
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	39	39	Out of bounds or no field created
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	50	50	Output Px and Py
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	58	58	Reset the grid
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	62	62	No map created yet
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	71	71	Recalculate potential field
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	75	75	Invalid K or no field created
86654dd9	f24	p0	2024-09-21 16:54:01	test.cpp	83	83	Clean up before exit
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	7	7	www.youtube.com/watch?v=DUZHe1nz6bs.
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	12	12	Constructor
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	15	15	Member initialization list
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	19	19	Allocate memory for the rows in the grid
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	22	22	Allocate memory for the columns in the grid
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	27	27	Set all of the values in the grid to 0.0
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	36	36	Destructor
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	39	39	Free the memory allocated for the rows
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	41	41	Delete the individual elements
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	44	45	Free the memory allocated for the grid\nDelete the array of pointers
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	49	49	Setter Function: Set the potential of a specific element in the grid (coordinate comes from the PotentialField class)
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	54	54	Getter Function: Get the value of a specific element in the grid
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	63	63	Iterate through all goals and obstacles to compute the potential components
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	67	67	Check if it's a goal or obstacle
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	69	70	Avoid division by zero\nGoal
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	73	73	Obstacle
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	83	83	Reset Function: Resets the value of the potential of each element in the grid to 0.0
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.cpp	92	92	Print the grid for debugging -- TO BE REMOVED
86654dd9	f24	p0	2024-09-21 21:49:43	Grid.h	16	16	REMOVE LATER
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	5	5	Constructor
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	14	14	resetPotential();
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	17	17	Destructor
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	25	25	Set goal
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	30	30	Set obstacle
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	36	36	Initialize all cells in the potential grid to 0.0
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	39	40	Reset goals and obstacles\nReset potential values
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	46	46	Use the Grid class's getPotential method
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	62	62	Initialize for each cell
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	65	65	Robot's cell; set potential to 0
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	70	70	Loop through all cells in goalObstacleGrid
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	77	77	Goal
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	79	79	Obstacle
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	87	87	Update the potential in the grid
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	94	94	Update K to the new value
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	96	96	Recalculate the potentials for all cells in the grid
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	100	100	Skip goals and obstacles
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.cpp	103	103	Recalculate potential for this cell
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	8	8	Constructor
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	11	11	Destructor
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	14	14	Add a goal to the grid
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	17	17	Add an obstacle to the grid
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	20	20	Reset the potential grid and goal/obstacle grid
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	23	23	Gets the potential from the Grid class
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	26	26	Sets the constant k
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	29	29	Function to update potentials using a new K value
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	34	34	void move(int x, int y, double &Px, double &Py);
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	36	36	TO BE DELETED
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	39	39	Update the potential of the grid based on the current goals and obstacles
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	42	42	Grid dimensions
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	46	46	Constant used for potential calculation
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	49	49	Grid to keep track of goals and obstacles
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	52	52	Grid to store potential values
86654dd9	f24	p0	2024-09-21 21:49:43	PotentialField.h	56	56	POTENTIALFIELD_H
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	16	16	Delete old field if it exists
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	19	19	Create new field with initial K=1
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	31	31	Add goal
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	34	34	Add obstacle
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	39	39	Out of bounds or no field created
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	50	50	Output Px and Py
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	58	58	Reset the grid
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	62	62	No map created yet
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	71	71	Recalculate potential field
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	75	75	Invalid K or no field created
86654dd9	f24	p0	2024-09-21 21:49:43	test.cpp	83	83	Clean up before exit
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	7	7	www.youtube.com/watch?v=DUZHe1nz6bs.
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	12	12	Constructor
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	15	15	Member initialization list
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	19	19	Allocate memory for the rows in the grid
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	22	22	Allocate memory for the columns in the grid
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	27	27	Set all of the values in the grid to 0.0
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	36	36	Destructor
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	39	39	Free the memory allocated for the rows
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	41	41	Delete the individual elements
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	44	45	Free the memory allocated for the grid\nDelete the array of pointers
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	49	49	Setter Function: Set the potential of a specific element in the grid (coordinate comes from the PotentialField class)
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	54	54	Getter Function: Get the value of a specific element in the grid
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	63	63	Iterate through all goals and obstacles to compute the potential components
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	67	67	Check if it's a goal or obstacle
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	69	70	Avoid division by zero\nGoal
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	73	73	Obstacle
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	83	83	Reset Function: Resets the value of the potential of each element in the grid to 0.0
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.cpp	92	92	Print the grid for debugging -- TO BE REMOVED
86654dd9	f24	p0	2024-09-21 22:57:58	Grid.h	16	16	REMOVE LATER
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	5	5	Constructor
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	14	14	resetPotential();
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	17	17	Destructor
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	25	25	Set goal
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	30	30	Set obstacle
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	36	36	Initialize all cells in the potential grid to 0.0
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	39	40	Reset goals and obstacles\nReset potential values
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	46	46	Use the Grid class's getPotential method
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	62	62	Initialize for each cell
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	65	65	Robot's cell; set potential to 0
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	70	70	Loop through all cells in goalObstacleGrid
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	77	77	Goal
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	79	79	Obstacle
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	87	87	Update the potential in the grid
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	94	94	Update K to the new value
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	96	96	Recalculate the potentials for all cells in the grid
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	100	100	Skip goals and obstacles
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.cpp	103	103	Recalculate potential for this cell
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	8	8	Constructor
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	11	11	Destructor
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	14	14	Add a goal to the grid
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	17	17	Add an obstacle to the grid
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	20	20	Reset the potential grid and goal/obstacle grid
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	23	23	Gets the potential from the Grid class
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	26	26	Sets the constant k
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	29	29	Function to update potentials using a new K value
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	34	34	void move(int x, int y, double &Px, double &Py);
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	36	36	TO BE DELETED
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	39	39	Update the potential of the grid based on the current goals and obstacles
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	42	42	Grid dimensions
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	46	46	Constant used for potential calculation
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	49	49	Grid to keep track of goals and obstacles
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	52	52	Grid to store potential values
86654dd9	f24	p0	2024-09-21 22:57:58	PotentialField.h	56	56	POTENTIALFIELD_H
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	16	16	Delete old field if it exists
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	19	19	Create new field with initial K=1
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	31	31	Add goal
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	34	34	Add obstacle
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	39	39	Out of bounds or no field created
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	50	50	Output Px and Py
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	58	58	Reset the grid
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	62	62	No map created yet
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	71	71	Recalculate potential field
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	75	75	Invalid K or no field created
86654dd9	f24	p0	2024-09-21 22:57:58	test.cpp	83	83	Clean up before exit
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	7	7	www.youtube.com/watch?v=DUZHe1nz6bs.
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	12	12	Constructor
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	15	15	Member initialization list
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	19	19	Allocate memory for the rows in the grid
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	22	22	Allocate memory for the columns in the grid
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	27	27	Set all of the values in the grid to 0.0
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	36	36	Destructor
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	39	39	Free the memory allocated for the rows
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	41	41	Delete the individual elements
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	44	45	Free the memory allocated for the grid\nDelete the array of pointers
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	49	49	Setter Function: Set the potential of a specific element in the grid (coordinate comes from the PotentialField class)
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	54	54	Getter Function: Get the value of a specific element in the grid
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	63	63	Iterate through all goals and obstacles to compute the potential components
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	67	67	Check if it's a goal or obstacle
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	69	70	Avoid division by zero\nGoal
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	73	73	Obstacle
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	83	83	Reset Function: Resets the value of the potential of each element in the grid to 0.0
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.cpp	92	92	Print the grid for debugging -- TO BE REMOVED
86654dd9	f24	p0	2024-09-22 12:28:29	Grid.h	16	16	REMOVE LATER
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	5	5	Constructor
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	14	14	resetPotential();
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	17	17	Destructor
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	25	25	Set goal
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	30	30	Set obstacle
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	36	36	Initialize all cells in the potential grid to 0.0
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	39	40	Reset goals and obstacles\nReset potential values
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	46	46	Use the Grid class's getPotential method
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	62	62	Initialize for each cell
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	65	65	Robot's cell; set potential to 0
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	70	70	Loop through all cells in goalObstacleGrid
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	77	77	Goal
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	79	79	Obstacle
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	87	87	Update the potential in the grid
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	94	94	Update K to the new value
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	96	96	Recalculate the potentials for all cells in the grid
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	100	100	Skip goals and obstacles
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.cpp	103	103	Recalculate potential for this cell
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	8	8	Constructor
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	11	11	Destructor
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	14	14	Add a goal to the grid
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	17	17	Add an obstacle to the grid
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	20	20	Reset the potential grid and goal/obstacle grid
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	23	23	Gets the potential from the Grid class
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	26	26	Sets the constant k
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	29	29	Function to update potentials using a new K value
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	34	34	void move(int x, int y, double &Px, double &Py);
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	36	36	TO BE DELETED
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	39	39	Update the potential of the grid based on the current goals and obstacles
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	42	42	Grid dimensions
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	46	46	Constant used for potential calculation
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	49	49	Grid to keep track of goals and obstacles
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	52	52	Grid to store potential values
86654dd9	f24	p0	2024-09-22 12:28:29	PotentialField.h	56	56	POTENTIALFIELD_H
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	16	16	Delete old field if it exists
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	19	19	Create new field with initial K=1
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	31	31	Add goal
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	34	34	Add obstacle
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	39	39	Out of bounds or no field created
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	50	50	Output Px and Py
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	58	58	Reset the grid
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	62	62	No map created yet
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	71	71	Recalculate potential field
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	75	75	Invalid K or no field created
86654dd9	f24	p0	2024-09-22 12:28:29	test.cpp	83	83	Clean up before exit
87980689	f24	p0	2024-09-17 19:18:59	p0.cpp	3	3	#include <fstream>
87980689	f24	p0	2024-09-17 19:18:59	p0.cpp	8	16	class RobotNavigation {\nprivate:\ndouble** grid;  // 2D array to store potentials\nint rows;\nint cols;\ndouble K;  // Constant to adjust potential magnitude\nstd::string* positions; // Store positions as strings (either goals or obstacles)\nint positionCount; // Keep track of the number of positions added\nint maxPositions;  // Maximum number of positions that can be stored
87980689	f24	p0	2024-09-17 19:18:59	p0.cpp	18	18	// Custom square root function using the Babylonian method
87980689	f24	p0	2024-09-17 19:18:59	p0.cpp	20	27	public:\nvoid create(int n, int m);\nvoid point(char t, int x, int y);\nvoid recomputePotential();\ndouble calculatePotential(int x, int y, int targetX, int targetY, char type);  // Helper function for computing potential\nvoid move(int x, int y);\nvoid update(double k);\nvoid clear();  // Fixed the clear() declaration
87980689	f24	p0	2024-09-17 19:18:59	p0.cpp	29	30	~RobotNavigation();\n};
87980689	f24	p0	2024-09-17 19:18:59	p0.cpp	32	32	Destructor
87980689	f24	p0	2024-09-17 20:14:50	p0.cpp	3	3	#include <fstream>
87980689	f24	p0	2024-09-17 20:14:50	p0.cpp	8	16	class RobotNavigation {\nprivate:\ndouble** grid;  // 2D array to store potentials\nint rows;\nint cols;\ndouble K;  // Constant to adjust potential magnitude\nstd::string* positions; // Store positions as strings (either goals or obstacles)\nint positionCount; // Keep track of the number of positions added\nint maxPositions;  // Maximum number of positions that can be stored
87980689	f24	p0	2024-09-17 20:14:50	p0.cpp	18	18	// Custom square root function using the Babylonian method
87980689	f24	p0	2024-09-17 20:14:50	p0.cpp	20	27	public:\nvoid create(int n, int m);\nvoid point(char t, int x, int y);\nvoid recomputePotential();\ndouble calculatePotential(int x, int y, int targetX, int targetY, char type);  // Helper function for computing potential\nvoid move(int x, int y);\nvoid update(double k);\nvoid clear();  // Fixed the clear() declaration
87980689	f24	p0	2024-09-17 20:14:50	p0.cpp	29	30	~RobotNavigation();\n};
87980689	f24	p0	2024-09-17 20:14:50	p0.cpp	32	32	Destructor
87980689	f24	p0	2024-09-17 20:23:03	p0.cpp	3	3	#include <fstream>
87980689	f24	p0	2024-09-17 20:23:03	p0.cpp	8	16	class RobotNavigation {\nprivate:\ndouble** grid;  // 2D array to store potentials\nint rows;\nint cols;\ndouble K;  // Constant to adjust potential magnitude\nstd::string* positions; // Store positions as strings (either goals or obstacles)\nint positionCount; // Keep track of the number of positions added\nint maxPositions;  // Maximum number of positions that can be stored
87980689	f24	p0	2024-09-17 20:23:03	p0.cpp	18	18	// Custom square root function using the Babylonian method
87980689	f24	p0	2024-09-17 20:23:03	p0.cpp	20	27	public:\nvoid create(int n, int m);\nvoid point(char t, int x, int y);\nvoid recomputePotential();\ndouble calculatePotential(int x, int y, int targetX, int targetY, char type);  // Helper function for computing potential\nvoid move(int x, int y);\nvoid update(double k);\nvoid clear();  // Fixed the clear() declaration
87980689	f24	p0	2024-09-17 20:23:03	p0.cpp	29	30	~RobotNavigation();\n};
87980689	f24	p0	2024-09-17 20:23:03	p0.cpp	32	32	Destructor
87980689	f24	p0	2024-09-17 20:24:28	p0.cpp	3	3	#include <fstream>
87980689	f24	p0	2024-09-17 20:24:28	p0.cpp	8	16	class RobotNavigation {\nprivate:\ndouble** grid;  // 2D array to store potentials\nint rows;\nint cols;\ndouble K;  // Constant to adjust potential magnitude\nstd::string* positions; // Store positions as strings (either goals or obstacles)\nint positionCount; // Keep track of the number of positions added\nint maxPositions;  // Maximum number of positions that can be stored
87980689	f24	p0	2024-09-17 20:24:28	p0.cpp	18	18	// Custom square root function using the Babylonian method
87980689	f24	p0	2024-09-17 20:24:28	p0.cpp	20	27	public:\nvoid create(int n, int m);\nvoid point(char t, int x, int y);\nvoid recomputePotential();\ndouble calculatePotential(int x, int y, int targetX, int targetY, char type);  // Helper function for computing potential\nvoid move(int x, int y);\nvoid update(double k);\nvoid clear();  // Fixed the clear() declaration
87980689	f24	p0	2024-09-17 20:24:28	p0.cpp	29	30	~RobotNavigation();\n};
87980689	f24	p0	2024-09-17 20:24:28	p0.cpp	32	32	Destructor
87980689	f24	p0	2024-09-17 20:47:36	p0.cpp	9	9	Use the clear function to deallocate memory
87980689	f24	p0	2024-09-17 20:47:36	p0.cpp	31	31	Clear any existing data before creating a new grid
87980689	f24	p0	2024-09-17 20:52:23	p0.cpp	9	9	Use the clear function to deallocate memory
87980689	f24	p0	2024-09-17 20:52:23	p0.cpp	31	31	Clear any existing data before creating a new grid
87980689	f24	p0	2024-09-17 20:57:26	p0.cpp	9	9	Use the clear function to deallocate memory
87980689	f24	p0	2024-09-17 20:57:26	p0.cpp	30	30	Clear any existing data before creating a new grid
87980689	f24	p0	2024-09-17 21:06:02	p0.cpp	3	3	#include <fstream>
87980689	f24	p0	2024-09-17 21:06:02	p0.cpp	8	16	class RobotNavigation {\nprivate:\ndouble** grid;  // 2D array to store potentials\nint rows;\nint cols;\ndouble K;  // Constant to adjust potential magnitude\nstd::string* positions; // Store positions as strings (either goals or obstacles)\nint positionCount; // Keep track of the number of positions added\nint maxPositions;  // Maximum number of positions that can be stored
87980689	f24	p0	2024-09-17 21:06:02	p0.cpp	18	18	// Custom square root function using the Babylonian method
87980689	f24	p0	2024-09-17 21:06:02	p0.cpp	20	27	public:\nvoid create(int n, int m);\nvoid point(char t, int x, int y);\nvoid recomputePotential();\ndouble calculatePotential(int x, int y, int targetX, int targetY, char type);  // Helper function for computing potential\nvoid move(int x, int y);\nvoid update(double k);\nvoid clear();  // Fixed the clear() declaration
87980689	f24	p0	2024-09-17 21:06:02	p0.cpp	29	30	~RobotNavigation();\n};
87980689	f24	p0	2024-09-17 21:06:02	p0.cpp	32	32	Destructor
87980689	f24	p0	2024-09-17 21:06:02	p0.cpp	135	137	int main() {\nRobotNavigation grid;\nstd::string command;
87980689	f24	p0	2024-09-17 21:06:02	p0.cpp	139	162	while (std::cin >> command) {\nif (command == "CREATE") {\nint n, m;\nstd::cin >> n >> m;\ngrid.create(n, m);\n} else if (command == "POINT") {\nchar t;\nint x, y;\nstd::cin >> t >> x >> y;\ngrid.point(t, x, y);\n} else if (command == "MOVE") {\nint x, y;\nstd::cin >> x >> y;\ngrid.move(x, y);\n} else if (command == "CLEAR") {\ngrid.clear();\n} else if (command == "UPDATE") {\ndouble k;\nstd::cin >> k;\ngrid.update(k);\n} else if (command == "EXIT") {\nbreak;\n}\n}
87980689	f24	p0	2024-09-17 21:06:02	p0.cpp	164	165	return 0;\n}
87980689	f24	p0	2024-09-17 21:06:02	p0.h	17	17	RobotNavigation();
87980689	f24	p0	2024-09-17 21:42:39	p0.cpp	3	3	#include <fstream>
87980689	f24	p0	2024-09-17 21:42:39	p0.cpp	8	16	class RobotNavigation {\nprivate:\ndouble** grid;  // 2D array to store potentials\nint rows;\nint cols;\ndouble K;  // Constant to adjust potential magnitude\nstd::string* positions; // Store positions as strings (either goals or obstacles)\nint positionCount; // Keep track of the number of positions added\nint maxPositions;  // Maximum number of positions that can be stored
87980689	f24	p0	2024-09-17 21:42:39	p0.cpp	18	18	// Custom square root function using the Babylonian method
87980689	f24	p0	2024-09-17 21:42:39	p0.cpp	20	27	public:\nvoid create(int n, int m);\nvoid point(char t, int x, int y);\nvoid recomputePotential();\ndouble calculatePotential(int x, int y, int targetX, int targetY, char type);  // Helper function for computing potential\nvoid move(int x, int y);\nvoid update(double k);\nvoid clear();  // Fixed the clear() declaration
87980689	f24	p0	2024-09-17 21:42:39	p0.cpp	29	30	~RobotNavigation();\n};
87980689	f24	p0	2024-09-17 21:42:39	p0.cpp	32	32	Destructor
87980689	f24	p0	2024-09-17 21:42:39	p0.cpp	135	137	int main() {\nRobotNavigation grid;\nstd::string command;
87980689	f24	p0	2024-09-17 21:42:39	p0.cpp	139	162	while (std::cin >> command) {\nif (command == "CREATE") {\nint n, m;\nstd::cin >> n >> m;\ngrid.create(n, m);\n} else if (command == "POINT") {\nchar t;\nint x, y;\nstd::cin >> t >> x >> y;\ngrid.point(t, x, y);\n} else if (command == "MOVE") {\nint x, y;\nstd::cin >> x >> y;\ngrid.move(x, y);\n} else if (command == "CLEAR") {\ngrid.clear();\n} else if (command == "UPDATE") {\ndouble k;\nstd::cin >> k;\ngrid.update(k);\n} else if (command == "EXIT") {\nbreak;\n}\n}
87980689	f24	p0	2024-09-17 21:42:39	p0.cpp	164	165	return 0;\n}
87980689	f24	p0	2024-09-17 21:42:39	p0.h	17	17	RobotNavigation();
87980689	f24	p0	2024-09-18 00:39:55	p0.cpp	8	8	Destructor
87980689	f24	p0	2024-09-18 00:39:55	p0.cpp	87	87	Optionally handle position array being full
87980689	f24	p0	2024-09-18 00:39:55	p0.cpp	106	106	Debug print to verify potential calculation
87980689	f24	p0	2024-09-18 00:39:55	p0.cpp	129	130	Debug prints to verify parsing\nstd::cout << "Type: " << type << ", posX: " << posX << ", posY: " << posY << std::endl;
87980689	f24	p0	2024-09-18 00:39:55	p0.cpp	136	137	Debug print to see what's happening\nstd::cout << "Potential at (" << x << ", " << y << ") due to (" << posX << ", " << posY << "): " << potential << std::endl;
87980689	f24	p0	2024-09-18 00:42:14	p0.cpp	8	8	Destructor
87980689	f24	p0	2024-09-18 00:42:14	p0.cpp	87	87	Optionally handle position array being full
87980689	f24	p0	2024-09-18 00:42:14	p0.cpp	106	106	Debug print to verify potential calculation
87980689	f24	p0	2024-09-18 00:42:14	p0.cpp	129	130	Debug prints to verify parsing\nstd::cout << "Type: " << type << ", posX: " << posX << ", posY: " << posY << std::endl;
87980689	f24	p0	2024-09-18 00:42:14	p0.cpp	136	137	Debug print to see what's happening\nstd::cout << "Potential at (" << x << ", " << y << ") due to (" << posX << ", " << posY << "): " << potential << std::endl;
87980689	f24	p0	2024-09-18 04:04:36	p0.cpp	9	9	Destructor
87980689	f24	p0	2024-09-18 04:04:36	p0.cpp	78	78	Initialize with [0, i, j]
87980689	f24	p0	2024-09-18 04:04:36	p0.cpp	95	95	Determine if it's a goal (1) or an obstacle (-1)
87980689	f24	p0	2024-09-18 04:04:36	p0.cpp	98	98	Update the position at grid[x][y]
87980689	f24	p0	2024-09-18 04:04:36	p0.cpp	131	131	Iterate through the positions array and calculate potential
87980689	f24	p0	2024-09-18 04:04:36	p0.cpp	134	135	Check if it's a goal or obstacle\nConvert back to char for potential calculation
87980689	f24	p0	2024-09-18 04:04:36	p0.h	9	9	Use a 3D array for positions where positions[x][y] -> [goal/obstacle, x, y]
87980689	f24	p0	2024-09-18 04:08:23	p0.cpp	8	8	Destructor
87980689	f24	p0	2024-09-18 04:25:28	p0.cpp	8	8	Destructor
87980689	f24	p0	2024-09-18 04:25:28	p0.cpp	77	77	Initialize with [0, i, j]
87980689	f24	p0	2024-09-18 04:25:28	p0.cpp	131	131	Iterate through the positions array and calculate potential
87980689	f24	p0	2024-09-18 04:25:28	p0.cpp	134	135	Check if it's a goal or obstacle\nConvert back to char for potential calculation
87980689	f24	p0	2024-09-18 13:23:38	p0.cpp	8	8	Destructor
87980689	f24	p0	2024-09-18 14:56:55	p0.cpp	8	8	Destructor
87980689	f24	p0	2024-09-18 18:00:46	p0.cpp	8	8	Destructor
87980689	f24	p0	2024-09-18 18:00:46	p0.cpp	77	77	Initialize with [0, i, j]
87980689	f24	p0	2024-09-18 18:00:46	p0.cpp	131	131	Iterate through the positions array and calculate potential
87980689	f24	p0	2024-09-18 18:00:46	p0.cpp	134	135	Check if it's a goal or obstacle\nConvert back to char for potential calculation
87980689	f24	p0	2024-09-18 18:33:09	p0.cpp	76	76	Initialize with [0, i, j]
87980689	f24	p0	2024-09-18 18:33:09	p0.cpp	128	128	Iterate through the positions array and calculate potential
87980689	f24	p0	2024-09-18 18:33:09	p0.cpp	131	132	Check if it's a goal or obstacle\nConvert back to char for potential calculation
87980689	f24	p0	2024-09-18 18:33:44	p0.cpp	76	76	Initialize with [0, i, j]
87980689	f24	p0	2024-09-18 18:33:44	p0.cpp	128	128	Iterate through the positions array and calculate potential
87980689	f24	p0	2024-09-18 18:33:44	p0.cpp	131	132	Check if it's a goal or obstacle\nConvert back to char for potential calculation
87980689	f24	p0	2024-09-20 19:51:12	project_0.cpp	4	4	Constructor
87980689	f24	p0	2024-09-20 19:51:12	project_0.cpp	15	15	Destructor to free the memory for the 2D array
87980689	f24	p0	2024-09-20 19:51:12	project_0.cpp	23	23	To update potential field after placing a goal or obstacle
87980689	f24	p0	2024-09-20 19:51:12	project_0.cpp	39	39	To place goals or obstacles and recalculate potential field
87980689	f24	p0	2024-09-20 19:51:12	project_0.cpp	49	49	Suggests potential values at the given (x, y) position
87980689	f24	p0	2024-09-20 19:51:12	project_0.cpp	62	62	To clear the grid and reset potentials
87980689	f24	p0	2024-09-20 19:51:12	project_0.cpp	72	72	ToU update the force constant used in the potential field calculations
87980689	f24	p0	2024-09-20 19:51:12	project_0.h	15	15	Our main dynamically allocated 2D array
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	7	7	gotta figure this out.
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	14	14	Creates cell object for each grid on the panel
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	16	16	for deletion
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	30	30	pointer to row
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	32	32	Create array for cells
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	34	34	each row has array size M (representing columns)
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	37	38	address of arr[i][j]\nhere I initialize every grid with class cell
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	40	40	might want to delete
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	48	50	uses classes K which also gets updated with the UPDATE function\nfloat potgoal{};\nfloat potobstacle{};
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	52	52	reset to 0 for no funny stuff
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	59	59	cycles through focusing on single cell and i and j calculate total
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	62	63	what i imagined here was it would cycle through the graph grid by grid, and calculate the potential due to every other goal or obstacle\ncycles through grid checking states
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	67	67	distance being zero indicates looking at same cell
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	77	77	change the potential of that cell by adding the effect of G/O
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	88	89	std::cout << "cell 4 2 potential "  << *arr[4][2].getPotential() << std::endl;\nstd::cout << "cell 4 4 state "  << arr[4][4].getState() << std::endl;
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	93	95	for (int i = 0; i < N; i++){ // cycles through entire array\nfor(int j = 0; j < M; j++){\nif (s == 'G'){
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	97	102	arr[i][j].addPotential(potgoal,potgoal);\n}\nelse{\npotobstacle = ((k)/sqrt(pow( i - xM, 2) + pow(j - yM, 2)));\narr[i][j].addPotential(potobstacle,potobstacle);\n}
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	104	106	//assign value  to each cell of array\n}\n}
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	109	109	things to do if cell is normal, onstacle or goal
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	113	113	update after placing
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	118	118	update after placing
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	137	137	am
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	146	146	cycles through entire array
88451d1a	f24	p0	2024-09-21 15:20:40	Board.cpp	149	149	resets to 0 and sets every tile to normal state as asked
88451d1a	f24	p0	2024-09-21 15:20:40	Board.h	8	10	Include stringstream\nInclude string for getline\nRequired for ceil function
88451d1a	f24	p0	2024-09-21 15:20:40	Board.h	22	22	this function does all the calculations
88451d1a	f24	p0	2024-09-21 15:20:40	Board.h	25	25	this is constructor
88451d1a	f24	p0	2024-09-21 15:20:40	Board.h	28	28	Member functions
88451d1a	f24	p0	2024-09-21 15:20:40	Board.h	36	36	Destructor
88451d1a	f24	p0	2024-09-21 15:20:40	Board.h	47	47	BOARD_H
88451d1a	f24	p0	2024-09-21 15:20:40	Cell.cpp	6	6	setters and getters for priv vars
88451d1a	f24	p0	2024-09-21 15:20:40	Cell.h	10	10	G for goal, O for obstacle, N for normal
88451d1a	f24	p0	2024-09-21 15:20:40	Cell.h	18	19	Call with no arguements\nCall with position
88451d1a	f24	p0	2024-09-21 15:20:40	Cell.h	24	24	CELL_H
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	7	7	gotta figure this out.
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	14	14	Creates cell object for each grid on the panel
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	16	16	for deletion
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	30	30	pointer to row
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	32	32	Create array for cells
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	34	34	each row has array size M (representing columns)
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	37	38	address of arr[i][j]\nhere I initialize every grid with class cell
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	40	40	might want to delete
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	48	50	uses classes K which also gets updated with the UPDATE function\nfloat potgoal{};\nfloat potobstacle{};
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	52	52	reset to 0 for no funny stuff
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	59	59	cycles through focusing on single cell and i and j calculate total
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	62	63	what i imagined here was it would cycle through the graph grid by grid, and calculate the potential due to every other goal or obstacle\ncycles through grid checking states
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	67	67	distance being zero indicates looking at same cell
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	77	77	change the potential of that cell by adding the effect of G/O
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	88	89	std::cout << "cell 4 2 potential "  << *arr[4][2].getPotential() << std::endl;\nstd::cout << "cell 4 4 state "  << arr[4][4].getState() << std::endl;
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	93	95	for (int i = 0; i < N; i++){ // cycles through entire array\nfor(int j = 0; j < M; j++){\nif (s == 'G'){
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	97	102	arr[i][j].addPotential(potgoal,potgoal);\n}\nelse{\npotobstacle = ((k)/sqrt(pow( i - xM, 2) + pow(j - yM, 2)));\narr[i][j].addPotential(potobstacle,potobstacle);\n}
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	104	106	//assign value  to each cell of array\n}\n}
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	109	109	things to do if cell is normal, onstacle or goal
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	113	113	update after placing
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	118	118	update after placing
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	137	137	am
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	146	146	cycles through entire array
88451d1a	f24	p0	2024-09-21 15:23:53	Board.cpp	149	149	resets to 0 and sets every tile to normal state as asked
88451d1a	f24	p0	2024-09-21 15:23:53	Board.h	8	10	Include stringstream\nInclude string for getline\nRequired for ceil function
88451d1a	f24	p0	2024-09-21 15:23:53	Board.h	22	22	this function does all the calculations
88451d1a	f24	p0	2024-09-21 15:23:53	Board.h	25	25	this is constructor
88451d1a	f24	p0	2024-09-21 15:23:53	Board.h	28	28	Member functions
88451d1a	f24	p0	2024-09-21 15:23:53	Board.h	36	36	Destructor
88451d1a	f24	p0	2024-09-21 15:23:53	Board.h	47	47	BOARD_H
88451d1a	f24	p0	2024-09-21 15:23:53	Cell.cpp	6	6	setters and getters for priv vars
88451d1a	f24	p0	2024-09-21 15:23:53	Cell.h	10	10	G for goal, O for obstacle, N for normal
88451d1a	f24	p0	2024-09-21 15:23:53	Cell.h	18	19	Call with no arguements\nCall with position
88451d1a	f24	p0	2024-09-21 15:23:53	Cell.h	24	24	CELL_H
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	7	7	gotta figure this out.
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	14	14	Creates cell object for each grid on the panel
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	16	16	for deletion
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	30	30	pointer to row
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	32	32	Create array for cells
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	34	34	each row has array size M (representing columns)
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	37	38	address of arr[i][j]\nhere I initialize every grid with class cell
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	40	40	might want to delete
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	48	50	uses classes K which also gets updated with the UPDATE function\nfloat potgoal{};\nfloat potobstacle{};
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	52	52	reset to 0 for no funny stuff
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	59	59	cycles through focusing on single cell and i and j calculate total
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	62	63	what i imagined here was it would cycle through the graph grid by grid, and calculate the potential due to every other goal or obstacle\ncycles through grid checking states
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	67	67	distance being zero indicates looking at same cell
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	77	77	change the potential of that cell by adding the effect of G/O
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	88	89	std::cout << "cell 4 2 potential "  << *arr[4][2].getPotential() << std::endl;\nstd::cout << "cell 4 4 state "  << arr[4][4].getState() << std::endl;
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	93	95	for (int i = 0; i < N; i++){ // cycles through entire array\nfor(int j = 0; j < M; j++){\nif (s == 'G'){
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	97	102	arr[i][j].addPotential(potgoal,potgoal);\n}\nelse{\npotobstacle = ((k)/sqrt(pow( i - xM, 2) + pow(j - yM, 2)));\narr[i][j].addPotential(potobstacle,potobstacle);\n}
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	104	106	//assign value  to each cell of array\n}\n}
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	109	109	things to do if cell is normal, onstacle or goal
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	113	113	update after placing
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	118	118	update after placing
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	137	137	am
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	146	146	cycles through entire array
88451d1a	f24	p0	2024-09-21 15:36:45	Board.cpp	149	149	resets to 0 and sets every tile to normal state as asked
88451d1a	f24	p0	2024-09-21 15:36:45	Board.h	8	10	Include stringstream\nInclude string for getline\nRequired for ceil function
88451d1a	f24	p0	2024-09-21 15:36:45	Board.h	22	22	this function does all the calculations
88451d1a	f24	p0	2024-09-21 15:36:45	Board.h	25	25	this is constructor
88451d1a	f24	p0	2024-09-21 15:36:45	Board.h	28	28	Member functions
88451d1a	f24	p0	2024-09-21 15:36:45	Board.h	36	36	Destructor
88451d1a	f24	p0	2024-09-21 15:36:45	Board.h	47	47	BOARD_H
88451d1a	f24	p0	2024-09-21 15:36:45	Cell.cpp	6	6	setters and getters for priv vars
88451d1a	f24	p0	2024-09-21 15:36:45	Cell.h	10	10	G for goal, O for obstacle, N for normal
88451d1a	f24	p0	2024-09-21 15:36:45	Cell.h	18	19	Call with no arguements\nCall with position
88451d1a	f24	p0	2024-09-21 15:36:45	Cell.h	24	24	CELL_H
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	7	7	gotta figure this out.
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	14	14	Creates cell object for each grid on the panel
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	16	16	for deletion
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	30	30	pointer to row
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	32	32	Create array for cells
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	34	34	each row has array size M (representing columns)
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	37	38	address of arr[i][j]\nhere I initialize every grid with class cell
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	40	40	might want to delete
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	48	48	uses classes K which also gets updated with the UPDATE function
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	53	53	reset to 0 for no funny stuff
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	60	60	cycles through focusing on single cell and i and j calculate total
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	63	64	what i imagined here was it would cycle through the graph grid by grid, and calculate the potential due to every other goal or obstacle\ncycles through grid checking states
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	68	68	distance being zero indicates looking at same cell
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	78	78	change the potential of that cell by adding the effect of G/O
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	89	90	std::cout << "cell 4 2 potential "  << *arr[4][2].getPotential() << std::endl;\nstd::cout << "cell 4 4 state "  << arr[4][4].getState() << std::endl;
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	94	96	for (int i = 0; i < N; i++){ // cycles through entire array\nfor(int j = 0; j < M; j++){\nif (s == 'G'){
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	98	103	arr[i][j].addPotential(potgoal,potgoal);\n}\nelse{\npotobstacle = ((k)/sqrt(pow( i - xM, 2) + pow(j - yM, 2)));\narr[i][j].addPotential(potobstacle,potobstacle);\n}
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	105	107	//assign value  to each cell of array\n}\n}
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	110	110	things to do if cell is normal, onstacle or goal
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	114	114	update after placing
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	119	119	update after placing
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	138	138	am
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	147	147	cycles through entire array
88451d1a	f24	p0	2024-09-23 12:19:35	Board.cpp	150	150	resets to 0 and sets every tile to normal state as asked
88451d1a	f24	p0	2024-09-23 12:19:35	Board.h	8	10	Include stringstream\nInclude string for getline\nRequired for ceil function
88451d1a	f24	p0	2024-09-23 12:19:35	Board.h	22	22	this function does all the calculations
88451d1a	f24	p0	2024-09-23 12:19:35	Board.h	25	25	this is constructor
88451d1a	f24	p0	2024-09-23 12:19:35	Board.h	28	28	Member functions
88451d1a	f24	p0	2024-09-23 12:19:35	Board.h	36	36	Destructor
88451d1a	f24	p0	2024-09-23 12:19:35	Board.h	47	47	BOARD_H
88451d1a	f24	p0	2024-09-23 12:19:35	Cell.cpp	6	6	setters and getters for priv vars
88451d1a	f24	p0	2024-09-23 12:19:35	Cell.h	10	10	G for goal, O for obstacle, N for normal
88451d1a	f24	p0	2024-09-23 12:19:35	Cell.h	18	19	Call with no arguements\nCall with position
88451d1a	f24	p0	2024-09-23 12:19:35	Cell.h	24	24	CELL_H
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	1	1	This destructor will automatically clear the memory when the Map object is destroyed
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	6	6	This function will clear the allocated memory that was used for the map.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	8	8	Just ensuring that the map exists
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	10	10	Free "x" direction arrays.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	12	13	Free outermost array, the "y" direction arrays.\nRemoving the pointer, to avoid dangling pointer
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	17	17	This creates a map of size N x M (XxY).
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	19	19	Basically "Deletes Map" (Free previous memory if a map exists).
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	22	22	Set variable value dependent on the array's properties.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	28	28	Allocate memory for the new 2D array
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	31	31	Making sub-arrays of size N.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	33	33	Default Value for each grid is X, which means it is neither a Goal or Object.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	40	40	This adds a Goal or Obstacle at position (xG, yG).
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	43	43	Ensures that the map is created and the coordinates are within bounds
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	49	49	Sets the grid to type T (Object, or Goal).
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	59	59	This gives back the potential at (x, y).
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	61	61	Ensures that the data input is within the limits of the map & that there is a map.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	67	67	we get the potential at point x,y from the function "calcPotField" and then just output it.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	73	74	Calculates the potential at grid xM,yM.\nx Move and y Move
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	78	79	big o of M then N\nlogic inside the for loops Runs O(1)
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	81	81	Itterates over the whole map and calculates the potential at the point.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	86	86	Calculates the distance from the the point xM yM to each grid point
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	88	88	If distance is 0 we skip it.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	107	107	This removes all positions of the Goals and Objects.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	109	109	Ensures that we have a map before doing anything.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	115	115	Iterate over map and sets all values back to X.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	128	128	This updates the value of K used in potential calculations.
88451d1a	f24	p0	2024-09-23 12:58:30	logic.cpp	130	130	Check if the new value of K is valid (must be positive)
88451d1a	f24	p0	2024-09-23 12:58:30	main.cpp	6	6	To store the input.
88451d1a	f24	p0	2024-09-23 12:58:30	main.cpp	9	9	We create an instance of the Map.
88451d1a	f24	p0	2024-09-23 12:58:30	main.cpp	12	12	Loop to process commands
88451d1a	f24	p0	2024-09-23 12:58:30	main.hpp	4	5	input/output\nUsed for math
88451d1a	f24	p0	2024-09-23 12:58:30	main.hpp	11	14	2D array to store the location of the Goals and Obstacles\nNumber of rows in the map\nNumber of columns in the map\nConstant used for potential calculations
88451d1a	f24	p0	2024-09-23 12:58:30	main.hpp	16	16	Calculates the potential at grid xM,yM by itterating over the whole map.
88451d1a	f24	p0	2024-09-23 12:58:30	main.hpp	19	19	This function will clear the allocated memory that was used for the map.
88451d1a	f24	p0	2024-09-23 12:58:30	main.hpp	23	23	Destructor
88451d1a	f24	p0	2024-09-23 12:58:30	main.hpp	26	26	Member functions
88451d1a	f24	p0	2024-09-23 12:58:30	main.hpp	34	34	MAIN_H
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	6	6	update k for use in calculating potentials
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	14	14	Creates cell object for each grid on the panel
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	16	16	for deletion
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	30	30	pointer to row
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	32	32	Create array for cells
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	34	34	each row has array size M (representing columns)
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	37	38	address of arr[i][j]\nhere I initialize every grid with class cell
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	40	40	might want to delete
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	48	48	uses classes K which also gets updated with the UPDATE function
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	53	53	reset to 0 for no funny stuff
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	60	60	cycles through focusing on single cell and i and j calculate total
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	63	64	what i imagined here was it would cycle through the graph grid by grid, and calculate the potential due to every other goal or obstacle\ncycles through grid checking states
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	68	68	distance being zero indicates looking at same cell
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	78	78	change the potential of that cell by adding the effect of G/O
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	91	91	things to do if cell is normal, onstacle or goal
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	95	95	update after placing
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	100	100	update after placing
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	127	127	cycles through entire array
88451d1a	f24	p0	2024-09-23 20:06:20	Board.cpp	130	130	resets to 0 and sets every tile to normal state as asked
88451d1a	f24	p0	2024-09-23 20:06:20	Board.h	8	10	Include stringstream\nInclude string for getline\nRequired for ceil function
88451d1a	f24	p0	2024-09-23 20:06:20	Board.h	22	22	this function does all the calculations
88451d1a	f24	p0	2024-09-23 20:06:20	Board.h	25	25	this is constructor
88451d1a	f24	p0	2024-09-23 20:06:20	Board.h	28	28	Member functions
88451d1a	f24	p0	2024-09-23 20:06:20	Board.h	35	35	Destructor
88451d1a	f24	p0	2024-09-23 20:06:20	Board.h	46	46	BOARD_H
88451d1a	f24	p0	2024-09-23 20:06:20	Cell.cpp	6	6	setters and getters for priv vars
88451d1a	f24	p0	2024-09-23 20:06:20	Cell.h	10	10	G for goal, O for obstacle, N for normal
88451d1a	f24	p0	2024-09-23 20:06:20	Cell.h	18	19	Call with no arguements\nCall with position
88451d1a	f24	p0	2024-09-23 20:06:20	Cell.h	24	24	CELL_H
8af034e5	f24	p0	2024-09-23 18:50:41	main.cpp	30	30	K = 1 by default
8af034e5	f24	p0	2024-09-23 18:50:41	main.cpp	92	92	Clean up memory before exiting
8af034e5	f24	p0	2024-09-23 18:50:41	potentialField.cpp	35	35	X represents empty space
8af034e5	f24	p0	2024-09-23 18:50:41	potentialField.cpp	63	63	denominator of vector field equation
8af034e5	f24	p0	2024-09-23 18:50:41	potentialField.cpp	87	88	assign goal/obstacle to grid\nupdate potential field
8af034e5	f24	p0	2024-09-23 18:50:41	potentialField.cpp	110	110	MAKE SURE TO INITIALIZE TO 0
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-11 13:09:35	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-11 13:11:29	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-11 13:13:52	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-11 18:10:14	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-11 18:13:24	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-11 18:16:34	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-11 18:39:09	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-12 17:16:01	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-13 13:33:26	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-13 14:05:17	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	32	32	Point Map
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	35	35	Potential Map
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	38	38	Array dimensions
8bc90be6	f24	p0	2024-09-16 18:17:24	project0.hpp	41	41	Constant
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	32	32	Grid
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	35	35	Array dimensions
8bc90be6	f24	p0	2024-09-16 20:21:33	potential.hpp	38	38	Constant
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	32	32	Grid
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	35	35	Array dimensions
8bc90be6	f24	p0	2024-09-16 20:34:19	potential.hpp	38	38	Constant
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	32	32	Grid
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	35	35	Array dimensions
8bc90be6	f24	p0	2024-09-16 20:42:20	potential.hpp	38	38	Constant
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	32	32	Grid
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	35	35	Array dimensions
8bc90be6	f24	p0	2024-09-16 20:45:02	potential.hpp	38	38	Constant
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	32	32	Grid
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	35	35	Array dimensions
8bc90be6	f24	p0	2024-09-16 20:52:03	potential.hpp	38	38	Constant
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	32	32	Grid
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	35	35	Array dimensions
8bc90be6	f24	p0	2024-09-17 12:28:45	potential.hpp	38	38	Constant
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	32	32	Grid
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	35	35	Array dimensions
8bc90be6	f24	p0	2024-09-17 13:22:48	potential.hpp	38	38	Constant
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	32	32	Grid
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	35	35	Array dimensions
8bc90be6	f24	p0	2024-09-18 15:04:49	potential.hpp	38	38	Constant
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	9	9	Constructor (CREATE)
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	12	12	Destructor
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	15	15	POINT
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	18	18	MOVE
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	21	21	CLEAR
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	24	24	UPDATE
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	27	27	Helper
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	32	32	Grid
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	35	35	Array dimensions
8bc90be6	f24	p0	2024-09-21 14:24:54	potential.hpp	38	38	Constant
8bc90be6	f24	p0	2024-09-23 09:56:13	potential.hpp	58	58	Grid
8bc90be6	f24	p0	2024-09-23 09:56:13	potential.hpp	60	61	Max x-coordinate\nMax y-coordinate
8bc90be6	f24	p0	2024-09-23 09:56:13	potential.hpp	63	63	Map constant (k)
8c295d42	f24	p0	2024-09-22 20:21:23	potentialfieldnav.cpp	1	1	class, constructor, destructor, dynamic 2d array, design doc
8c295d42	f24	p0	2024-09-22 21:13:48	potentialfieldnav.cpp	1	1	class, constructor, destructor, dynamic 2d array, design doc
8c295d42	f24	p0	2024-09-22 21:47:14	potentialfieldnav.cpp	1	1	class, constructor, destructor, dynamic 2d array, design doc
8c295d42	f24	p0	2024-09-23 20:41:29	potentialfieldnav.cpp	1	1	class, constructor, destructor, dynamic 2d array, design doc
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	6	6	Constructor - Initializes an empty grid with 0 rows, 0 columns, and a potential constant K of 1.0
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	9	9	Destructor - Cleans up dynamically allocated memory for the grid (both field and map arrays)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	12	12	Deallocate memory for the field array
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	17	17	Deallocate each row
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	19	20	Deallocate the main array\nAvoid dangling pointer
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	23	23	Deallocate memory for the map array
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	28	28	Deallocate each row
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	30	31	Deallocate the main array\nAvoid dangling pointer
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	35	35	create - Initializes a new grid of size N x M, and sets K to its default value (1.0)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	38	38	Clean up any existing grid if it exists
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	59	59	Update grid size and initialize K
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	62	62	Reset the potential constant K to 1.0
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	64	66	Dynamically allocate memory for the new grid\nArray of Potential pointers\nArray of char pointers
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	68	68	Initialize each cell in the grid
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	71	72	Allocate memory for each row in the potential grid\nAllocate memory for each row in the map grid
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	76	77	Initialize the potential at each cell to <0, 0>\nInitialize each cell to an empty space
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	84	84	calculatePotential - Calculates the potential values across the entire grid based on a goal or obstacle at (xGoal, yGoal)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	91	91	Skip calculating potential at the goal/obstacle position
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	97	97	Handle zero distance explicitly
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	101	101	For goals, the potential is negative (attractive); for obstacles, it's positive (repulsive)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	104	104	Subtract for goal
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	109	109	Add for obstacle
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	116	116	Recalculate potentials for all goals and obstacles
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	119	119	Clear all potentials first (reset to zero)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	124	124	Reset potential
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	128	128	Recalculate potentials for all goals and obstacles in the map
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	141	141	addPoint - Adds a goal ('G') or obstacle ('O') at position (x, y)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	144	144	Check if the position is within the grid bounds
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	151	151	Mark the cell as a goal or obstacle
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	154	154	Recalculate the potential field after adding the goal/obstacle
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	161	161	updateK - Updates the value of the constant K used in potential field calculations and recalculates the potentials
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	164	164	Ensure that K is a valid positive value
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	171	171	Update K to the new value
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	174	174	Recalculate potentials after updating K
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	181	181	move - Prints the potential value at a specific position (x, y)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	184	184	Check if the position is within the grid bounds
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	187	187	Output failure if out of bounds
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	190	190	Output the potential value at the specified position
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	194	194	clear - Resets all potentia==l values to <0, 0> and clears any goals/obstacles from the grid
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	197	197	Iterate over every cell in the grid
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	202	203	Reset the potential to <0, 0>\nClear the cell (set it to empty space)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	209	209	printField - Prints the potential values in the grid (for debugging purposes)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	212	212	Iterate over the grid and print the potential at each position
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	217	217	Print the potential as (x, y)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.cpp	219	219	Move to the next line after printing a row
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	7	7	Struct to hold potential vectors
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	14	14	Grid class to handle the environment
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	20	21	Dynamically allocated 2D array for potential\nDynamically allocated 2D array for goals/obstacles
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	23	23	Helper method to calculate the potential at each point
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	26	26	Recalculate potentials for all goals and obstacles
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	30	31	Constructor\nDestructor
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	33	33	Creates a grid of size N x M
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	36	36	Adds a goal or obstacle to the grid
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	39	39	Moves the robot to the point (X, Y)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	42	42	Clears the grid
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	45	45	Updates the value of K
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	48	48	Prints the potential field (for debugging)
8c965645	f24	p0	2024-09-23 15:15:46	Grid.h	52	52	GRID_H
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	1	4	Include the header file for the Grid class\nInclude the standard input/output stream library\nInclude the string library for string manipulation\nUse the standard namespace to avoid prefixing std::
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	6	6	The main function where the program execution begins
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	9	10	Create an instance of the Grid class to manage the grid operations\nVariable to store the command input by the user
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	12	12	Continuously read commands from standard input until "EXIT" is encountered
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	15	15	If the command is "EXIT", break out of the loop and terminate the program
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	19	19	If the command is "CREATE", initialize a new grid with specified dimensions
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	22	24	Variables to store the number of rows (N) and columns (M)\nRead the grid dimensions from the input\nCall the create method of the Grid class to initialize the grid
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	26	26	If the command is "UPDATE", update the constant K used in potential field calculations
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	29	31	Variable to store the new value of K\nRead the new K value from the input\nCall the updateK method to update K and recalculate potentials
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	33	33	If the command is "POINT", add a goal or obstacle at a specified position in the grid
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	36	39	Variable to store the type of point ('G' for goal, 'O' for obstacle)\nVariables to store the coordinates of the point\nRead the type and coordinates from the input\nCall the addPoint method to add the point to the grid
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	41	41	If the command is "MOVE", attempt to move the robot to a specified position
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	44	46	Variables to store the target coordinates\nRead the target coordinates from the input\nCall the move method to attempt to move the robot
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	48	48	If the command is "CLEAR", reset the grid by clearing all goals and obstacles
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	51	51	Call the clear method to reset the grid to its initial state
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	53	53	If the command is unrecognized, output "failure" and continue
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	56	57	Handle unrecognized commands or skip them\nOutput failure message for unrecognized commands
8c965645	f24	p0	2024-09-23 15:15:46	main.cpp	61	61	Return 0 to indicate successful program execution
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	1	2	ECE 250 P0\nAuthor - Armaan Ghosh (21064006)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	7	7	Using the standard namespace to avoid prefixing std:: and make the code look cleaner
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	9	9	Constructor - Initializes an empty grid with 0 rows, 0 columns, and a potential constant K of 1.0
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	12	12	Destructor - Cleans up dynamically allocated memory for the grid (both field and map arrays)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	15	15	Deallocate memory for the field array
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	26	26	Deallocate memory for the map array
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	38	38	create - Initializes a new grid of size N x M, and sets K to its default value (1.0)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	41	41	Clean up any existing grid if it exists
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	62	62	Update grid size and initialize K
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	65	65	Reset the potential constant K to 1.0
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	67	69	Dynamically allocate memory for the new grid\nArray of Potential pointers\nArray of char pointers
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	71	71	Initialize each cell in the grid
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	74	75	Allocate memory for each row in the potential grid\nAllocate memory for each row in the map grid
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	79	80	Initialize the potential at each cell to <0, 0>\nInitialize each cell to an empty space
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	87	87	calculatePotential - Calculates the potential values across the entire grid based on a goal or obstacle at (xGoal, yGoal)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	105	105	Skip calculating potential at the goal/obstacle position
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	111	111	Check to avoid division by zero error
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	115	115	For goals, the potential is negative (attractive); for obstacles, it's positive (repulsive)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	118	118	Subtract for goal
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	123	123	Add for obstacle
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	130	130	Recalculate potentials for all goals and obstacles
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	144	144	Clear all potentials first (reset to zero)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	153	153	Recalculate potentials for all goals and obstacles in the map
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	166	166	addPoint - Adds a goal ('G') or obstacle ('O') at position (x, y)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	169	169	Check if the position is within the grid bounds
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	176	176	Mark the cell as a goal/obstacle
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	179	179	Recalculate the potential field after adding the goal/obstacle
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	186	186	updateK - Updates the value of the constant K used in potential field calculations and recalculates the potentials
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	189	189	Ensure that K is a valid positive value
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	196	196	Update K to the new value
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	199	199	Recalculate potentials after updating K
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	206	206	move - Prints the potential value at a specific position (x, y)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	211	211	Output failure if out of bounds
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	217	217	clear - Resets all potential values to <0, 0> and clears any goals/obstacles from the grid
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	231	231	printField - Prints the potential values in the grid (for debugging purposes)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.cpp	238	238	Print the potential as (x, y) for each position
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	1	2	ECE 250 P0\nAuthor - Armaan Ghosh (21064006)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	10	10	Struct to hold potential vectors
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	17	17	Grid class to handle the environment
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	23	24	Dynamically allocated 2D array for potential\nDynamically allocated 2D array for goals/obstacles
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	26	26	Helper method to calculate the potential at each point
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	29	29	Recalculate potentials for all goals and obstacles
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	33	34	Constructor\nDestructor
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	36	36	Create grid of size N x M
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	39	39	Add goal/obstacle to the grid
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	42	42	Moves the robot to the point (X, Y)
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	45	45	Clears the grid
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	48	48	Updates the value of K
8c965645	f24	p0	2024-09-23 20:06:33	Grid.h	51	51	Prints the potential field (helping to debug)
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	1	2	ECE 250 P0\nAuthor - Armaan Ghosh (21064006)
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	7	7	Using the standard namespace to avoid prefixing std:: and make the code look cleaner
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	11	12	Instance of the Grid class to manage the grid operations\nFor user input commands
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	14	14	Parser
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	17	17	If the command is "EXIT", break out of the loop and terminate the program
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	21	21	If the command is "CREATE", initialize a new grid with specified dimensions
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	24	24	rows (N) and columns (M)
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	29	29	If the command is "UPDATE", update the constant K used in potential field calculations
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	34	34	Call the updateK method to update K and recalculate potentials
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	37	37	If the command is "POINT", add a goal or obstacle at a specified position in the grid
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	40	40	Variable to store the type of point ('G' for goal, 'O' for obstacle)
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	43	43	Call the addPoint method to add the point to the grid
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	46	46	If the command is "MOVE", attempt to move the robot to a specified position
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	49	49	Variables to store the target coordinates
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	51	51	Call the move method to attempt to move the robot
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	54	54	If the command is "CLEAR", reset the grid by clearing all goals and obstacles
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	60	60	If the command is unrecognized, output "failure" and continue
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	63	63	Output failure message for unrecognized commands
8c965645	f24	p0	2024-09-23 20:06:33	main.cpp	67	67	Return 0 to indicate successful program execution
8e0b132c	f24	p0	2024-09-22 20:50:11	entity.cpp	27	27	Recomputes
8e0b132c	f24	p0	2024-09-22 20:50:11	entity.cpp	60	60	Update K Function
8e0b132c	f24	p0	2024-09-22 20:50:11	entity.cpp	68	68	Recomputes
8e0b132c	f24	p0	2024-09-22 20:50:11	grid.cpp	5	5	Constructor
8e0b132c	f24	p0	2024-09-22 20:50:11	grid.cpp	18	18	Destructor
8e0b132c	f24	p0	2024-09-22 20:50:11	grid.cpp	25	25	computes grid size function
8e0b132c	f24	p0	2024-09-22 20:50:11	grid.cpp	31	31	Checker Function
8e0b132c	f24	p0	2024-09-22 20:58:19	entity.cpp	27	27	Recomputes
8e0b132c	f24	p0	2024-09-22 20:58:19	entity.cpp	60	60	Update K Function
8e0b132c	f24	p0	2024-09-22 20:58:19	entity.cpp	68	68	Recomputes
8e0b132c	f24	p0	2024-09-22 20:58:19	grid.cpp	5	5	Constructor
8e0b132c	f24	p0	2024-09-22 20:58:19	grid.cpp	18	18	Destructor
8e0b132c	f24	p0	2024-09-22 20:58:19	grid.cpp	27	27	computes grid size function
8e0b132c	f24	p0	2024-09-22 20:58:19	grid.cpp	33	33	Checker Function
8e0b132c	f24	p0	2024-09-22 21:15:15	entity.cpp	27	27	Recomputes
8e0b132c	f24	p0	2024-09-22 21:15:15	entity.cpp	60	60	Update K Function
8e0b132c	f24	p0	2024-09-22 21:15:15	entity.cpp	68	68	Recomputes
8e0b132c	f24	p0	2024-09-22 21:15:15	grid.cpp	5	5	Constructor
8e0b132c	f24	p0	2024-09-22 21:15:15	grid.cpp	18	18	Destructor
8e0b132c	f24	p0	2024-09-22 21:15:15	grid.cpp	27	27	computes grid size function
8e0b132c	f24	p0	2024-09-22 21:15:15	grid.cpp	33	33	Checker Function
8e0b132c	f24	p0	2024-09-23 11:51:22	entity.cpp	42	42	Recomputes
8e0b132c	f24	p0	2024-09-23 11:51:22	entity.cpp	77	77	Update K Function
8e0b132c	f24	p0	2024-09-23 11:51:22	entity.cpp	82	82	Recomputes
8e0b132c	f24	p0	2024-09-23 11:51:22	entity.cpp	85	85	Recomputes
8e0b132c	f24	p0	2024-09-23 11:51:22	grid.cpp	5	5	Constructor
8e0b132c	f24	p0	2024-09-23 11:51:22	grid.cpp	18	18	Destructor
8e0b132c	f24	p0	2024-09-23 11:51:22	grid.cpp	28	28	computes grid size function
8e0b132c	f24	p0	2024-09-23 11:51:22	grid.cpp	34	34	Checker Function
8e0b132c	f24	p0	2024-09-23 11:59:43	entity.cpp	42	42	Recomputes
8e0b132c	f24	p0	2024-09-23 11:59:43	entity.cpp	77	77	Update K Function
8e0b132c	f24	p0	2024-09-23 11:59:43	entity.cpp	82	82	Recomputes
8e0b132c	f24	p0	2024-09-23 11:59:43	entity.cpp	85	85	Recomputes
8e0b132c	f24	p0	2024-09-23 11:59:43	grid.cpp	5	5	Constructor
8e0b132c	f24	p0	2024-09-23 11:59:43	grid.cpp	18	18	computes grid size function
8e0b132c	f24	p0	2024-09-23 11:59:43	grid.cpp	24	24	Checker Function
8e0b132c	f24	p0	2024-09-23 12:17:00	entity.cpp	42	42	Recomputes
8e0b132c	f24	p0	2024-09-23 12:17:00	entity.cpp	77	77	Update K Function
8e0b132c	f24	p0	2024-09-23 12:17:00	entity.cpp	82	82	Recomputes
8e0b132c	f24	p0	2024-09-23 12:17:00	entity.cpp	85	85	Recomputes
8e0b132c	f24	p0	2024-09-23 12:17:00	grid.cpp	5	5	Constructor
8e0b132c	f24	p0	2024-09-23 12:17:00	grid.cpp	18	18	computes grid size function
8e0b132c	f24	p0	2024-09-23 12:17:00	grid.cpp	24	24	Checker Function
8e0b132c	f24	p0	2024-09-23 15:21:48	entity.cpp	42	42	Recomputes
8e0b132c	f24	p0	2024-09-23 15:21:48	entity.cpp	77	77	Update K Function
8e0b132c	f24	p0	2024-09-23 15:21:48	entity.cpp	82	82	Recomputes
8e0b132c	f24	p0	2024-09-23 15:21:48	entity.cpp	85	85	Recomputes
8e0b132c	f24	p0	2024-09-23 15:21:48	grid.cpp	5	5	Constructor
8e0b132c	f24	p0	2024-09-23 15:21:48	grid.cpp	18	18	Destructor
8e0b132c	f24	p0	2024-09-23 15:21:48	grid.cpp	25	25	computes grid size function
8e0b132c	f24	p0	2024-09-23 15:21:48	grid.cpp	31	31	Checker Function
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	7	7	implement methods
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	10	10	Default constructor
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	22	22	check if old map exists, if so delete
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	31	31	update size of N and M
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	36	36	Create new 2D array, dynamic allocation
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	50	50	check if coordinate is in 2D array AND array is not nullptr, can assume char is always G or O
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	53	53	GOAL CASE
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	56	56	recompute potential
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	66	66	replacement case (double it)
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	82	82	OBSTACLE CASE
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	85	85	recompute potential
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	95	95	replacement case (double it)
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	111	111	if not in 2D array or nullptr
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	118	118	check if coordinate is in 2D array AND array is not nullptr
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	122	122	if not in 2D array
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	132	132	Clears the array of all obstacles and goals and resets the potentials in it to ⟨0,0⟩
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.cpp	151	151	scale everything up with Knew
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.hpp	3	4	#include <string>\nusing namespace std;
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.hpp	11	11	Data();
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.hpp	16	16	declare class and variables here private
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.hpp	19	19	variables here
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.hpp	24	24	methods here
8f89e3b8	f24	p0	2024-09-22 17:55:21	field.hpp	28	28	use new
8f89e3b8	f24	p0	2024-09-22 17:55:21	main.cpp	7	7	main loop here
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	7	7	implement methods
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	10	10	Default constructor
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	22	22	check if old map exists, if so delete
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	31	31	update size of N and M
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	36	36	Create new 2D array, dynamic allocation
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	50	50	check if coordinate is in 2D array AND array is not nullptr, can assume char is always G or O
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	53	53	GOAL CASE
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	56	56	recompute potential
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	66	66	replacement case (double it)
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	82	82	OBSTACLE CASE
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	85	85	recompute potential
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	95	95	replacement case (double it)
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	111	111	if not in 2D array or nullptr
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	118	118	check if coordinate is in 2D array AND array is not nullptr
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	122	122	if not in 2D array
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	132	132	Clears the array of all obstacles and goals and resets the potentials in it to ⟨0,0⟩
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.cpp	151	151	scale everything up with Knew
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.hpp	3	4	#include <string>\nusing namespace std;
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.hpp	11	11	Data();
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.hpp	16	16	declare class and variables here private
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.hpp	19	19	variables here
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.hpp	24	24	methods here
8f89e3b8	f24	p0	2024-09-22 18:05:40	field.hpp	28	28	use new
8f89e3b8	f24	p0	2024-09-22 18:05:40	main.cpp	7	7	main loop here
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	7	7	implement methods
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	10	10	Default constructor
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	22	22	check if old map exists, if so delete
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	31	31	update size of N and M
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	36	36	Create new 2D array, dynamic allocation
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	50	50	check if coordinate is in 2D array AND array is not nullptr, can assume char is always G or O
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	53	53	GOAL CASE
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	56	56	recompute potential
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	66	66	replacement case (double it)
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	82	82	OBSTACLE CASE
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	85	85	recompute potential
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	95	95	replacement case (double it)
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	111	111	if not in 2D array or nullptr
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	118	118	check if coordinate is in 2D array AND array is not nullptr
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	122	122	if not in 2D array
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	132	132	Clears the array of all obstacles and goals and resets the potentials in it to ⟨0,0⟩
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.cpp	151	151	scale everything up with Knew
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.hpp	3	4	#include <string>\nusing namespace std;
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.hpp	11	11	Data();
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.hpp	16	16	declare class and variables here private
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.hpp	19	19	variables here
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.hpp	24	24	methods here
8f89e3b8	f24	p0	2024-09-22 18:07:06	field.hpp	28	28	use new
8f89e3b8	f24	p0	2024-09-22 18:07:06	main.cpp	7	7	main loop here
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	7	7	implement methods
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	10	10	Default constructor
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	22	22	check if old map exists, if so delete
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	31	31	update size of N and M
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	36	36	Create new 2D array, dynamic allocation
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	50	50	check if coordinate is in 2D array AND array is not nullptr, can assume char is always G or O
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	53	53	GOAL CASE
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	56	56	recompute potential
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	66	66	replacement case (double it)
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	82	82	OBSTACLE CASE
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	85	85	recompute potential
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	95	95	replacement case (double it)
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	111	111	if not in 2D array or nullptr
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	118	118	check if coordinate is in 2D array AND array is not nullptr
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	122	122	if not in 2D array
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	132	132	Clears the array of all obstacles and goals and resets the potentials in it to ⟨0,0⟩
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.cpp	151	151	scale everything up with Knew
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.hpp	3	4	#include <string>\nusing namespace std;
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.hpp	11	11	Data();
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.hpp	16	16	declare class and variables here private
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.hpp	19	19	variables here
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.hpp	24	24	methods here
8f89e3b8	f24	p0	2024-09-23 20:02:01	field.hpp	28	28	use new
8f89e3b8	f24	p0	2024-09-23 20:02:01	main.cpp	7	7	main loop here
911abc14	f24	p0	2024-09-13 15:06:33	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-13 15:06:33	potentialfield.cpp	56	56	print();/
911abc14	f24	p0	2024-09-13 15:06:33	potentialfield.cpp	95	95	print();
911abc14	f24	p0	2024-09-13 15:06:33	potentialfield.cpp	147	148	print();\nstd::cout << "success" << std::endl;
911abc14	f24	p0	2024-09-13 20:59:07	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-13 20:59:07	potentialfield.cpp	56	56	print();/
911abc14	f24	p0	2024-09-13 20:59:07	potentialfield.cpp	78	78	need to do a check to see if there's a point here
911abc14	f24	p0	2024-09-13 20:59:07	potentialfield.cpp	109	109	print();
911abc14	f24	p0	2024-09-13 20:59:07	potentialfield.cpp	176	177	print();\nstd::cout << "success" << std::endl;
911abc14	f24	p0	2024-09-14 00:56:39	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-14 01:29:15	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-14 01:29:15	potentialfield.cpp	17	18	if (this->size > 0)\n{
911abc14	f24	p0	2024-09-14 01:29:15	potentialfield.cpp	20	20	}
911abc14	f24	p0	2024-09-14 05:00:30	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-14 05:00:30	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-14 05:00:30	potentialfield.cpp	37	37	must make it exist first to access it.
911abc14	f24	p0	2024-09-14 05:00:30	potentialfield.cpp	42	43	if (this->points == nullptr)\n{
911abc14	f24	p0	2024-09-14 05:00:30	potentialfield.cpp	45	45	}
911abc14	f24	p0	2024-09-15 03:15:19	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-15 03:15:19	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-15 03:15:19	potentialfield.cpp	37	37	must make it exist first to access it.
911abc14	f24	p0	2024-09-15 03:15:19	potentialfield.cpp	42	43	if (this->points == nullptr)\n{
911abc14	f24	p0	2024-09-15 03:15:19	potentialfield.cpp	45	45	}
911abc14	f24	p0	2024-09-15 18:09:42	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-15 18:09:42	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-15 18:09:42	potentialfield.cpp	37	37	must make it exist first to access it.
911abc14	f24	p0	2024-09-15 18:09:42	potentialfield.cpp	42	43	if (this->points == nullptr)\n{
911abc14	f24	p0	2024-09-15 18:09:42	potentialfield.cpp	45	45	}
911abc14	f24	p0	2024-09-15 23:43:34	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-15 23:43:34	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-15 23:43:34	potentialfield.cpp	37	37	must make it exist first to access it.
911abc14	f24	p0	2024-09-15 23:43:34	potentialfield.cpp	42	43	if (this->points == nullptr)\n{
911abc14	f24	p0	2024-09-15 23:43:34	potentialfield.cpp	45	45	}
911abc14	f24	p0	2024-09-16 02:08:42	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-16 02:08:42	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-16 02:08:42	potentialfield.cpp	37	37	must make it exist first to access it.
911abc14	f24	p0	2024-09-16 02:08:42	potentialfield.cpp	42	43	if (this->points == nullptr)\n{
911abc14	f24	p0	2024-09-16 02:08:42	potentialfield.cpp	45	45	}
911abc14	f24	p0	2024-09-17 18:26:07	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-17 18:26:07	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-17 18:26:07	potentialfield.cpp	37	37	must make it exist first to access it.
911abc14	f24	p0	2024-09-17 20:12:33	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-17 20:12:33	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-17 20:12:33	potentialfield.cpp	37	37	must make it exist first to access it.
911abc14	f24	p0	2024-09-17 20:13:32	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-17 20:13:32	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-17 20:13:32	potentialfield.cpp	37	37	must make it exist first to access it.
911abc14	f24	p0	2024-09-19 00:05:17	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-19 00:05:17	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-19 00:05:17	potentialfield.cpp	37	37	must make it exist first to access it.
911abc14	f24	p0	2024-09-23 13:30:38	main.cpp	4	6	declaring the header file allows us to set up the structure of the code (classes).\nwe implement the definitions by ourselves in the cpp code.\nnow we can use the header file in our main with the defintions we created.
911abc14	f24	p0	2024-09-23 13:30:38	main.cpp	55	55	grid->reset();
911abc14	f24	p0	2024-09-23 13:30:38	potentialfield.cpp	37	37	must make it exist first to access it.
9720d345	f24	p0	2024-09-10 20:48:44	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-10 20:48:44	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-11 14:34:27	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-11 14:34:27	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-11 14:56:34	grid.cpp	12	14	grid::~grid(){\n\n}
9720d345	f24	p0	2024-09-11 14:56:34	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-11 14:56:34	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-11 14:58:17	grid.cpp	12	14	grid::~grid(){\n\n}
9720d345	f24	p0	2024-09-11 14:58:17	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-11 14:58:17	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-11 15:02:18	grid.cpp	12	14	grid::~grid(){\n\n}
9720d345	f24	p0	2024-09-11 15:02:18	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-11 15:02:18	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-11 15:12:28	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-11 15:12:28	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-11 16:15:19	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-11 16:15:19	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-13 13:03:53	grid.cpp	25	25	this->obstacles.remove(vector<int>{X,Y});
9720d345	f24	p0	2024-09-13 13:03:53	grid.cpp	30	30	this->goals.remove(vector<int>{X,Y});
9720d345	f24	p0	2024-09-13 13:03:53	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-13 13:03:53	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-13 13:05:47	grid.cpp	25	25	this->obstacles.remove(vector<int>{X,Y});
9720d345	f24	p0	2024-09-13 13:05:47	grid.cpp	30	30	this->goals.remove(vector<int>{X,Y});
9720d345	f24	p0	2024-09-13 13:05:47	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-13 13:05:47	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-13 13:35:10	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-13 13:35:10	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-13 13:47:43	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-13 13:47:43	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-13 13:50:51	vector.cpp	3	3	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-13 13:50:51	vector.cpp	27	27	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-18 17:27:24	vector.cpp	4	4	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-18 17:27:24	vector.cpp	28	28	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-20 18:53:52	vector.cpp	4	4	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-20 18:53:52	vector.cpp	28	28	I only need ints and doubles, but this class will work with
9720d345	f24	p0	2024-09-22 18:54:34	vector.cpp	4	4	This should really be a struct but the lab document says it cant be so ...
9720d345	f24	p0	2024-09-22 18:54:34	vector.cpp	28	28	I only need ints and doubles, but this class will work with any datatype
9b9ebbdb	f24	p0	2024-09-23 15:50:24	Grid.hpp	10	11	2D array for X of potentials\n2D array for Y of potentials
9b9ebbdb	f24	p0	2024-09-23 15:50:24	Grid.hpp	15	16	potential at (x1,y1) due to goal/obstacle at (x2,y2)\npotentials after
9b9ebbdb	f24	p0	2024-09-23 15:50:24	Grid.hpp	24	24	output potential at (x,y)
9b9ebbdb	f24	p0	2024-09-23 15:50:24	main.cpp	17	17	HowtoParseInGeneral video
9b9ebbdb	f24	p0	2024-09-23 19:39:04	Grid.hpp	10	11	2D array for X of potentials\n2D array for Y of potentials
9b9ebbdb	f24	p0	2024-09-23 19:39:04	Grid.hpp	15	15	potential at (x1,y1) due to goal/obstacle at (x2,y2)
9b9ebbdb	f24	p0	2024-09-23 19:39:04	Grid.hpp	24	24	output potential at (x,y)
9b9ebbdb	f24	p0	2024-09-23 19:39:04	main.cpp	17	17	HowtoParseInGeneral video
9b9ebbdb	f24	p0	2024-09-23 19:42:06	Grid.hpp	10	11	2D array for X of potentials\n2D array for Y of potentials
9b9ebbdb	f24	p0	2024-09-23 19:42:06	Grid.hpp	15	15	potential at (x1,y1) due to goal/obstacle at (x2,y2)
9b9ebbdb	f24	p0	2024-09-23 19:42:06	Grid.hpp	24	24	output potential at (x,y)
9b9ebbdb	f24	p0	2024-09-23 19:42:06	main.cpp	17	17	HowtoParseInGeneral video
9b9ebbdb	f24	p0	2024-09-23 21:08:59	Grid.hpp	10	11	2D array for X of potentials\n2D array for Y of potentials
9b9ebbdb	f24	p0	2024-09-23 21:08:59	main.cpp	17	17	HowtoParseInGeneral video
9bf7f431	f24	p0	2024-09-22 19:40:04	Grid.cpp	12	12	Clear any existing grid
9bf7f431	f24	p0	2024-09-22 19:40:04	Grid.cpp	21	21	Dynamically allocate 2D array
9bf7f431	f24	p0	2024-09-22 19:40:04	main.cpp	51	52	in theory it is good practice to end an else-if with an else for edge-case handling\nhowever for p0 it is not needed
9bf7f431	f24	p0	2024-09-22 22:58:56	Grid.cpp	12	12	Clear any existing grid
9bf7f431	f24	p0	2024-09-22 22:58:56	Grid.cpp	24	24	Check if the point already exists
9bf7f431	f24	p0	2024-09-22 22:58:56	Grid.cpp	27	27	Overwrite the existing point
9bf7f431	f24	p0	2024-09-22 22:58:56	Grid.cpp	32	32	Point doesn't exist, add it
9bf7f431	f24	p0	2024-10-07 03:22:05	CPU.cpp	13	13	Initialize all workloads to 0
9bf7f431	f24	p0	2024-10-07 03:22:05	CPU.cpp	30	30	Try to steal a task
9bf7f431	f24	p0	2024-10-07 03:22:05	CPU.cpp	32	32	steals task and adds it to the empty core
9bf7f431	f24	p0	2024-10-07 03:22:05	CPU.cpp	80	81	Find the core with the least work among the remaining cores\nStart with the next core
9bf7f431	f24	p0	2024-10-07 03:22:05	CPU.cpp	88	88	Assign the task to the core with the least work
9bf7f431	f24	p0	2024-10-07 03:22:05	CPU.cpp	92	92	updateLeastAndMostWorkCore(leastWorkIndex);
9bf7f431	f24	p0	2024-10-07 03:22:05	CPU.hpp	28	28	Array to keep track of each core's workload
9bf7f431	f24	p0	2024-10-07 03:22:05	CPU.hpp	31	31	CPU_HPP
9bf7f431	f24	p0	2024-10-07 03:22:05	deque.hpp	86	86	DEQUE_HPP
9d10f433	f24	p0	2024-09-11 14:18:48	main.cpp	61	61	INVALID COMMAND
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.cpp	5	5	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.cpp	9	9	MapArray constructor definition
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.cpp	17	17	MapArray destructor definition
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.cpp	88	88	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.cpp	91	91	If the point is a goal
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.cpp	95	95	If the point is an obstacle
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.cpp	102	102	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.cpp	117	117	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.h	8	11	x-value of potential value\ny-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.h	18	20	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.h	31	32	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.h	34	37	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-11 14:18:48	MapStructures.h	40	40	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-11 14:23:12	main.cpp	61	61	INVALID COMMAND
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.cpp	5	5	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.cpp	9	9	MapArray constructor definition
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.cpp	17	17	MapArray destructor definition
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.cpp	88	88	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.cpp	91	91	If the point is a goal
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.cpp	95	95	If the point is an obstacle
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.cpp	102	102	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.cpp	117	117	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.h	8	11	x-value of potential value\ny-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.h	18	20	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.h	31	32	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.h	34	37	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-11 14:23:12	MapStructures.h	40	40	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-11 14:24:21	main.cpp	61	61	INVALID COMMAND
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.cpp	5	5	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.cpp	9	9	MapArray constructor definition
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.cpp	17	17	MapArray destructor definition
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.cpp	88	88	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.cpp	91	91	If the point is a goal
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.cpp	95	95	If the point is an obstacle
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.cpp	102	102	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.cpp	117	117	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.h	8	11	x-value of potential value\ny-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.h	18	20	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.h	31	32	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.h	34	37	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-11 14:24:21	MapStructures.h	40	40	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-11 14:31:23	main.cpp	60	60	INVALID COMMAND
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.cpp	5	5	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.cpp	9	9	MapArray constructor definition
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.cpp	17	17	MapArray destructor definition
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.cpp	88	88	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.cpp	91	91	If the point is a goal
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.cpp	95	95	If the point is an obstacle
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.cpp	102	102	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.cpp	117	117	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.h	8	11	x-value of potential value\ny-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.h	18	20	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.h	31	32	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.h	34	37	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-11 14:31:23	MapStructures.h	40	40	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-11 14:43:46	main.cpp	11	11	Read commands from standard input
9d10f433	f24	p0	2024-09-11 14:43:46	main.cpp	13	15	If input fails, clear the error state and ignore the rest of the line\nClear the error state\nRestart the loop to try reading the next command
9d10f433	f24	p0	2024-09-11 14:43:46	main.cpp	21	21	Handle input failure for rows and columns
9d10f433	f24	p0	2024-09-11 14:43:46	main.cpp	36	36	Handle input failure for type, x, and y
9d10f433	f24	p0	2024-09-11 14:43:46	main.cpp	55	55	Handle input failure for x and y
9d10f433	f24	p0	2024-09-11 14:43:46	main.cpp	84	84	Handle input failure for k
9d10f433	f24	p0	2024-09-11 14:43:46	main.cpp	101	101	Cleanup before exiting
9d10f433	f24	p0	2024-09-11 14:43:46	main.cpp	106	106	Handle invalid command
9d10f433	f24	p0	2024-09-11 14:43:46	main.cpp	111	111	Cleanup
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.cpp	5	5	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.cpp	9	9	MapArray constructor definition
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.cpp	17	17	MapArray destructor definition
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.cpp	90	90	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.cpp	93	93	If the point is a goal
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.cpp	97	97	If the point is an obstacle
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.cpp	104	104	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.cpp	119	119	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.h	8	11	x-value of potential value\ny-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.h	18	20	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.h	31	32	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.h	34	37	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-11 14:43:46	MapStructures.h	40	40	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	15	15	Discard the rest of the line
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	20	20	Read commands from standard input
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	22	24	If input fails, clear the error state and ignore the rest of the line\nClear the error state\nRestart the loop to try reading the next command
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	30	30	Handle input failure for rows and columns
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	45	45	Handle input failure for type, x, and y
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	65	65	Handle input failure for x and y
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	96	96	Handle input failure for k
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	114	114	Cleanup before exiting
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	120	120	Handle invalid command
9d10f433	f24	p0	2024-09-11 15:01:59	main.cpp	126	126	Cleanup
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.cpp	5	5	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.cpp	9	9	MapArray constructor definition
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.cpp	17	17	MapArray destructor definition
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.cpp	90	90	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.cpp	93	93	If the point is a goal
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.cpp	97	97	If the point is an obstacle
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.cpp	104	104	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.cpp	119	119	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.h	8	11	x-value of potential value\ny-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.h	18	20	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.h	31	32	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.h	34	37	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-11 15:01:59	MapStructures.h	40	40	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	15	15	Discard the rest of the line
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	20	20	Read commands from standard input
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	22	24	If input fails, clear the error state and ignore the rest of the line\nClear the error state\nRestart the loop to try reading the next command
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	30	30	Handle input failure for rows and columns
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	45	45	Handle input failure for type, x, and y
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	65	65	Handle input failure for x and y
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	97	97	Handle input failure for k
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	114	114	Cleanup before exiting
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	120	120	Handle invalid command
9d10f433	f24	p0	2024-09-11 18:33:57	main.cpp	126	126	Cleanup
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.cpp	6	6	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.cpp	10	10	MapArray constructor definition
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.cpp	18	18	MapArray destructor definition
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.cpp	91	91	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.cpp	94	94	If the point is a goal
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.cpp	98	98	If the point is an obstacle
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.cpp	105	105	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.cpp	120	120	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.h	8	11	x-value of potential value\ny-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.h	18	20	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.h	31	32	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.h	34	37	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-11 18:33:57	MapStructures.h	40	40	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	15	15	Discard the rest of the line
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	20	20	Read commands from standard input
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	22	24	If input fails, clear the error state and ignore the rest of the line\nClear the error state\nRestart the loop to try reading the next command
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	31	31	Handle input failure for rows and columns
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	46	46	Handle input failure for type, x, and y
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	66	66	Handle input failure for x and y
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	98	98	Handle input failure for k
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	115	115	Cleanup before exiting
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	121	121	Handle invalid command
9d10f433	f24	p0	2024-09-11 18:46:33	main.cpp	127	127	Cleanup
9d10f433	f24	p0	2024-09-11 18:46:33	MapStructures.cpp	6	6	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-11 18:46:33	MapStructures.cpp	10	10	MapArray constructor definition
9d10f433	f24	p0	2024-09-11 18:46:33	MapStructures.cpp	18	18	MapArray destructor definition
9d10f433	f24	p0	2024-09-11 18:46:33	MapStructures.cpp	91	91	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 18:46:33	MapStructures.cpp	94	94	If the point is a goal
9d10f433	f24	p0	2024-09-11 18:46:33	MapStructures.cpp	98	98	If the point is an obstacle
9d10f433	f24	p0	2024-09-11 18:46:33	MapStructures.cpp	105	105	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-11 18:46:33	MapStructures.cpp	120	120	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	15	15	Discard the rest of the line
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	20	20	Read commands from standard input
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	22	24	If input fails, clear the error state and ignore the rest of the line\nClear the error state\nRestart the loop to try reading the next command
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	30	30	Handle input failure for rows and columns
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	49	49	Handle input failure for type, x, and y
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	69	69	Handle input failure for x and y
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	101	101	Handle input failure for k
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	118	118	Cleanup before exiting
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	124	124	Handle invalid command
9d10f433	f24	p0	2024-09-11 18:53:14	main.cpp	130	130	Cleanup
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.cpp	6	6	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.cpp	10	10	MapArray constructor definition
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.cpp	18	18	MapArray destructor definition
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.cpp	91	91	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.cpp	94	94	If the point is a goal
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.cpp	98	98	If the point is an obstacle
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.cpp	105	105	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.cpp	120	120	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.h	8	11	x-value of potential value\ny-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.h	18	20	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.h	31	32	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.h	34	37	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-11 18:53:14	MapStructures.h	40	40	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	15	15	Discard the rest of the line
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	20	20	Read commands from standard input
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	22	24	If input fails, clear the error state and ignore the rest of the line\nClear the error state\nRestart the loop to try reading the next command
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	30	30	Handle input failure for rows and columns
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	49	49	Handle input failure for type, x, and y
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	69	69	Handle input failure for x and y
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	101	101	Handle input failure for k
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	118	118	Cleanup before exiting
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	124	124	Handle invalid command
9d10f433	f24	p0	2024-09-16 19:34:31	main.cpp	130	130	Cleanup
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.cpp	6	6	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.cpp	10	10	MapArray constructor definition
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.cpp	18	18	MapArray destructor definition
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.cpp	91	91	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.cpp	94	94	If the point is a goal
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.cpp	98	98	If the point is an obstacle
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.cpp	105	105	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.cpp	120	120	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.h	8	11	x-value of potential value\ny-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.h	18	20	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.h	31	32	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.h	34	37	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-16 19:34:31	MapStructures.h	40	40	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	15	15	Discard the rest of the line
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	20	20	Read commands from standard input
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	22	24	If input fails, clear the error state and ignore the rest of the line\nClear the error state\nRestart the loop to try reading the next command
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	30	30	Handle input failure for rows and columns
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	49	49	Handle input failure for type, x, and y
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	69	69	Handle input failure for x and y
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	100	100	Handle input failure for k
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	117	117	Cleanup before exiting
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	123	123	Handle invalid command
9d10f433	f24	p0	2024-09-23 12:57:24	main.cpp	129	129	Cleanup
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.cpp	6	6	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.cpp	10	10	MapArray constructor definition
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.cpp	18	18	MapArray destructor definition
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.cpp	90	90	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.cpp	93	93	If the point is a goal
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.cpp	96	96	If the point is an obstacle
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.cpp	102	102	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.cpp	117	117	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.hpp	8	10	x-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.hpp	17	19	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.hpp	30	31	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.hpp	33	36	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-23 12:57:24	MapStructures.hpp	39	39	MAP_ARRAY_H
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	15	15	Discard the rest of the line
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	20	20	Read commands from standard input
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	22	24	If input fails, clear the error state and ignore the rest of the line\nClear the error state\nRestart the loop to try reading the next command
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	30	30	Handle input failure for rows and columns
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	49	49	Handle input failure for type, x, and y
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	69	69	Handle input failure for x and y
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	100	100	Handle input failure for k
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	117	117	Cleanup before exiting
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	123	123	Handle invalid command
9d10f433	f24	p0	2024-09-23 13:01:14	main.cpp	129	129	Cleanup
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.cpp	6	6	PotentialVector constructor definition
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.cpp	10	10	MapArray constructor definition
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.cpp	18	18	MapArray destructor definition
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.cpp	90	90	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.cpp	93	93	If the point is a goal
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.cpp	96	96	If the point is an obstacle
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.cpp	102	102	Set the total potential at the specified point
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.cpp	117	117	Calculate the total potential for each point in the map
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.hpp	8	10	x-value of potential value\ntype of point (goal, obstacle, or empty)\nerror flag
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.hpp	17	19	Number of rows in the map array.\nNumber of columns in the map array.\nPointer to array of pointers to PotentialVector objects.
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.hpp	30	31	Constructor to initialize the map array.\nDestructor to free memory.
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.hpp	33	36	Sets the type at a given map point.\nGets the PotentialVector at a point.\nSets the kVal.\nClears the map by resetting all values.
9d10f433	f24	p0	2024-09-23 13:01:14	MapStructures.hpp	39	39	MAP_ARRAY_H
a09bfd17	f24	p0	2024-09-20 17:18:05	main.cpp	8	8	Creates a potential field object to run
a09bfd17	f24	p0	2024-09-20 17:18:05	main.cpp	10	10	stores the command line itself (ex: "CREATE", "POINT", etc)
a09bfd17	f24	p0	2024-09-20 17:18:05	main.cpp	12	12	*******  ParseIn while loop to receive commands  **********
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.cpp	6	6	**************** Below is the Constructor and Destructor of the Potential Class *******************
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.cpp	8	8	Default constructor Initailzing the parameters, stating an empty grid
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.cpp	14	14	conditional statement to prevent double free
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.cpp	44	44	**************** Below are the public functions for the Field_ class, including all the mutators and accessors *******************
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.cpp	46	46	Delete the current field if a field already exist
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.cpp	121	121	Update N and M.
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.cpp	151	151	reset potentials to zero, remove all obsticles and goals.
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.hpp	3	3	Abstract Container variables within Potential_Vals[i], containing 2 members: Potential Values of the coordinate (P_x and P_y)
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.hpp	5	5	ILLustration: Potential_Vals[i][j] = MyPair_, while MyPair.P_x = (X coordinate Potential Value of that specific point), same logic for MyPair.P_y
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.hpp	27	27	Constructor of MyPair_
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.hpp	29	29	Destructor of MyPair_
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.hpp	33	33	***************************************************************************************************************************************************************
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.hpp	38	38	Class Field, this class implements the 2D grid and all the functionalities and methods
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.hpp	96	96	reset field
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.hpp	98	98	free memory
a09bfd17	f24	p0	2024-09-20 17:18:05	Potential_Field.hpp	104	104	multiply(n_k / K);
a09bfd17	f24	p0	2024-09-21 00:13:18	main.cpp	8	8	Creates a potential field object to run
a09bfd17	f24	p0	2024-09-21 00:13:18	main.cpp	10	10	stores the command line itself (ex: "CREATE", "POINT", etc)
a09bfd17	f24	p0	2024-09-21 00:13:18	main.cpp	12	12	*******  ParseIn while loop to receive commands  **********
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.cpp	6	6	**************** Below is the Constructor and Destructor of the Potential Class *******************
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.cpp	8	8	Default constructor Initailzing the parameters, stating an empty grid
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.cpp	14	14	conditional statement to prevent double free
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.cpp	44	44	**************** Below are the public functions for the Field_ class, including all the mutators and accessors *******************
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.cpp	46	46	Delete the current field if a field already exist
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.cpp	121	121	Update N and M.
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.cpp	151	151	reset potentials to zero, remove all obsticles and goals.
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.hpp	3	3	Abstract Container variables within Potential_Vals[i], containing 2 members: Potential Values of the coordinate (P_x and P_y)
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.hpp	5	5	ILLustration: Potential_Vals[i][j] = MyPair_, while MyPair.P_x = (X coordinate Potential Value of that specific point), same logic for MyPair.P_y
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.hpp	27	27	Constructor of MyPair_
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.hpp	29	29	Destructor of MyPair_
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.hpp	33	33	***************************************************************************************************************************************************************
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.hpp	38	38	Class Field, this class implements the 2D grid and all the functionalities and methods
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.hpp	96	96	reset field
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.hpp	98	98	free memory
a09bfd17	f24	p0	2024-09-21 00:13:18	Potential_Field.hpp	104	104	multiply(n_k / K);
a09bfd17	f24	p0	2024-09-21 03:39:03	main.cpp	8	8	Creates a potential field object to run
a09bfd17	f24	p0	2024-09-21 03:39:03	main.cpp	10	10	stores the command line itself (ex: "CREATE", "POINT", etc)
a09bfd17	f24	p0	2024-09-21 03:39:03	main.cpp	12	12	*******  ParseIn while loop to receive commands  **********
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.cpp	6	6	**************** Below is the Constructor and Destructor of the Potential Class *******************
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.cpp	8	8	Default constructor Initailzing the parameters, stating an empty grid
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.cpp	14	14	conditional statement to prevent double free
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.cpp	44	44	**************** Below are the public functions for the Field_ class, including all the mutators and accessors *******************
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.cpp	46	46	Delete the current field if a field already exist
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.cpp	110	110	Update N and M.
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.cpp	139	139	reset potentials to zero, remove all obsticles and goals.
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.hpp	3	3	Abstract Container variables within Potential_Vals[i], containing 2 members: Potential Values of the coordinate (P_x and P_y)
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.hpp	5	5	ILLustration: Potential_Vals[i][j] = MyPair_, while MyPair.P_x = (X coordinate Potential Value of that specific point), same logic for MyPair.P_y
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.hpp	27	27	Constructor of MyPair_
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.hpp	29	29	Destructor of MyPair_
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.hpp	33	33	***************************************************************************************************************************************************************
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.hpp	38	38	Class Field, this class implements the 2D grid and all the functionalities and methods
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.hpp	96	96	reset field
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.hpp	98	98	free memory
a09bfd17	f24	p0	2024-09-21 03:39:03	Potential_Field.hpp	104	104	multiply(n_k / K);
a09bfd17	f24	p0	2024-09-21 14:59:03	main.cpp	8	8	Creates a potential field object to run
a09bfd17	f24	p0	2024-09-21 14:59:03	main.cpp	10	10	stores the command line itself (ex: "CREATE", "POINT", etc)
a09bfd17	f24	p0	2024-09-21 14:59:03	main.cpp	12	12	*******  ParseIn while loop to receive commands  **********
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.cpp	6	6	**************** Below is the Constructor and Destructor of the Potential Class *******************
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.cpp	8	8	Default constructor Initailzing the parameters, stating an empty grid
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.cpp	14	14	conditional statement to prevent double free
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.cpp	44	44	**************** Below are the public functions for the Field_ class, including all the mutators and accessors *******************
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.cpp	46	46	Delete the current field if a field already exist
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.cpp	110	110	Update N and M.
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.cpp	139	139	reset potentials to zero, remove all obsticles and goals.
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.hpp	3	3	Abstract Container variables within Potential_Vals[i], containing 2 members: Potential Values of the coordinate (P_x and P_y)
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.hpp	5	5	ILLustration: Potential_Vals[i][j] = MyPair_, while MyPair.P_x = (X coordinate Potential Value of that specific point), same logic for MyPair.P_y
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.hpp	27	27	Constructor of MyPair_
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.hpp	29	29	Destructor of MyPair_
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.hpp	33	33	***************************************************************************************************************************************************************
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.hpp	38	38	Class Field, this class implements the 2D grid and all the functionalities and methods
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.hpp	96	96	reset field
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.hpp	98	98	free memory
a09bfd17	f24	p0	2024-09-21 14:59:03	Potential_Field.hpp	104	104	multiply(n_k / K);
a09bfd17	f24	p0	2024-09-22 16:24:35	main.cpp	8	8	Creates a potential field object to run
a09bfd17	f24	p0	2024-09-22 16:24:35	main.cpp	10	10	stores the command line itself (ex: "CREATE", "POINT", etc)
a09bfd17	f24	p0	2024-09-22 16:24:35	main.cpp	12	12	*******  ParseIn while loop to receive commands  **********
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.cpp	6	6	**************** Below is the Constructor and Destructor of the Potential Class *******************
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.cpp	8	8	Default constructor Initailzing the parameters, stating an empty grid
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.cpp	14	14	conditional statement to prevent double free
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.cpp	44	44	**************** Below are the public functions for the Field_ class, including all the mutators and accessors *******************
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.cpp	46	46	Delete the current field if a field already exist
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.cpp	110	110	Update N and M.
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.cpp	139	139	reset potentials to zero, remove all obsticles and goals.
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.hpp	3	3	Abstract Container variables within Potential_Vals[i], containing 2 members: Potential Values of the coordinate (P_x and P_y)
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.hpp	5	5	ILLustration: Potential_Vals[i][j] = MyPair_, while MyPair.P_x = (X coordinate Potential Value of that specific point), same logic for MyPair.P_y
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.hpp	27	27	Constructor of MyPair_
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.hpp	29	29	Destructor of MyPair_
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.hpp	33	33	***************************************************************************************************************************************************************
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.hpp	38	38	Class Field, this class implements the 2D grid and all the functionalities and methods
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.hpp	96	96	reset field
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.hpp	98	98	free memory
a09bfd17	f24	p0	2024-09-22 16:24:35	Potential_Field.hpp	104	104	multiply(n_k / K);
a09bfd17	f24	p0	2024-09-23 19:25:38	main.cpp	8	8	Creates a potential field object to run
a09bfd17	f24	p0	2024-09-23 19:25:38	main.cpp	10	10	stores the command line itself (ex: "CREATE", "POINT", etc)
a09bfd17	f24	p0	2024-09-23 19:25:38	main.cpp	12	12	*******  ParseIn while loop to receive commands  **********
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.cpp	6	6	**************** Below is the Constructor and Destructor of the Potential Class *******************
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.cpp	8	8	Default constructor Initailzing the parameters, stating an empty grid
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.cpp	14	14	conditional statement to prevent double free
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.cpp	44	44	**************** Below are the public functions for the Field_ class, including all the mutators and accessors *******************
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.cpp	46	46	Delete the current field if a field already exist
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.cpp	110	110	Update N and M.
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.cpp	139	139	reset potentials to zero, remove all obsticles and goals.
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.hpp	3	3	Abstract Container variables within Potential_Vals[i], containing 2 members: Potential Values of the coordinate (P_x and P_y)
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.hpp	5	5	ILLustration: Potential_Vals[i][j] = MyPair_, while MyPair.P_x = (X coordinate Potential Value of that specific point), same logic for MyPair.P_y
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.hpp	27	27	Constructor of MyPair_
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.hpp	29	29	Destructor of MyPair_
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.hpp	33	33	***************************************************************************************************************************************************************
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.hpp	38	38	Class Field, this class implements the 2D grid and all the functionalities and methods
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.hpp	96	96	reset field
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.hpp	98	98	free memory
a09bfd17	f24	p0	2024-09-23 19:25:38	Potential_Field.hpp	104	104	multiply(n_k / K);
a09bfd17	f24	p0	2024-09-23 19:29:02	main.cpp	8	8	Creates a potential field object to run
a09bfd17	f24	p0	2024-09-23 19:29:02	main.cpp	10	10	stores the command line itself (ex: "CREATE", "POINT", etc)
a09bfd17	f24	p0	2024-09-23 19:29:02	main.cpp	12	12	*******  ParseIn while loop to receive commands  **********
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.cpp	6	6	**************** Below is the Constructor and Destructor of the Potential Class *******************
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.cpp	8	8	Default constructor Initailzing the parameters, stating an empty grid
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.cpp	14	14	conditional statement to prevent double free
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.cpp	44	44	**************** Below are the public functions for the Field_ class, including all the mutators and accessors *******************
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.cpp	46	46	Delete the current field if a field already exist
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.cpp	110	110	Update N and M.
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.cpp	139	139	reset potentials to zero, remove all obsticles and goals.
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.hpp	3	3	Abstract Container variables within Potential_Vals[i], containing 2 members: Potential Values of the coordinate (P_x and P_y)
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.hpp	5	5	ILLustration: Potential_Vals[i][j] = MyPair_, while MyPair.P_x = (X coordinate Potential Value of that specific point), same logic for MyPair.P_y
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.hpp	27	27	Constructor of MyPair_
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.hpp	29	29	Destructor of MyPair_
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.hpp	33	33	***************************************************************************************************************************************************************
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.hpp	38	38	Class Field, this class implements the 2D grid and all the functionalities and methods
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.hpp	96	96	reset field
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.hpp	98	98	free memory
a09bfd17	f24	p0	2024-09-23 19:29:02	Potential_Field.hpp	104	104	multiply(n_k / K);
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	7	7	Constructor definition
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	20	20	Destructor definition
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	24	24	Rows freed
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	26	26	Pointers array freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	32	32	Coordinates freed
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	34	34	Array of goals freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	40	40	Coordinates freed
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	42	42	Array of obstacles freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	48	48	Helper function
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	51	51	Calculate potential value at all cells that are not goals/obstacles
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	54	54	Reset potential value for current cell
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	56	57	G (goal) = 1.0 , O (obstacle) = 2.0\nSkip goal/obstacle cells
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	60	60	Effect from goals on potential
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	69	69	Effect from obstacles on potential
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	78	78	Current cell is set to newly calculated potential value
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	88	89	Create grid as 2D array\nArray of pointers for each row
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	92	92	Each row is the length of the number of columns
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	95	95	Set all potential vector values to 0.0
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	99	99	Create dynamic array for goals and obstacles
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	105	105	2 elements per cell for coordinate (x,y)
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	113	113	insert the Goal/Obstacle if (X,Y) is in the bounds
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	115	115	G (goal) = 1.0
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	119	119	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	123	123	O (obstacle)= 2.0
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	127	127	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	135	135	Coordinate out of bounds
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	141	141	(X,Y) is in the bounds then insert the Goal/Obstacle
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.cpp	186	199	void FieldMap::print_grid() const {\nif (!grid_array) {\ncout << "Grid is not created yet." << endl;\nreturn;\n}\ncout << endl;\nfor (int i = 0; i < N_rows; ++i) {\nfor (int j = 0; j < M_columns; ++j) {\ncout << grid_array[i][j] << "    ";  // Print each cell\n}\ncout << endl;  // Newline after each row\n}\ncout << endl;\n}
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.h	4	4	Class declaration
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.h	7	8	constructor\nDestructor (frees up dynamically allocated memory)
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.h	17	17	void print_grid() const;
a2a325f6	f24	p0	2024-09-23 17:12:54	FieldMap.h	22	27	Dynamically allocated 2D array\nConstant in potential value formula\n(X,Y) coordinates for goals\n(X,Y) coordinates for obstacles\nNumber of goals\nNumber of obstacles
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	8	8	Store input command
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	10	13	Loop through input file commands until "EXIT" command\nCreate a new grid of size N rows x M columns (ints)\nRows\nColumns
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	21	21	map.print_grid();
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	25	27	'G' for goal or 'O' for obstacle\nx coordinate for goal/obstacle position\ny coordinate for goal/obstacle position
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	40	40	map.print_grid();
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	44	45	x coordinate for current robot position\ny coordinate for current robot position
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	52	52	map.print_grid();
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	64	64	map.print_grid();
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	69	69	Constant in potential value formula
a2a325f6	f24	p0	2024-09-23 17:12:54	main.cpp	81	81	map.print_grid();
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	7	7	Constructor definition
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	20	20	Destructor definition
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	24	24	Rows freed
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	26	26	Pointers array freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	32	32	Coordinates freed
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	34	34	Array of goals freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	40	40	Coordinates freed
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	42	42	Array of obstacles freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	48	48	Helper function
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	51	51	Calculate potential value at all cells
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	54	54	Reset potential value for current cell
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	56	56	Effect from goals on potential
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	65	65	Effect from obstacles on potential
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	74	74	Current cell is set to newly calculated potential value
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	84	85	Create grid as 2D array\nArray of pointers for each row
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	88	88	Each row is the length of the number of columns
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	91	91	Set all potential vector values to 0.0
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	95	95	Create dynamic array for goals and obstacles
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	101	101	2 elements per cell for coordinate (x,y)
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	109	109	insert the Goal/Obstacle if (X,Y) is in the bounds
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	111	111	G (goal) = 1.0
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	115	115	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	119	119	O (obstacle)= 2.0
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	123	123	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	131	131	Coordinate out of bounds
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.cpp	137	137	(X,Y) is in the bounds then insert the Goal/Obstacle
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.h	4	4	Class declaration
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.h	7	8	constructor\nDestructor (frees up dynamically allocated memory)
a2a325f6	f24	p0	2024-09-23 17:38:25	FieldMap.h	21	26	Dynamically allocated 2D array\nConstant in potential value formula\n(X,Y) coordinates for goals\n(X,Y) coordinates for obstacles\nNumber of goals\nNumber of obstacles
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	8	8	Store input command
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	10	13	Loop through input file commands until "EXIT" command\nCreate a new grid of size N rows x M columns (ints)\nRows\nColumns
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	21	21	map.print_grid();
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	25	27	'G' for goal or 'O' for obstacle\nx coordinate for goal/obstacle position\ny coordinate for goal/obstacle position
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	40	40	map.print_grid();
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	44	45	x coordinate for current robot position\ny coordinate for current robot position
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	52	52	map.print_grid();
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	64	64	map.print_grid();
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	69	69	Constant in potential value formula
a2a325f6	f24	p0	2024-09-23 17:38:25	main.cpp	81	81	map.print_grid();
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	7	7	Constructor definition
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	20	20	Destructor definition
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	24	24	Rows freed
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	26	26	Pointers array freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	32	32	Coordinates freed
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	34	34	Array of goals freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	40	40	Coordinates freed
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	42	42	Array of obstacles freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	48	48	Helper function
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	51	51	Calculate potential value at all cells
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	54	54	Reset potential value for current cell
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	56	56	Effect from goals on potential
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	65	65	Effect from obstacles on potential
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	74	74	Current cell is set to newly calculated potential value
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	86	86	Rows freed
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	88	88	Pointers array freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	94	94	Coordinates freed
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	96	96	Array of goals freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	102	102	Coordinates freed
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	104	104	Array of obstacles freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	109	110	Create grid as 2D array\nArray of pointers for each row
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	113	113	Each row is the length of the number of columns
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	116	116	Set all potential vector values to 0.0
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	120	120	Create dynamic array for goals and obstacles
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	126	126	2 elements per cell for coordinate (x,y)
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	134	134	insert the Goal/Obstacle if (X,Y) is in the bounds
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	136	136	G (goal) = 1.0
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	140	140	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	144	144	O (obstacle)= 2.0
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	148	148	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	156	156	Coordinate out of bounds
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.cpp	162	162	(X,Y) is in the bounds then insert the Goal/Obstacle
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.h	4	4	Class declaration
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.h	7	8	constructor\nDestructor (frees up dynamically allocated memory)
a2a325f6	f24	p0	2024-09-23 22:23:50	FieldMap.h	18	25	Number of rows in grid\nNumber of columns in grid\nDynamically allocated 2D array\nConstant value used in potential value formula\n(X,Y) coordinates for goals\n(X,Y) coordinates for obstacles\nNumber of goals\nNumber of obstacles
a2a325f6	f24	p0	2024-09-23 22:23:50	main.cpp	8	8	Store input command
a2a325f6	f24	p0	2024-09-23 22:23:50	main.cpp	10	13	Loop through input file commands until "EXIT" command\nCreate a new grid of size N rows x M columns (ints)\nRows\nColumns
a2a325f6	f24	p0	2024-09-23 22:23:50	main.cpp	22	24	'G' for goal or 'O' for obstacle\nx coordinate for goal/obstacle position\ny coordinate for goal/obstacle position
a2a325f6	f24	p0	2024-09-23 22:23:50	main.cpp	37	38	x coordinate for current robot position\ny coordinate for current robot position
a2a325f6	f24	p0	2024-09-23 22:23:50	main.cpp	55	55	Constant in potential value formula
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	7	7	Constructor definition
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	20	20	Destructor definition
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	24	24	Rows freed
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	26	26	Pointers array freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	32	32	Coordinates freed
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	34	34	Array of goals freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	40	40	Coordinates freed
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	42	42	Array of obstacles freed and set to nullptr
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	48	48	Helper function
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	51	51	Calculate potential value at all cells
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	54	54	Reset potential value for current cell
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	56	56	Effect from goals on potential
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	65	65	Effect from obstacles on potential
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	74	74	Current cell is set to newly calculated potential value
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	84	85	Create grid as 2D array\nArray of pointers for each row
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	88	88	Each row is the length of the number of columns
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	91	91	Set all potential vector values to 0.0
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	95	95	Create dynamic array for goals and obstacles
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	101	101	2 elements per cell for coordinate (x,y)
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	109	109	insert the Goal/Obstacle if (X,Y) is in the bounds
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	111	111	G (goal) = 1.0
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	115	115	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	119	119	O (obstacle)= 2.0
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	123	123	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	131	131	Coordinate out of bounds
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.cpp	137	137	(X,Y) is in the bounds then insert the Goal/Obstacle
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.h	4	4	Class declaration
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.h	7	8	constructor\nDestructor (frees up dynamically allocated memory)
a2a325f6	f24	p0	2024-09-23 22:32:38	FieldMap.h	18	25	Number of rows in grid\nNumber of columns in grid\nDynamically allocated 2D array\nConstant value used in potential value formula\n(X,Y) coordinates for goals\n(X,Y) coordinates for obstacles\nNumber of goals\nNumber of obstacles
a2a325f6	f24	p0	2024-09-23 22:32:38	main.cpp	8	8	Store input command
a2a325f6	f24	p0	2024-09-23 22:32:38	main.cpp	10	13	Loop through input file commands until "EXIT" command\nCreate a new grid of size N rows x M columns (ints)\nRows\nColumns
a2a325f6	f24	p0	2024-09-23 22:32:38	main.cpp	22	24	'G' for goal or 'O' for obstacle\nx coordinate for goal/obstacle position\ny coordinate for goal/obstacle position
a2a325f6	f24	p0	2024-09-23 22:32:38	main.cpp	37	38	x coordinate for current robot position\ny coordinate for current robot position
a2a325f6	f24	p0	2024-09-23 22:32:38	main.cpp	55	55	Constant in potential value formula
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	7	7	Constructor definition
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	20	20	Destructor definition
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	24	24	Rows freed
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	26	26	Pointers array freed and set to nullptr
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	32	32	Coordinates freed
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	34	34	Array of goals freed and set to nullptr
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	40	40	Coordinates freed
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	42	42	Array of obstacles freed and set to nullptr
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	48	48	Helper function
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	51	51	Calculate potential value at all cells
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	54	54	Reset potential value for current cell
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	56	56	Effect from goals on potential
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	65	65	Effect from obstacles on potential
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	74	74	Current cell is set to newly calculated potential value
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	84	85	Create grid as 2D array\nArray of pointers for each row
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	88	88	Each row is the length of the number of columns
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	91	91	Set all potential vector values to 0.0
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	95	95	Create dynamic array for goals and obstacles
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	101	101	2 elements per cell for coordinate (x,y)
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	109	109	insert the Goal/Obstacle if (X,Y) is in the bounds
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	111	111	G (goal) = 1.0
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	115	115	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	119	119	O (obstacle)= 2.0
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	123	123	Recalculate potential values for all other points
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	131	131	Coordinate out of bounds
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.cpp	137	137	(X,Y) is in the bounds then insert the Goal/Obstacle
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.h	4	4	Class declaration
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.h	7	8	constructor\nDestructor (frees up dynamically allocated memory)
a2a325f6	f24	p0	2024-10-07 22:48:35	FieldMap.h	18	25	Number of rows in grid\nNumber of columns in grid\nDynamically allocated 2D array\nConstant value used in potential value formula\n(X,Y) coordinates for goals\n(X,Y) coordinates for obstacles\nNumber of goals\nNumber of obstacles
a2a325f6	f24	p0	2024-10-07 22:48:35	main.cpp	8	8	Store input command
a2a325f6	f24	p0	2024-10-07 22:48:35	main.cpp	10	13	Loop through input file commands until "EXIT" command\nCreate a new grid of size N rows x M columns (ints)\nRows\nColumns
a2a325f6	f24	p0	2024-10-07 22:48:35	main.cpp	22	24	'G' for goal or 'O' for obstacle\nx coordinate for goal/obstacle position\ny coordinate for goal/obstacle position
a2a325f6	f24	p0	2024-10-07 22:48:35	main.cpp	37	38	x coordinate for current robot position\ny coordinate for current robot position
a2a325f6	f24	p0	2024-10-07 22:48:35	main.cpp	55	55	Constant in potential value formula
a3275c15	f24	p0	2024-09-19 19:56:15	Driver.cpp	28	28	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-19 19:56:15	Driver.cpp	30	30	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-19 19:56:15	Driver.cpp	62	62	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-19 19:56:15	Driver.cpp	64	64	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 19:56:15	Driver.cpp	66	66	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 19:56:15	Driver.cpp	99	99	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-19 19:56:15	Driver.cpp	110	110	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 19:56:15	Driver.cpp	112	112	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 19:56:15	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-19 19:56:15	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-19 20:06:17	Driver.cpp	28	28	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-19 20:06:17	Driver.cpp	30	30	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-19 20:06:17	Driver.cpp	62	62	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-19 20:06:17	Driver.cpp	64	64	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 20:06:17	Driver.cpp	66	66	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 20:06:17	Driver.cpp	99	99	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-19 20:06:17	Driver.cpp	110	110	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 20:06:17	Driver.cpp	112	112	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 20:06:17	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-19 20:06:17	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-19 20:11:38	Driver.cpp	28	28	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-19 20:11:38	Driver.cpp	30	30	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-19 20:11:38	Driver.cpp	62	62	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-19 20:11:38	Driver.cpp	64	64	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 20:11:38	Driver.cpp	66	66	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 20:11:38	Driver.cpp	99	99	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-19 20:11:38	Driver.cpp	110	110	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 20:11:38	Driver.cpp	112	112	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 20:11:38	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-19 20:11:38	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-19 20:11:46	Driver.cpp	28	28	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-19 20:11:46	Driver.cpp	30	30	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-19 20:11:46	Driver.cpp	62	62	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-19 20:11:46	Driver.cpp	64	64	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 20:11:46	Driver.cpp	66	66	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 20:11:46	Driver.cpp	99	99	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-19 20:11:46	Driver.cpp	110	110	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 20:11:46	Driver.cpp	112	112	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 20:11:46	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-19 20:20:23	Driver.cpp	28	28	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-19 20:20:23	Driver.cpp	30	30	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-19 20:20:23	Driver.cpp	62	62	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-19 20:20:23	Driver.cpp	64	64	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 20:20:23	Driver.cpp	66	66	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 20:20:23	Driver.cpp	99	99	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-19 20:20:23	Driver.cpp	110	110	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 20:20:23	Driver.cpp	112	112	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 20:20:23	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-19 21:01:05	Driver.cpp	28	28	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-19 21:01:05	Driver.cpp	30	30	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-19 21:01:05	Driver.cpp	62	62	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-19 21:01:05	Driver.cpp	64	64	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 21:01:05	Driver.cpp	66	66	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 21:01:05	Driver.cpp	99	99	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-19 21:01:05	Driver.cpp	110	110	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 21:01:05	Driver.cpp	112	112	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 21:01:05	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Driver.cpp	28	28	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Driver.cpp	30	30	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Driver.cpp	62	62	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Driver.cpp	64	64	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Driver.cpp	66	66	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Driver.cpp	99	99	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Driver.cpp	110	110	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Driver.cpp	112	112	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-19 21:13:44	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-19 21:51:45	Driver.cpp	28	28	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-19 21:51:45	Driver.cpp	30	30	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-19 21:51:45	Driver.cpp	62	62	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-19 21:51:45	Driver.cpp	64	64	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 21:51:45	Driver.cpp	66	66	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 21:51:45	Driver.cpp	99	99	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-19 21:51:45	Driver.cpp	110	110	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 21:51:45	Driver.cpp	112	112	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 21:51:45	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-19 21:51:45	Main.cpp	42	42	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-19 21:53:46	Driver.cpp	28	28	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-19 21:53:46	Driver.cpp	30	30	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-19 21:53:46	Driver.cpp	62	62	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-19 21:53:46	Driver.cpp	64	64	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 21:53:46	Driver.cpp	66	66	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 21:53:46	Driver.cpp	99	99	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-19 21:53:46	Driver.cpp	110	110	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-19 21:53:46	Driver.cpp	112	112	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-19 21:53:46	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-19 21:53:46	Main.cpp	42	42	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-20 14:31:21	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-20 14:31:21	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-20 14:31:21	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-20 14:31:21	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-20 14:31:21	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 14:31:21	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 14:31:21	Driver.cpp	102	102	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-20 14:31:21	Driver.cpp	113	113	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 14:31:21	Driver.cpp	115	115	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 14:31:21	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-20 14:31:21	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-20 14:36:26	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-20 14:36:26	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-20 14:36:26	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-20 14:36:26	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-20 14:36:26	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 14:36:26	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 14:36:26	Driver.cpp	102	102	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-20 14:36:26	Driver.cpp	113	113	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 14:36:26	Driver.cpp	115	115	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 14:36:26	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-20 14:36:26	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	73	73	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	103	103	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	114	114	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	116	116	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 14:57:03	Driver.cpp	120	120	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-20 14:57:03	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-20 14:57:03	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	73	73	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	103	103	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	114	114	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	116	116	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 15:21:30	Driver.cpp	120	120	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-20 15:21:30	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-20 15:21:30	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	73	73	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	103	103	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	114	114	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	116	116	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 15:23:17	Driver.cpp	120	120	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-20 15:23:17	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-20 15:23:17	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	73	73	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	103	103	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	114	114	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	116	116	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 15:25:12	Driver.cpp	120	120	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-20 15:25:12	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-20 15:25:12	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	73	73	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	103	103	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	114	114	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	116	116	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 17:14:22	Driver.cpp	120	120	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-20 17:14:22	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-20 17:14:22	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	73	73	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	103	103	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	114	114	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	116	116	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-20 17:31:40	Driver.cpp	120	120	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-20 17:31:40	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-20 17:31:40	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	73	73	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	103	103	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	114	114	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	116	116	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-21 04:04:04	Driver.cpp	120	120	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-21 04:04:04	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-21 04:04:04	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	73	73	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	103	103	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	114	114	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	116	116	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-21 19:20:29	Driver.cpp	120	120	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-21 19:20:29	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-21 19:20:29	Main.cpp	41	41	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	65	65	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	67	67	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	69	69	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	73	73	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	103	103	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	114	114	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	116	116	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-22 23:43:00	Driver.cpp	120	120	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-22 23:43:00	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-22 23:43:00	Main.cpp	43	43	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	69	69	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	71	71	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	73	73	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	81	81	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	111	111	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	122	122	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	124	124	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-22 23:48:06	Driver.cpp	132	132	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-22 23:48:06	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-22 23:48:06	Main.cpp	43	43	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	77	77	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	79	79	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	81	81	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	89	89	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	119	119	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	130	130	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	132	132	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-23 00:15:25	Driver.cpp	140	140	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-23 00:15:25	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-23 00:15:25	Main.cpp	43	43	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	29	29	std::cout << "Enter N: ";
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	31	31	std::cout << "Enter M: ";
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	77	77	std::cout << "Enter T: ";
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	79	79	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	81	81	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	89	89	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	119	119	std::cout << "Enter New K Values: ";
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	130	130	std::cout << "Enter X: ";
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	132	132	std::cout << "Enter Y: ";
a3275c15	f24	p0	2024-09-23 00:32:19	Driver.cpp	140	140	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-23 00:32:19	Main.cpp	12	12	std::cout << "Enter Command: ";
a3275c15	f24	p0	2024-09-23 00:32:19	Main.cpp	44	44	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-23 18:21:38	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-23 18:21:38	Driver.cpp	81	81	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-23 18:21:38	Driver.cpp	124	124	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-23 18:21:38	Main.cpp	65	65	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-23 19:30:13	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-23 19:30:13	Driver.cpp	61	64	void Map::PRINT() {\nif (map == nullptr) {\nreturn;\n}
a3275c15	f24	p0	2024-09-23 19:30:13	Driver.cpp	66	72	for (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; ++j) {\nstd::cout << map[i][j] << " ";\n}\nstd::cout << std::endl;\n}\n}
a3275c15	f24	p0	2024-09-23 19:30:13	Driver.cpp	81	81	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-23 19:30:13	Driver.cpp	124	124	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-23 19:30:13	Driver.hpp	20	20	void PRINT();
a3275c15	f24	p0	2024-09-23 19:30:13	Main.cpp	24	28	if (command == "PRINT") {\nif (map1 != nullptr) {\nmap1->PRINT();\n}\n}
a3275c15	f24	p0	2024-09-23 19:30:13	Main.cpp	65	65	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3275c15	f24	p0	2024-09-23 19:33:16	Driver.cpp	14	14	std::cout << "deallocate" << std::endl;
a3275c15	f24	p0	2024-09-23 19:33:16	Driver.cpp	61	64	void Map::PRINT() {\nif (map == nullptr) {\nreturn;\n}
a3275c15	f24	p0	2024-09-23 19:33:16	Driver.cpp	66	72	for (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; ++j) {\nstd::cout << map[i][j] << " ";\n}\nstd::cout << std::endl;\n}\n}
a3275c15	f24	p0	2024-09-23 19:33:16	Driver.cpp	81	81	std::cout << X << " " << N << std::endl;
a3275c15	f24	p0	2024-09-23 19:33:16	Driver.cpp	124	124	std::cout << X << " " << M << std::endl;
a3275c15	f24	p0	2024-09-23 19:33:16	Driver.hpp	20	20	void PRINT();
a3275c15	f24	p0	2024-09-23 19:33:16	Main.cpp	24	28	if (command == "PRINT") {\nif (map1 != nullptr) {\nmap1->PRINT();\n}\n}
a3275c15	f24	p0	2024-09-23 19:33:16	Main.cpp	65	65	scp -r hycheng_p0  hycheng@eceUbuntu.uwaterloo.ca:/home/hycheng/ece250
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	7	9	//////////////////////////////////////////////////////////////////////////////\nDefinitions for Tile Class\n//////////////////////////////////////////////////////////////////////////////
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	11	11	Constructor
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	19	19	Deconstructor
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	23	25	//////////////////\nSetter methods //\n//////////////////
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	27	27	Setter method xPotential
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	31	31	Setter method yPotential
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	35	35	Setter method for object on tile
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	39	39	Setter method for object on tile
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	44	46	//////////////////\nGetter methods //\n//////////////////
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	48	48	Getter method for xPotential
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	52	52	Getter method for yPotential
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	56	56	Getter method for object on tile
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	60	60	Returns if something occupies the tile or not
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	65	67	/ @brief Create the Grid\n/ @param n rows\n/ @param m columns
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	74	74	If a grid already exists, delete it first
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	78	78	Initialize grid as a dynamically allocated array of Tile pointers
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	80	80	Each pointer in GRID points to a dynamically allocated 1D array of Tiles
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	87	87	Deallocate current Grid
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	95	95	Compute all potential vectors
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	116	116	Check if (x,y) is out of bounds
a3d14003	f24	p0	2024-09-22 20:58:35	P0.cpp	166	166	Clear all potential vectors in the GRID
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	1	1	Individual tiles in the 2D grid array
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	4	4	Tile Constructors
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	6	6	Tile Destructor
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	9	9	Setter method xPotential
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	11	11	Setter method yPotential
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	13	13	Setter method for object on tile
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	15	15	Setter method for object on tile
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	18	18	Getter method for xPotential
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	20	20	Getter method for yPotential
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	22	22	Getter method for object on tile
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	24	24	Returns if something occupies the tile or not
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	33	33	Global Variables //
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	38	38	Create 2D array of tiles
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	41	41	Deallocates 2D array of tiles
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	44	44	Computes all potential values for each tile
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	47	47	Add a new object t at position (x,y)
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	50	50	Outputs potential values at (x,y)
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	53	53	Clear the grid of all obstacles and goals and resets the potentials to (0,0)
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	56	56	Updates value of K in pot field calculations. Recomputes all potentials if K is valid.
a3d14003	f24	p0	2024-09-22 20:58:35	Tile.hpp	59	59	Clears all potential values
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	7	9	//////////////////////////////////////////////////////////////////////////////\nDefinitions for Tile Class\n//////////////////////////////////////////////////////////////////////////////
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	11	11	Constructor
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	19	19	Deconstructor
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	23	25	//////////////////\nSetter methods //\n//////////////////
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	27	27	Setter method xPotential
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	31	31	Setter method yPotential
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	35	35	Setter method for object on tile
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	39	39	Setter method for object on tile
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	44	46	//////////////////\nGetter methods //\n//////////////////
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	48	48	Getter method for xPotential
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	52	52	Getter method for yPotential
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	56	56	Getter method for object on tile
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	60	60	Returns if something occupies the tile or not
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	65	67	/ @brief Create the Grid\n/ @param n rows\n/ @param m columns
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	74	74	If a grid already exists, delete it first
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	78	78	Initialize grid as a dynamically allocated array of Tile pointers
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	80	80	Each pointer in GRID points to a dynamically allocated 1D array of Tiles
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	87	87	Deallocate current Grid
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	95	95	Compute all potential vectors
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	116	116	Check if (x,y) is out of bounds
a3d14003	f24	p0	2024-09-22 21:01:08	P0.cpp	166	166	Clear all potential vectors in the GRID
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	1	1	Individual tiles in the 2D grid array
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	4	4	Tile Constructors
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	6	6	Tile Destructor
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	9	9	Setter method xPotential
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	11	11	Setter method yPotential
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	13	13	Setter method for object on tile
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	15	15	Setter method for object on tile
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	18	18	Getter method for xPotential
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	20	20	Getter method for yPotential
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	22	22	Getter method for object on tile
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	24	24	Returns if something occupies the tile or not
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	33	33	Global Variables //
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	38	38	Create 2D array of tiles
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	41	41	Deallocates 2D array of tiles
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	44	44	Computes all potential values for each tile
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	47	47	Add a new object t at position (x,y)
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	50	50	Outputs potential values at (x,y)
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	53	53	Clear the grid of all obstacles and goals and resets the potentials to (0,0)
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	56	56	Updates value of K in pot field calculations. Recomputes all potentials if K is valid.
a3d14003	f24	p0	2024-09-22 21:01:08	Tile.hpp	59	59	Clears all potential values
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	7	9	//////////////////////////////////////////////////////////////////////////////\nDefinitions for Tile Class\n//////////////////////////////////////////////////////////////////////////////
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	11	11	Constructor
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	19	19	Deconstructor
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	23	25	//////////////////\nSetter methods //\n//////////////////
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	27	27	Setter method xPotential
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	31	31	Setter method yPotential
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	35	35	Setter method for object on tile
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	39	39	Setter method for object on tile
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	44	46	//////////////////\nGetter methods //\n//////////////////
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	48	48	Getter method for xPotential
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	52	52	Getter method for yPotential
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	56	56	Getter method for object on tile
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	60	60	Returns if something occupies the tile or not
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	65	67	/ @brief Create the Grid\n/ @param n rows\n/ @param m columns
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	72	72	If a grid already exists, delete it first
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	79	79	Initialize grid as a dynamically allocated array of Tile pointers
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	81	81	Each pointer in GRID points to a dynamically allocated 1D array of Tiles
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	88	88	Deallocate current Grid
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	96	96	Compute all potential vectors
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	117	117	Check if (x,y) is out of bounds
a3d14003	f24	p0	2024-09-23 17:42:05	P0.cpp	167	167	Clear all potential vectors in the GRID
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	1	1	Individual tiles in the 2D grid array
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	4	4	Tile Constructors
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	6	6	Tile Destructor
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	9	9	Setter method xPotential
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	11	11	Setter method yPotential
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	13	13	Setter method for object on tile
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	15	15	Setter method for object on tile
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	18	18	Getter method for xPotential
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	20	20	Getter method for yPotential
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	22	22	Getter method for object on tile
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	24	24	Returns if something occupies the tile or not
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	33	33	Global Variables //
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	38	38	Create 2D array of tiles
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	41	41	Deallocates 2D array of tiles
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	44	44	Computes all potential values for each tile
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	47	47	Add a new object t at position (x,y)
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	50	50	Outputs potential values at (x,y)
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	53	53	Clear the grid of all obstacles and goals and resets the potentials to (0,0)
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	56	56	Updates value of K in pot field calculations. Recomputes all potentials if K is valid.
a3d14003	f24	p0	2024-09-23 17:42:05	Tile.hpp	59	59	Clears all potential values
a6125200	f24	p0	2024-09-21 21:04:38	program.h	6	8	questions\ninbounds function\npiazza
a6125200	f24	p0	2024-09-21 22:02:58	program.h	6	8	questions\ninbounds function\npiazza
a6125200	f24	p0	2024-09-22 12:48:22	program.h	6	8	questions\ninbounds function\npiazza
a6125200	f24	p0	2024-09-22 13:28:53	program.h	6	8	questions\ninbounds function\npiazza
a6125200	f24	p0	2024-09-22 14:51:28	program.h	6	8	questions\ninbounds function\npiazza
a6125200	f24	p0	2024-09-22 15:32:47	program.h	6	8	questions\ninbounds function\npiazza
a6125200	f24	p0	2024-09-22 15:40:01	program.h	6	8	questions\ninbounds function\npiazza
a6125200	f24	p0	2024-09-22 15:52:53	program.h	6	8	questions\ninbounds function\npiazza
a6125200	f24	p0	2024-09-23 18:48:19	program.h	6	8	questions\ninbounds function\npiazza
a6125200	f24	p0	2024-09-23 22:36:07	program.h	6	8	questions\ninbounds function\npiazza
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	9	9	Deallocate memory
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	15	15	If a grid already exists delete old one
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	21	21	Create 1D array to store goals and obstacles
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	25	25	1 by default
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	31	31	Check if grid exists and if the coordinates are out of bounds
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	41	41	Check if grid exists and if the coordinates are out of bounds
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	45	46	Calculate potential on demand\nLoop through entire array and add potential if O or T tile
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	50	50	Check if robot is on tile
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	53	53	Check if tile is a goal or obstacle
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	71	71	Check if grid exists
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	74	74	Set all goals and obstacles to default value
a6179a3d	f24	p0	2024-09-22 23:49:58	grid.cpp	85	85	K cannot be 0 or less
a6179a3d	f24	p0	2024-09-22 23:49:58	main.cpp	13	13	Read in entire line
a6179a3d	f24	p0	2024-09-22 23:49:58	main.cpp	16	16	Handle each unique command seperately
a6179a3d	f24	p0	2024-09-22 23:49:58	main.cpp	18	18	Get X, Y params
a6179a3d	f24	p0	2024-09-22 23:49:58	main.cpp	25	25	Get T, X, Y params
a6179a3d	f24	p0	2024-09-22 23:49:58	main.cpp	50	50	Get K param
a6179a3d	f24	p0	2024-09-22 23:49:58	main.cpp	55	55	Cleanup grid obj and exit loop
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	8	8	Deallocate memory
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	14	14	If a grid already exists delete old one
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	20	20	Create 1D array to store goals and obstacles
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	24	24	1 by default
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	30	30	Check if grid exists and if the coordinates are out of bounds
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	40	40	Check if grid exists and if the coordinates are out of bounds
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	44	45	Calculate potential on demand\nLoop through entire array and add potential if O or T tile
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	49	49	Check if robot is on tile
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	52	52	Check if tile is a goal or obstacle
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	70	70	Check if grid exists
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	73	73	Set all goals and obstacles to default value
a6179a3d	f24	p0	2024-09-23 00:19:23	grid.cpp	84	84	K cannot be 0 or less
a6179a3d	f24	p0	2024-09-23 00:19:23	main.cpp	13	13	Read in entire line
a6179a3d	f24	p0	2024-09-23 00:19:23	main.cpp	16	16	Handle each unique command seperately
a6179a3d	f24	p0	2024-09-23 00:19:23	main.cpp	18	18	Get X, Y params
a6179a3d	f24	p0	2024-09-23 00:19:23	main.cpp	25	25	Get T, X, Y params
a6179a3d	f24	p0	2024-09-23 00:19:23	main.cpp	50	50	Get K param
a6179a3d	f24	p0	2024-09-23 00:19:23	main.cpp	55	55	Cleanup grid obj and exit loop
a64a7c74	f24	p0	2024-09-23 17:45:18	Grid.cpp	58	58	go through all points and calc potential for everything on grid incrementally
a64a7c74	f24	p0	2024-09-23 17:45:18	main.cpp	31	31	Check if any point needs to be overwritten
a64a7c74	f24	p0	2024-09-23 22:27:34	Grid.cpp	58	58	go through all points and calc potential for everything on grid incrementally
a64a7c74	f24	p0	2024-09-23 22:27:34	main.cpp	31	31	Check if any point needs to be overwritten
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	5	5	set up 2D array with specified dimensions
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	15	15	deallocate dynamic 2D array
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	33	33	Print the combined potential in a grid format
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	36	36	Add a space between elements, except the last in the row
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	41	41	Move to the next row after printing a row of potentials
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	48	48	iterate through all tiles as a robot
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	52	53	For a given tile with a robot, iterate through all tiles to check if they have goal / obstacle\nIf there is a goal / obstacle, compute potential and add to total potential
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	116	116	Fix this to actually use the constructor and destructor
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	118	118	Delete original map
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.cpp	126	126	create empty map with the same height and width
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.hpp	31	31	double calc_pot(int x, int y, int xC, int yC, int state);
aaa363bf	f24	p0	2024-09-17 21:55:57	Grid.hpp	35	35	GRID_H
aaa363bf	f24	p0	2024-09-17 21:55:57	main.cpp	13	14	Should not implement functionality\nHow to implement the create function? -> pass the my_map pointer into the create function?
aaa363bf	f24	p0	2024-09-17 21:55:57	Tile.cpp	4	4	set up each tile to have initial pot vec of <0, 0>
aaa363bf	f24	p0	2024-09-17 21:55:57	Tile.hpp	16	16	-1 for goal, 1 for obstacle, 0 for neither
aaa363bf	f24	p0	2024-09-17 21:55:57	Tile.hpp	21	21	TILE_H
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	5	5	set up 2D array with specified dimensions
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	15	15	deallocate dynamic 2D array
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	32	32	Print the combined potential in a grid format
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	35	35	Add a space between elements, except the last in the row
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	40	40	Move to the next row after printing a row of potentials
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	44	44	Recomputes the potential contribution of a new goal/obstacle on a given tile to all other tiles on the grid
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	84	84	changes the state of the specified tile to goal / obstacle
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	94	94	factor by which the potential contribition of new tile changes other tiles' potentials
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	114	114	Fix this to actually use the constructor and destructor
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	116	116	Delete original map
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.cpp	124	124	create empty map with the same height and width
aaa363bf	f24	p0	2024-09-19 18:15:46	Grid.hpp	34	34	GRID_HPP
aaa363bf	f24	p0	2024-09-19 18:15:46	main.cpp	13	15	Grid::create(5, 5, my_map);\nmy_map->point('G', 2, 2);\nmy_map->print_map();
aaa363bf	f24	p0	2024-09-19 18:15:46	Tile.cpp	4	4	set up each tile to have initial pot vec of <0, 0>
aaa363bf	f24	p0	2024-09-19 18:15:46	Tile.hpp	16	16	-1 for goal, 1 for obstacle, 0 for neither
aaa363bf	f24	p0	2024-09-19 18:15:46	Tile.hpp	21	21	TILE_HPP
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	5	5	set up 2D array with specified dimensions
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	15	15	deallocate dynamic 2D array
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	32	32	Print the combined potential in a grid format
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	35	35	Add a space between elements, except the last in the row
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	40	40	Move to the next row after printing a row of potentials
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	44	44	Recomputes the potential contribution of a new goal/obstacle on a given tile to all other tiles on the grid
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	84	84	changes the state of the specified tile to goal / obstacle
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	94	94	factor by which the potential contribition of new tile changes other tiles' potentials
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	114	114	Fix this to actually use the constructor and destructor
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	118	118	Delete original map
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.cpp	126	126	create empty map with the same height and width
aaa363bf	f24	p0	2024-09-19 19:39:22	Grid.hpp	34	34	GRID_HPP
aaa363bf	f24	p0	2024-09-19 19:39:22	main.cpp	13	15	Grid::create(5, 5, my_map);\nmy_map->point('G', 2, 2);\nmy_map->print_map();
aaa363bf	f24	p0	2024-09-19 19:39:22	Tile.cpp	4	4	set up each tile to have initial pot vec of <0, 0>
aaa363bf	f24	p0	2024-09-19 19:39:22	Tile.hpp	16	16	-1 for goal, 1 for obstacle, 0 for neither
aaa363bf	f24	p0	2024-09-19 19:39:22	Tile.hpp	21	21	TILE_HPP
aaa363bf	f24	p0	2024-09-22 16:47:36	Grid.cpp	5	5	set up 2D array with specified dimensions
aaa363bf	f24	p0	2024-09-22 16:47:36	Grid.cpp	13	13	deallocate dynamic 2D array
aaa363bf	f24	p0	2024-09-22 16:47:36	Grid.cpp	22	22	Recomputes the potential contribution of a new goal/obstacle on a given tile to all other tiles on the grid
aaa363bf	f24	p0	2024-09-22 16:47:36	Grid.cpp	60	60	changes the state of the specified tile to goal / obstacle
aaa363bf	f24	p0	2024-09-22 16:47:36	Grid.cpp	63	63	factor by which the potential contribition of new tile changes other tiles' potentials
aaa363bf	f24	p0	2024-09-22 16:47:36	Grid.cpp	84	84	Delete original grid
aaa363bf	f24	p0	2024-09-22 16:47:36	Grid.cpp	92	92	create empty grid with the same height and width
aaa363bf	f24	p0	2024-09-22 16:47:36	Grid.hpp	30	30	GRID_HPP
aaa363bf	f24	p0	2024-09-22 16:47:36	Tile.cpp	4	4	set up each tile to have initial pot vec of <0, 0>
aaa363bf	f24	p0	2024-09-22 16:47:36	Tile.hpp	11	11	-1 for goal, 1 for obstacle, 0 for neither
aaa363bf	f24	p0	2024-09-22 16:47:36	Tile.hpp	16	16	TILE_HPP
aaa363bf	f24	p0	2024-09-23 10:53:32	Grid.cpp	5	5	set up 2D array with specified dimensions
aaa363bf	f24	p0	2024-09-23 10:53:32	Grid.cpp	13	13	deallocate dynamic 2D array
aaa363bf	f24	p0	2024-09-23 10:53:32	Grid.cpp	22	22	Recomputes the potential contribution of a new goal/obstacle on a given tile to all other tiles on the grid
aaa363bf	f24	p0	2024-09-23 10:53:32	Grid.cpp	60	60	changes the state of the specified tile to goal / obstacle
aaa363bf	f24	p0	2024-09-23 10:53:32	Grid.cpp	63	63	factor by which the potential contribition of new tile changes other tiles' potentials
aaa363bf	f24	p0	2024-09-23 10:53:32	Grid.cpp	84	84	Delete original grid
aaa363bf	f24	p0	2024-09-23 10:53:32	Grid.cpp	92	92	create empty grid with the same height and width
aaa363bf	f24	p0	2024-09-23 10:53:32	Grid.hpp	30	30	GRID_HPP
aaa363bf	f24	p0	2024-09-23 10:53:32	Tile.cpp	4	4	set up each tile to have initial pot vec of <0, 0>
aaa363bf	f24	p0	2024-09-23 10:53:32	Tile.hpp	11	11	-1 for goal, 1 for obstacle, 0 for neither
aaa363bf	f24	p0	2024-09-23 10:53:32	Tile.hpp	16	16	TILE_HPP
aaa363bf	f24	p0	2024-09-23 15:00:15	Grid.cpp	5	5	set up 2D array with specified dimensions
aaa363bf	f24	p0	2024-09-23 15:00:15	Grid.cpp	13	13	deallocate dynamic 2D array
aaa363bf	f24	p0	2024-09-23 15:00:15	Grid.cpp	22	22	Recomputes the potential contribution of a new goal/obstacle on a given tile to all other tiles on the grid
aaa363bf	f24	p0	2024-09-23 15:00:15	Grid.cpp	60	60	changes the state of the specified tile to goal / obstacle
aaa363bf	f24	p0	2024-09-23 15:00:15	Grid.cpp	63	63	factor by which the potential contribition of new tile changes other tiles' potentials
aaa363bf	f24	p0	2024-09-23 15:00:15	Grid.cpp	84	84	Delete original grid
aaa363bf	f24	p0	2024-09-23 15:00:15	Grid.cpp	92	92	create empty grid with the same height and width
aaa363bf	f24	p0	2024-09-23 15:00:15	Grid.hpp	30	30	GRID_HPP
aaa363bf	f24	p0	2024-09-23 15:00:15	Tile.cpp	4	4	set up each tile to have initial pot vec of <0, 0>
aaa363bf	f24	p0	2024-09-23 15:00:15	Tile.hpp	11	11	-1 for goal, 1 for obstacle, 0 for neither
aaa363bf	f24	p0	2024-09-23 15:00:15	Tile.hpp	16	16	TILE_HPP
ab8419b4	f24	p0	2024-09-23 17:50:58	map.cpp	62	62	Calculate the potential at point (x, y) due to each goal and obstacle in array
ab8419b4	f24	p0	2024-09-23 18:10:26	map.cpp	65	65	Calculate the potential at point (x, y) due to each goal and obstacle in array
ab8419b4	f24	p0	2024-09-23 18:23:49	map.cpp	65	65	Calculate the potential at point (x, y) due to each goal and obstacle in array
ab8419b4	f24	p0	2024-09-23 19:57:48	map.cpp	65	65	Calculate the potential at point (x, y) due to each goal and obstacle in array
ab8419b4	f24	p0	2024-09-23 20:06:28	map.cpp	62	62	Calculate the potential at point (x, y) due to each goal and obstacle in array
ab8419b4	f24	p0	2024-10-02 11:53:27	map.cpp	62	62	Calculate the potential at point (x, y) due to each goal and obstacle in array
aead40d3	f24	p0	2024-09-22 20:29:00	Cell.h	14	14	'E', 'O', 'G are the types
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	7	8	constructor for class grid, takes parameters rows and columns\ndynamically allocating memory for 2d array, first dim. for rows
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	10	10	dynamically allocating memory for each column
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	15	15	destructor for class grid, prevents memory leaks by freeing dynamically allocated memory
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	17	17	delete rows
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	19	19	delete array of pointers
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	24	26	if position is within bounds\nadd description of cell to be obstacle or goal\ninsertion was successful
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	29	30	then out of bounds\ninsertion not successful
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	35	35	calculating for each single cell
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	37	37	if we are in the same position as obstacle or goal, potential is 0
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	50	50	calculating for entire map
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	54	54	if we are in same spot as obstacle or goal, skip calculating the potential
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	66	66	location is in array
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	76	76	if a grid has been created continue to resetting all values to 0
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	84	84	if no grid then cannot set any values to 0.0, failure
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	92	93	if k valid\nupdate k value
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	98	98	iterate through all cells and recalculate all potentials
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.cpp	107	107	if k not valid
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.hpp	13	14	constructor\ndestructor
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.hpp	17	20	function to add goal or obstacle to (x,y) within array\nwill output next position to move to\nfunction to clear a grid of goals and obstacles\nfunction to update k value
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.hpp	26	26	pointer for 2D array that will hold potential values
b33d43ee	f24	p0	2024-09-23 14:33:45	grid.hpp	28	29	function to calculate potential value for map\nfunction to calculate potential value for each cell
b33d43ee	f24	p0	2024-09-23 14:33:45	main.cpp	14	15	pointer is nullptr since no map yet\nstore command from user input
b33d43ee	f24	p0	2024-09-23 14:33:45	robot.hpp	17	18	value of potential in cell\nG/O/N for type of object found in the cell
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	7	8	constructor for class grid, takes parameters rows and columns\ndynamically allocating memory for 2d array, first dim. for rows
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	10	10	dynamically allocating memory for each column
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	15	15	destructor for class grid, prevents memory leaks by freeing dynamically allocated memory
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	17	17	delete rows
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	19	19	delete array of pointers
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	24	26	if position is within bounds\nadd description of cell to be obstacle or goal\ninsertion was successful
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	29	30	then out of bounds\ninsertion not successful
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	35	35	calculating for each single cell
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	38	38	if we are in the same position as obstacle or goal, potential is 0
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	53	53	calculating for entire map
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	57	57	if we are in same spot as obstacle or goal, skip calculating the potential
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	69	69	location is in array
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	79	79	if a grid has been created continue to resetting all values to 0
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	87	87	if no grid then cannot set any values to 0.0, failure
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	95	96	if k valid\nupdate k value
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	101	101	iterate through all cells and recalculate all potentials
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.cpp	110	110	if k not valid
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.hpp	13	14	constructor\ndestructor
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.hpp	17	20	function to add goal or obstacle to (x,y) within array\nwill output next position to move to\nfunction to clear a grid of goals and obstacles\nfunction to update k value
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.hpp	26	26	pointer for 2D array that will hold potential values
b33d43ee	f24	p0	2024-09-23 15:20:23	grid.hpp	28	29	function to calculate potential value for map\nfunction to calculate potential value for each cell
b33d43ee	f24	p0	2024-09-23 15:20:23	main.cpp	14	15	pointer is nullptr since no map yet\nstore command from user input
b33d43ee	f24	p0	2024-09-23 15:20:23	robot.hpp	17	18	value of potential in cell\nG/O/N for type of object found in the cell
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter_lib.cpp	5	5	for time(NULL)
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter_lib.cpp	15	15	main game function
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter_lib.cpp	31	31	show
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter_lib.cpp	36	36	mark
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter_lib.cpp	41	41	restart
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter_lib.cpp	76	76	gets initial conditions of the board
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter_lib.cpp	99	99	calls functions to create the board
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter.cpp	125	125	check if each nongoose field is unhidden
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter.cpp	127	128	if the field is hidden and nongoose\nnot winning
b33d43ee	f24	p0	2024-09-23 16:04:01	geesespotter.cpp	134	134	outside of the loop - must be winning
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	7	8	constructor for class grid, takes parameters rows and columns\ndynamically allocating memory for 2d array, first dim. for rows
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	10	10	dynamically allocating memory for each column
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	15	15	destructor for class grid, prevents memory leaks by freeing dynamically allocated memory
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	17	17	delete rows
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	19	19	delete array of pointers
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	24	24	if position is within bounds
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	26	27	add description of cell to be obstacle or goal\ninsertion was successful
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	30	30	insertion not successful
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	33	34	then out of bounds\ninsertion not successful
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	39	39	calculating for each single cell
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	42	42	if we are in the same position as obstacle or goal, potential is 0
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	58	58	calculating for entire map
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	62	62	if we are in same spot as obstacle or goal, skip calculating the potential
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	74	74	location is in array
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	84	84	if a grid has been created continue to resetting all values to 0
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	92	92	if no grid then cannot set any values to 0.0, failure
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	100	101	if k valid\nupdate k value
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	106	106	iterate through all cells and recalculate all potentials
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.cpp	115	115	if k not valid
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.hpp	13	14	constructor\ndestructor
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.hpp	17	20	function to add goal or obstacle to (x,y) within array\nwill output next position to move to\nfunction to clear a grid of goals and obstacles\nfunction to update k value
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.hpp	26	26	pointer for 2D array that will hold potential values
b33d43ee	f24	p0	2024-09-23 16:04:01	grid.hpp	28	29	function to calculate potential value for map\nfunction to calculate potential value for each cell
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	63	65	GIVEN\nMember functions to get values.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	80	82	GIVEN\nMember functions to set values.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	89	91	GIVEN\nPrint the transaction.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	114	120	//////////////////////////////////////////////////////////////////////////////\nDefinitions for the History class\n//////////////////////////////////////////////////////////////////////////////\n\n\nConstructor\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	125	126	Destructor.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	128	132	initializing a pointer called current to the first in the linked list where p_head is used to point at it\nthis loop is being used to iterate through each node/object in the list saying that as long as the current one is not null continue to delete\nthis says point to the next node by first finding the next one using the get next method from the current position we are at\nthis deletes the position we just moved from\nthis updates the current position we just deleted to the one we moved to from the get_next
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	135	135	once the linked list is empty, p_head is set to nullptr which says the linked list is now empty as it does not point to anything (specified in the doc)
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	138	139	Insert transaction into linked list.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	143	144	if statement is checking if the list is empty if yes then,\nthis updates the p_head for the list to point at the new trans we just inserted at the beginnning since p_head must point at the first in the list
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	146	146	this initializes a pointer called current that will be used in the loop to iterate through the following pointers at objects in the linked list
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	148	150	this while loop checks to see if there are more objects and checks to see if the current object we are looking at has a lower trans id than the one we are trying to indert\nthis tells us to point to the next in the list since the trans id is still lower than that of the one we are trying to insert\nthe loop breaks when the spot our trans should go in
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	153	153	this makes the next pointer of the current in the list point at the trans we just inserted
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	157	158	Read the transaction history from file.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	160	160	calling the function to open file before using any of the provided functions?
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	162	163	this loop is telling us to iterate through each transaction in the input file and read what is below as long as the nexttransentry function indicates there is another trans\nFunctions to access the parsed fields from prject4.cpp
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	172	172	now we need to dynamically allocate memory for the transaction we just read the details of to create the list
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	174	176	we just created a new transaction according to what we read from the input file and included all the information we read\nnow we call the insert function to insert this transaction into the list\nthis tells the insert function to use the trans we just created to insert into the list
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	178	178	calling the function to close the file once complete
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	181	182	Print the transaction history.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	184	186	here we initialize a pointer to point at the first in the list so that we can use it in a loop\nwe will use a loop to print each part of the transaction in the order given on the assignment doc\nthe loop will break once there is no next transaction
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	191	191	this tells us to set the current position to the next in the list by using getnext to get to the next transaction
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	197	197	initialize a new sorted list with pointer head called sorted list head
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	199	199	this is setting up a temporary pointer to start at phead of the original ist so we can go through it in order
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	202	203	loop statement says while the current transaction exists do the following\ninitializing a poinnter next og list to say the pointer next og list let it point at the trans after the one we are currently looking at
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	206	206	this if statement says if the first trans in the sorted list is nullptr or if the current trans is less than the first one in the sorted list then do the following
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	208	209	this says put the current trans first by making it point to the original head next\nthis upates the first poinnter in the sorted list to point at the one we jyst inseretd
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	211	212	if there is a head or if the trans we are trying to insert is more than the current first then go through the sorted list till you find its place\ninitializing a pointer to point at the head so we can go through the sorted list top to bottom
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	214	215	while condititon says while there is a next trans AND the one we are trying to insert is more than the one we are looking at do the following\nget the next trans in the sorted list and go through the loop ahain
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	218	218	once the loop breaks and we have where the trans should be inserted we need to set the trans after the trans we inserted to be the one we inserted before it
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	223	223	now we need to do the next trans in the og list
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	227	227	now we should set the first pointer the head of the original list to point at the sorted list head because print function uses phead so we can print the sorted list not the original
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	237	237	if its a buy transaction
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	243	243	if it is not the first trans in the list
b33d43ee	f24	p0	2024-09-23 16:04:01	History_Transaction_definitions.cpp	262	262	if its a sell transaction
b33d43ee	f24	p0	2024-09-23 16:04:01	History.hpp	12	13	Constructor\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History.hpp	16	17	Destructor.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History.hpp	20	21	Insert transaction into linked list.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History.hpp	24	25	Read the transaction history from file.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History.hpp	28	29	Print the transaction history.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History.hpp	32	33	Sort using insertion sort.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History.hpp	36	37	Update the acb members in the linked list.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	History.hpp	40	41	Compute the ACB, and CGL.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	main.cpp	14	15	pointer is nullptr since no map yet\nstore command from user input
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	1	6	//////////////////////////////////\nECE 150: Project 4\n\nAuthors: Douglas Harder\nHiren Patel\n//////////////////////////////////
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	19	19	File and string parsing
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	25	25	Ticker symbol.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	28	28	Date fields.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	33	33	Transaction type, shares and amount.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	39	41	//////////////////\nFile functions //\n//////////////////
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	43	43	Open the file for reading
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	45	46	If the file is already open, close it\n- this is just in case the file changed since the last opening
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	51	51	Open the file and set the character position to zero
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	54	54	If the file did not open, indicate an error occurred.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	59	59	Assign to the string the 'content' the contents of the file
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	68	68	Moves to the next transaction entry.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	82	82	Functions to access the parsed fields.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.cpp	97	97	namespace ece150
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	3	8	//////////////////////////////////\nECE 150: Project 4\n\nAuthors: Douglas Harder\nHiren Patel\n//////////////////////////////////
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	19	19	File and string parsing
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	25	25	Ticker symbol.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	28	28	Date fields.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	33	33	Transaction type, shares and amount.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	38	40	//////////////////\nFile functions //\n//////////////////
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	42	42	Open the file for reading
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	47	47	Moves to the next transaction entry.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	50	50	Functions to access the parsed fields.
b33d43ee	f24	p0	2024-09-23 16:04:01	project4.hpp	65	65	namespace ece150
b33d43ee	f24	p0	2024-09-23 16:04:01	robot.hpp	17	18	value of potential in cell\nG/O/N for type of object found in the cell
b33d43ee	f24	p0	2024-09-23 16:04:01	Transaction.hpp	10	11	Constructor\n
b33d43ee	f24	p0	2024-09-23 16:04:01	Transaction.hpp	17	18	Destructor\n
b33d43ee	f24	p0	2024-09-23 16:04:01	Transaction.hpp	22	23	Overloaded < operator.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	Transaction.hpp	26	27	Member functions to get values.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	Transaction.hpp	42	43	Member functions to set values.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	Transaction.hpp	50	51	Print the transaction.\n
b33d43ee	f24	p0	2024-09-23 16:04:01	Transaction.hpp	64	64	These private members have to be populated.
b33d43ee	f24	p0	2024-09-23 16:04:01	Transaction.hpp	72	73	A unique identifier class variable to assign identifiers (trans_id).\n
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	7	8	constructor for class grid, takes parameters rows and columns\ndynamically allocating memory for 2d array, first dim. for rows
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	10	10	dynamically allocating memory for each column
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	15	15	destructor for class grid, prevents memory leaks by freeing dynamically allocated memory
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	17	17	delete rows
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	19	19	delete array of pointers
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	24	24	if position is within bounds
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	26	27	add description of cell to be obstacle or goal\ninsertion was successful
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	30	30	insertion not successful
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	33	34	then out of bounds\ninsertion not successful
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	39	39	calculating for each single cell
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	42	42	if we are in the same position as obstacle or goal, potential is 0
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	58	58	calculating for entire map
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	62	62	if we are in same spot as obstacle or goal, skip calculating the potential
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	74	74	location is in array
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	84	84	if a grid has been created continue to resetting all values to 0
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	92	92	if no grid then cannot set any values to 0.0, failure
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	100	101	if k valid\nupdate k value
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	106	106	iterate through all cells and recalculate all potentials
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.cpp	115	115	if k not valid
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.hpp	13	14	constructor\ndestructor
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.hpp	17	20	function to add goal or obstacle to (x,y) within array\nwill output next position to move to\nfunction to clear a grid of goals and obstacles\nfunction to update k value
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.hpp	26	26	pointer for 2D array that will hold potential values
b33d43ee	f24	p0	2024-09-23 16:07:37	grid.hpp	28	29	function to calculate potential value for map\nfunction to calculate potential value for each cell
b33d43ee	f24	p0	2024-09-23 16:07:37	main.cpp	14	15	pointer is nullptr since no map yet\nstore command from user input
b33d43ee	f24	p0	2024-09-23 16:07:37	robot.hpp	17	18	value of potential in cell\nG/O/N for type of object found in the cell
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	7	8	constructor for class grid, takes parameters rows and columns\ndynamically allocating memory for 2d array, first dim. for rows
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	10	10	dynamically allocating memory for each column
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	15	15	destructor for class grid, prevents memory leaks by freeing dynamically allocated memory
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	17	17	delete rows
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	19	19	delete array of pointers
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	24	24	if position is within bounds
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	26	27	add description of cell to be obstacle or goal\ninsertion was successful
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	30	30	insertion not successful
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	33	34	then out of bounds\ninsertion not successful
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	39	39	calculating for each single cell
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	42	42	if we are in the same position as obstacle or goal, potential is 0
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	59	59	calculating for entire map
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	63	63	if we are in same spot as obstacle or goal, skip calculating the potential
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	76	76	location is in array
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	86	86	if a grid has been created continue to resetting all values to 0
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	94	94	if no grid then cannot set any values to 0.0, failure
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	102	103	if k valid\nupdate k value
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	107	107	iterate through all cells and recalculate all potentials
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.cpp	116	116	if k not valid
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.hpp	13	14	constructor\ndestructor
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.hpp	17	20	function to add goal or obstacle to (x,y) within array\nwill output next position to move to\nfunction to clear a grid of goals and obstacles\nfunction to update k value
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.hpp	26	26	pointer for 2D array that will hold potential values
b33d43ee	f24	p0	2024-09-23 17:49:10	grid.hpp	28	29	function to calculate potential value for map\nfunction to calculate potential value for each cell
b33d43ee	f24	p0	2024-09-23 17:49:10	main.cpp	14	15	pointer is nullptr since no map yet\nstore command from user input
b33d43ee	f24	p0	2024-09-23 17:49:10	robot.hpp	17	18	value of potential in cell\nG/O/N for type of object found in the cell
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	7	8	constructor for class grid, takes parameters rows and columns\ndynamically allocating memory for 2d array, first dim. for rows
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	10	10	dynamically allocating memory for each column
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	15	15	destructor for class grid, prevents memory leaks by freeing dynamically allocated memory
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	17	17	delete rows
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	19	19	delete array of pointers
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	24	24	if position is within bounds
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	26	27	add description of cell to be obstacle or goal\ninsertion was successful
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	30	30	insertion not successful
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	33	34	then out of bounds\ninsertion not successful
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	39	39	calculating for each single cell
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	42	42	if we are in the same position as obstacle or goal, potential is 0
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	58	58	calculating for entire map
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	62	62	if we are in same spot as obstacle or goal, skip calculating the potential
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	74	74	location is in array
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	84	84	if a grid has been created continue to resetting all values to 0
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	92	92	if no grid then cannot set any values to 0.0, failure
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	100	101	if k valid\nupdate k value
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	106	106	iterate through all cells and recalculate all potentials
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.cpp	115	115	if k not valid
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.hpp	13	14	constructor\ndestructor
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.hpp	17	20	function to add goal or obstacle to (x,y) within array\nwill output next position to move to\nfunction to clear a grid of goals and obstacles\nfunction to update k value
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.hpp	26	26	pointer for 2D array that will hold potential values
b33d43ee	f24	p0	2024-09-23 17:54:16	grid.hpp	28	29	function to calculate potential value for map\nfunction to calculate potential value for each cell
b33d43ee	f24	p0	2024-09-23 17:54:16	main.cpp	14	15	pointer is nullptr since no map yet\nstore command from user input
b33d43ee	f24	p0	2024-09-23 17:54:16	robot.hpp	17	18	value of potential in cell\nG/O/N for type of object found in the cell
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	7	8	constructor for class grid, takes parameters rows and columns\ndynamically allocating memory for 2d array, first dim. for rows
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	10	10	dynamically allocating memory for each column
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	15	15	destructor for class grid, prevents memory leaks by freeing dynamically allocated memory
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	17	17	delete rows
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	19	19	delete array of pointers
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	24	24	if position is within bounds
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	26	27	add description of cell to be obstacle or goal\ninsertion was successful
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	30	30	insertion not successful
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	33	34	then out of bounds\ninsertion not successful
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	39	39	calculating for each single cell
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	42	42	if we are in the same position as obstacle or goal, potential is 0
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	58	58	calculating for entire map
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	62	62	if we are in same spot as obstacle or goal, skip calculating the potential
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	74	74	location is in array
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	84	84	if a grid has been created continue to resetting all values to 0
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	92	92	if no grid then cannot set any values to 0.0, failure
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	100	101	if k valid\nupdate k value
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	106	106	iterate through all cells and recalculate all potentials
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.cpp	115	115	if k not valid
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.hpp	13	14	constructor\ndestructor
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.hpp	17	20	function to add goal or obstacle to (x,y) within array\nwill output next position to move to\nfunction to clear a grid of goals and obstacles\nfunction to update k value
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.hpp	26	26	pointer for 2D array that will hold potential values
b33d43ee	f24	p0	2024-09-23 18:04:11	grid.hpp	28	29	function to calculate potential value for map\nfunction to calculate potential value for each cell
b33d43ee	f24	p0	2024-09-23 18:04:11	main.cpp	14	15	pointer is nullptr since no map yet\nstore command from user input
b33d43ee	f24	p0	2024-09-23 18:04:11	robot.hpp	17	18	value of potential in cell\nG/O/N for type of object found in the cell
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	7	8	constructor for class grid, takes parameters rows and columns\ndynamically allocating memory for 2d array, first dim. for rows
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	10	10	dynamically allocating memory for each column
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	15	15	destructor for class grid, prevents memory leaks by freeing dynamically allocated memory
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	17	17	delete rows
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	19	19	delete array of pointers
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	24	24	if position is within bounds
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	26	27	add description of cell to be obstacle or goal\ninsertion was successful
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	30	30	insertion not successful
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	33	34	then out of bounds\ninsertion not successful
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	39	39	calculating for each single cell
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	42	42	if we are in the same position as obstacle or goal, potential is 0
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	58	58	calculating for entire map
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	62	62	if we are in same spot as obstacle or goal, skip calculating the potential
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	74	74	location is in array
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	84	84	if a grid has been created continue to resetting all values to 0
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	92	92	if no grid then cannot set any values to 0.0, failure
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	100	101	if k valid\nupdate k value
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	106	106	iterate through all cells and recalculate all potentials
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.cpp	115	115	if k not valid
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.hpp	13	14	constructor\ndestructor
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.hpp	17	20	function to add goal or obstacle to (x,y) within array\nwill output next position to move to\nfunction to clear a grid of goals and obstacles\nfunction to update k value
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.hpp	26	26	pointer for 2D array that will hold potential values
b33d43ee	f24	p0	2024-09-23 18:49:40	grid.hpp	28	29	function to calculate potential value for map\nfunction to calculate potential value for each cell
b33d43ee	f24	p0	2024-09-23 18:49:40	main.cpp	14	15	pointer is nullptr since no map yet\nstore command from user input
b33d43ee	f24	p0	2024-09-23 18:49:40	robot.hpp	17	18	value of potential in cell\nG/O/N for type of object found in the cell
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	7	8	constructor for class grid, takes parameters rows and columns\ndynamically allocating memory for 2d array, first dim. for rows
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	10	10	dynamically allocating memory for each column
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	15	15	destructor for class grid, prevents memory leaks by freeing dynamically allocated memory
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	17	17	delete rows
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	19	19	delete array of pointers
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	24	24	if position is within bounds
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	26	27	add description of cell to be obstacle or goal\ninsertion was successful
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	30	30	insertion not successful
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	33	34	then out of bounds\ninsertion not successful
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	39	39	calculating for each single cell
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	42	42	if we are in the same position as obstacle or goal, potential is 0
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	58	58	calculating for entire map
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	62	62	if we are in same spot as obstacle or goal, skip calculating the potential
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	74	74	location is in array
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	84	84	if a grid has been created continue to resetting all values to 0
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	92	92	if no grid then cannot set any values to 0.0, failure
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	100	101	if k valid\nupdate k value
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	106	106	iterate through all cells and recalculate all potentials
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.cpp	115	115	if k not valid
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.hpp	13	14	constructor\ndestructor
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.hpp	17	20	function to add goal or obstacle to (x,y) within array\nwill output next position to move to\nfunction to clear a grid of goals and obstacles\nfunction to update k value
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.hpp	26	26	pointer for 2D array that will hold potential values
b33d43ee	f24	p0	2024-09-23 20:31:33	grid.hpp	28	29	function to calculate potential value for map\nfunction to calculate potential value for each cell
b33d43ee	f24	p0	2024-09-23 20:31:33	main.cpp	14	15	pointer is nullptr since no map yet\nstore command from user input
b33d43ee	f24	p0	2024-09-23 20:31:33	robot.hpp	17	18	value of potential in cell\nG/O/N for type of object found in the cell
b92c1a1f	f24	p0	2024-09-18 15:40:39	Grid.cpp	26	26	point command
b92c1a1f	f24	p0	2024-09-18 15:40:39	Grid.cpp	46	46	add 0 to the potential no matter what as long as the robot is on that tile
b92c1a1f	f24	p0	2024-09-18 15:40:39	Grid.cpp	65	65	recompute every single potential
b92c1a1f	f24	p0	2024-09-18 15:40:39	Grid.cpp	85	85	get the point's potential
b92c1a1f	f24	p0	2024-09-18 15:40:39	Grid.cpp	99	100	clear array of all obstacles and goals\nreset potential to 0
b92c1a1f	f24	p0	2024-09-18 15:40:39	Point.cpp	6	6	default at nothing
b92c1a1f	f24	p0	2024-09-18 15:40:39	Point.hpp	9	9	accessor functions
b92c1a1f	f24	p0	2024-09-18 15:40:39	PotentialField.cpp	14	14	update function
b92c1a1f	f24	p0	2024-09-18 15:40:39	potentialFieldsTester.cpp	66	66	K value
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	14	16	o_count = 1;\nx_obstacles = new int[o_count];\ny_obstacles = new int[o_count];
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	36	37	default value\nReset grid pointer to prevent dangling pointers
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	45	45	if a grid is already created - delete and initalize a new one :: instructions
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	51	51	Update the grid dimensions in the object
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	55	55	setting the k value constant to 1;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	60	60	initalizing 2d dynamic array and setting the values to 0;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	68	69	Explicitly set each element to 0.0\nstd::cout << "*";
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	71	71	std::cout << "" << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	79	79	if inputted x,y coordinates are out of bounds - print failure msg
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	84	86	for goals you're always overwriting the current one\nif update var is negative - do overrwrite commands\nstd::cout << "override code" << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	88	88	overwriting old goal by adding its potential values back (essentially negating it)
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	93	93	update new goal values and recalculate potential
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	96	96	this way for the first time it will not run overwrite commands but every time after it will
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	99	99	potential_calculator(sign, x_goal, y_goal);
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	106	106	std::cout << "Obstacle added at (" << x << ", " << y << ")" << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	114	114	send different k value update in update func
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	118	119	std::cout << k << std::endl;\ndouble distance = 0.0;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	126	126	for cells that are labelled as obstacles/goals set the potential value to 0
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	130	130	std::cout << grid[i][j] << " ";
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	133	133	std::cout << "" << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	136	136	this -> grid = grid;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	142	144	std::cout << grid[0][0] << std::endl;\nstd::cout << k << std::endl;\nstd::cout << k_new << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	146	146	std::cout << k << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	152	152	std::cout << grid[i][j] << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	156	156	std::cout << " " << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	162	164	std::cout << "new k: " << k << std::endl;\nstd::cout << grid[0][0] << std::endl;\nstd::cout << k << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	170	170	Check if grid is created and valid
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	172	172	The grid has not been created or has invalid dimensions
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	176	176	Reset all the grid cells to 0.0
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	179	179	Explicitly set each element to 0.0
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	188	189	m = x, n = y\nstd::cout << "debug move" << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	197	198	// Initializing min value with some grid element\nDefault to the current square if there are no neighbors
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	200	203	// Check the top square (if it exists)\nif (y > 0 && min > grid[x][y-1]) {\nmin = grid[x][y-1];\n}
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	205	208	// Check the bottom square (if it exists)\nif (y < n-1 && min > grid[x][y+1]) {\nmin = grid[x][y+1];\n}
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	210	213	// Check the right square (if it exists)\nif (x < m-1 && min > grid[x+1][y]) {\nmin = grid[x+1][y];\n}
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	215	218	// Check the left square (if it exists)\nif (x > 0 && min > grid[x-1][y]) {\nmin = grid[x-1][y];\n}
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.cpp	220	220	Print the minimum value twice
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.h	9	9	dimensions of the grid
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.h	12	12	potential variable
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.h	22	24	// variables to track positions of goals\nint x_goal = 0;\nint y_goal = 0;
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.h	28	28	counting how many obstacles i have
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.h	32	36	\nconstructor\ndestructor
bd6d2784	f24	p0	2024-09-22 20:08:26	Grid.h	38	38	create function
bd6d2784	f24	p0	2024-09-22 20:08:26	main.cpp	9	12	for tracking the rows and cols of the grid\nfor tracking the inputted x and y params for various funcs\neither an obstacle or goal\ncreate instance of grid class
bd6d2784	f24	p0	2024-09-22 20:08:26	main.cpp	19	22	std::cout << "debug 1" << std::endl;\nread parameter svalues\ncreate new grid with inputted parameters\ncan i access m and n above throughout the code? // do i make it a pointer
bd6d2784	f24	p0	2024-09-22 20:08:26	main.cpp	26	26	std::cout << "debug 2" << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	main.cpp	37	37	std::cout << "debug 4" << std::endl;
bd6d2784	f24	p0	2024-09-22 20:08:26	main.cpp	46	46	std::cout << "debug 5" << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	39	39	Reset grid to zero
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	46	46	Add goal potential
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	51	51	Add obstacle potentials
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	62	62	Skip the point itself
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	85	85	Reset grid pointer to prevent dangling pointers
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	96	96	if a grid is already created - delete and initalize a new one :: instructions
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	102	102	Update the grid dimensions in the object, k, and set exists boolean to true
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	108	108	initalizing 2d dynamic array and setting the values to 0;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	116	117	Explicitly set each element to 0.0\nstd::cout << "*";
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	119	119	std::cout << "" << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	131	131	void Grid::point(char c, int x, int y) {
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	133	147	// if inputted x,y coordinates are out of bounds - print failure msg\nif( x > m || y > n) {\nstd::cout << "failure" << std::endl;\n}else {\nif(c == 'G'){\n// for goals you're always overwriting the current one\nif(x_goal != -1 && y_goal != -1) {\npotential_calculator(1, x_goal, y_goal); // overwriting old goal by adding its potential values back (essentially negating it)\nstd::cout << "success" << std::endl;\n}\n// update new goal values and recalculate potential\nthis -> x_goal = x;\nthis -> y_goal = y;\n// overwrite = true;// this way for the first time it will not run overwrite commands but every time after it will\nthis -> sign = -1;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	149	151	// potential_calculator(sign, x_goal, y_goal);\npotential_calculator(sign, x, y);\nstd::cout << "success" << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	154	159	}else if (c == 'O'){\nthis -> sign = 1;\nif (x == x_goal && y == y_goal){\npotential_calculator(1,x_goal,y_goal); // negate effects due to that goal\n}\n// std::cout << "Obstacle added at (" << x << ", " << y << ")" << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	161	165	potential_calculator(sign, x, y);\nstd::cout << "success" << std::endl;\n}\n}\n}
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	177	177	Check if obstacle already exists at this point
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	199	199	send different k value update in update func
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	201	201	void Grid::potential_calculator(int sign, int x, int y){
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	203	204	// std::cout << k << std::endl;\n// double distance = 0.0;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	206	213	for(int i = 0; i < m; i++){\nfor (int j = 0; j < n; j++){\ndistance = sqrt ((pow(i-x, 2)) + (pow(j-y, 2)));\nif(distance != 0){\ngrid[i][j] +=  (sign*k)/ distance;\n}else { // for cells that are labelled as obstacles/goals set the potential value to 0\ngrid[i][j] = 0.0;\n}
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	215	216	// std::cout << grid[i][j] << " ";\n}
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	218	219	// std::cout << "" << std::endl;\n}
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	221	221	// this -> grid = grid;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	223	223	}
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	226	239	void Grid::potential_calculator(int sign, int x, int y) {\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nif (i == x && j == y) {\n// If this is the location of the goal/obstacle, set potential to 0\ngrid[i][j] = 0;\n} else {\ndouble distance = sqrt(pow(i-x, 2) + pow(j-y, 2));\ndouble potential = sign * k / distance;\ngrid[i][j] += potential;  // Add this potential to existing potential\n}\n}\n}\n}
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	243	245	std::cout << grid[0][0] << std::endl;\nstd::cout << k << std::endl;\nstd::cout << k_new << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	247	247	std::cout << k << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	249	250	for(int i = 0; i < m; i++){\nfor (int j = 0; j < n; j++){
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	252	253	grid[i][j] *= (k_new/k);\n// std::cout << grid[i][j] << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	255	255	}
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	257	257	// std::cout << " " << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	259	259	}
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	261	265	this-> k =  k_new;\nstd::cout << "success" << std::endl;\n// std::cout << "new k: " << k << std::endl;\n// std::cout << grid[0][0] << std::endl;\n// std::cout << k << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	276	276	Check if grid is created and valid
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	278	278	The grid has not been created or has invalid dimensions
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	282	282	Reset all the grid cells to 0.0
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	285	285	Explicitly set each element to 0.0
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	297	298	m = x, n = y\nstd::cout << "debug move" << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	306	307	// Initializing min value with some grid element\nDefault to the current square if there are no neighbors
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.cpp	309	309	Print the minimum value twice
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.h	9	9	dimensions of the grid
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.h	12	12	potential variable
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.h	22	26	\nconstructor\ndestructor
bd6d2784	f24	p0	2024-09-23 13:34:58	Grid.h	32	32	create function
bd6d2784	f24	p0	2024-09-23 13:34:58	main.cpp	9	12	for tracking the rows and cols of the grid\nfor tracking the inputted x and y params for various funcs\neither an obstacle or goal\ncreate instance of grid class
bd6d2784	f24	p0	2024-09-23 13:34:58	main.cpp	19	22	std::cout << "debug 1" << std::endl;\nread parameter svalues\ncreate new grid with inputted parameters\ncan i access m and n above throughout the code? // do i make it a pointer
bd6d2784	f24	p0	2024-09-23 13:34:58	main.cpp	26	26	std::cout << "debug 2" << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	main.cpp	37	37	std::cout << "debug 4" << std::endl;
bd6d2784	f24	p0	2024-09-23 13:34:58	main.cpp	46	46	std::cout << "debug 5" << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	39	39	Reset grid to zero
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	46	46	Add goal potential
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	51	51	Add obstacle potentials
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	62	62	Skip the point itself
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	85	85	Reset grid pointer to prevent dangling pointers
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	96	96	if a grid is already created - delete and initalize a new one :: instructions
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	102	102	Update the grid dimensions in the object, k, and set exists boolean to true
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	108	108	initalizing 2d dynamic array and setting the values to 0;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	116	117	Explicitly set each element to 0.0\nstd::cout << "*";
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	119	119	std::cout << "" << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	131	131	void Grid::point(char c, int x, int y) {
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	133	147	// if inputted x,y coordinates are out of bounds - print failure msg\nif( x > m || y > n) {\nstd::cout << "failure" << std::endl;\n}else {\nif(c == 'G'){\n// for goals you're always overwriting the current one\nif(x_goal != -1 && y_goal != -1) {\npotential_calculator(1, x_goal, y_goal); // overwriting old goal by adding its potential values back (essentially negating it)\nstd::cout << "success" << std::endl;\n}\n// update new goal values and recalculate potential\nthis -> x_goal = x;\nthis -> y_goal = y;\n// overwrite = true;// this way for the first time it will not run overwrite commands but every time after it will\nthis -> sign = -1;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	149	151	// potential_calculator(sign, x_goal, y_goal);\npotential_calculator(sign, x, y);\nstd::cout << "success" << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	154	159	}else if (c == 'O'){\nthis -> sign = 1;\nif (x == x_goal && y == y_goal){\npotential_calculator(1,x_goal,y_goal); // negate effects due to that goal\n}\n// std::cout << "Obstacle added at (" << x << ", " << y << ")" << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	161	165	potential_calculator(sign, x, y);\nstd::cout << "success" << std::endl;\n}\n}\n}
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	177	177	Check if obstacle already exists at this point
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	199	199	send different k value update in update func
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	201	201	void Grid::potential_calculator(int sign, int x, int y){
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	203	204	// std::cout << k << std::endl;\n// double distance = 0.0;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	206	213	for(int i = 0; i < m; i++){\nfor (int j = 0; j < n; j++){\ndistance = sqrt ((pow(i-x, 2)) + (pow(j-y, 2)));\nif(distance != 0){\ngrid[i][j] +=  (sign*k)/ distance;\n}else { // for cells that are labelled as obstacles/goals set the potential value to 0\ngrid[i][j] = 0.0;\n}
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	215	216	// std::cout << grid[i][j] << " ";\n}
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	218	219	// std::cout << "" << std::endl;\n}
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	221	221	// this -> grid = grid;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	223	223	}
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	226	239	void Grid::potential_calculator(int sign, int x, int y) {\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nif (i == x && j == y) {\n// If this is the location of the goal/obstacle, set potential to 0\ngrid[i][j] = 0;\n} else {\ndouble distance = sqrt(pow(i-x, 2) + pow(j-y, 2));\ndouble potential = sign * k / distance;\ngrid[i][j] += potential;  // Add this potential to existing potential\n}\n}\n}\n}
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	243	245	std::cout << grid[0][0] << std::endl;\nstd::cout << k << std::endl;\nstd::cout << k_new << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	247	247	std::cout << k << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	249	250	for(int i = 0; i < m; i++){\nfor (int j = 0; j < n; j++){
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	252	253	grid[i][j] *= (k_new/k);\n// std::cout << grid[i][j] << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	255	255	}
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	257	257	// std::cout << " " << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	259	259	}
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	261	265	this-> k =  k_new;\nstd::cout << "success" << std::endl;\n// std::cout << "new k: " << k << std::endl;\n// std::cout << grid[0][0] << std::endl;\n// std::cout << k << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	276	276	Check if grid is created and valid
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	278	278	The grid has not been created or has invalid dimensions
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	282	282	Reset all the grid cells to 0.0
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	285	285	Explicitly set each element to 0.0
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	297	298	m = x, n = y\nstd::cout << "debug move" << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	306	307	// Initializing min value with some grid element\nDefault to the current square if there are no neighbors
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.cpp	309	309	Print the minimum value twice
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.h	9	9	dimensions of the grid
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.h	12	12	potential variable
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.h	22	26	\nconstructor\ndestructor
bd6d2784	f24	p0	2024-09-23 19:53:41	Grid.h	32	32	create function
bd6d2784	f24	p0	2024-09-23 19:53:41	main.cpp	9	12	for tracking the rows and cols of the grid\nfor tracking the inputted x and y params for various funcs\neither an obstacle or goal\ncreate instance of grid class
bd6d2784	f24	p0	2024-09-23 19:53:41	main.cpp	19	22	std::cout << "debug 1" << std::endl;\nread parameter svalues\ncreate new grid with inputted parameters\ncan i access m and n above throughout the code? // do i make it a pointer
bd6d2784	f24	p0	2024-09-23 19:53:41	main.cpp	26	26	std::cout << "debug 2" << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	main.cpp	37	37	std::cout << "debug 4" << std::endl;
bd6d2784	f24	p0	2024-09-23 19:53:41	main.cpp	46	46	std::cout << "debug 5" << std::endl;
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	16	16	arbitrary value to start with
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	20	20	arbitrary value to start with
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	34	35	increase capacity (doubling)\ncreate  memory
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	38	38	copying old array to avoid losing data
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	41	41	avoiding memory leads
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	43	43	point to new arrays created
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	49	49	same thing as for goals but for obstacles
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	51	51	creating new array - deleting old memory - pointing to new array
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	68	68	recalculating potentials
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	86	86	potential formula
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	100	100	calling member function
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	105	106	basically deleting everything\nnote: apparantly you cant call the destructor function within your code - why is it there then
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	114	114	Reset grid pointer to prevent dangling pointers
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	118	118	freeing up all the memory - avoid leaks
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	132	132	if a grid is already created - delete and initalize a new one :: instructions
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	134	134	if there is already a grid delete it and make a new one
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	138	138	Update the grid dimensions in the object, k, and set exists boolean to true
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	141	141	std::cout << m << " " << n << std::endl; // debug statement
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	145	145	initalizing 2d dynamic array and setting the values to 0;
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	153	154	set each element to 0.0\nstd::cout << "*";
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	156	156	std::cout << "" << std::endl;
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	186	186	for goal
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	188	188	make array bigger to store
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	193	193	for obstacle
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	207	209	k = k_new;\nrecalculateGrid();\nstd::cout << "success" << std::endl;
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	211	211	instead of recalculating the whole grid you can do factor method to cancel out the previous constant
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	217	217	changing the old constant to new constant
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	225	225	Check if grid is created and valid
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	227	227	failure case - out of bounds
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	231	231	Reset all the grid cells to 0.0
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	234	234	setting to zero - required in instructions
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.cpp	245	246	m = x, n = y\nstd::cout << "debug move" << std::endl;
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.h	1	1	Grid.h
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.h	7	8	for the map\nfor robot's map
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.h	10	10	x and y dimensions of map
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.h	13	13	constant for potential formula
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.h	15	16	using this to check if the grid exists or not (for create you wanna clear the old one before creating a new)\nto store x,y coordinates for goal
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.h	18	20	number of goals in the goal array\ncapacity of goal array (different from goal count)\nvars below are same function as goals vars above but for obstacles
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.h	25	30	these are all my helper functions - why do i have so many\nresizing grid that stores obstacle coordinates\nsame thing as above but for goals\n- resetting all values first then changing potnetial values for entire grid\ncalculating potential values at a single point to grid\ndeleting
bd6d2784	f24	p0	2024-09-23 21:58:00	Grid.h	36	36	assignment required functions
bd6d2784	f24	p0	2024-09-23 21:58:00	main.cpp	9	12	for tracking the rows and cols of the grid\nfor tracking the inputted x and y params for various funcs\neither an obstacle or goal\ncreate instance of grid class
bd6d2784	f24	p0	2024-09-23 21:58:00	main.cpp	19	22	std::cout << "debug 1" << std::endl;\nread parameter svalues\ncreate new grid with inputted parameters\ncan i access m and n above throughout the code? // do i make it a pointer
bd6d2784	f24	p0	2024-09-23 21:58:00	main.cpp	26	26	std::cout << "debug 2" << std::endl;
bd6d2784	f24	p0	2024-09-23 21:58:00	main.cpp	37	37	std::cout << "debug 4" << std::endl;
bd6d2784	f24	p0	2024-09-23 21:58:00	main.cpp	46	46	std::cout << "debug 5" << std::endl;
be2eef02	f24	p0	2024-09-17 13:44:16	project0.cpp	44	46	if (distance == 0) {\ndistance = 1e-10;\n}
be2eef02	f24	p0	2024-09-17 13:44:16	project0.cpp	129	129	i should delete the field instance after
be2eef02	f24	p0	2024-09-17 13:46:23	project0.cpp	44	46	if (distance == 0) {\ndistance = 1e-10;\n}
be2eef02	f24	p0	2024-09-17 13:46:23	project0.cpp	129	129	i should delete the field instance after
be2eef02	f24	p0	2024-09-17 16:12:42	project0.cpp	5	5	! N Columns, M row
bed195a7	f24	p0	2024-09-22 15:11:14	main.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:11:14	main.cpp	10	10	Contains the Node and Map classes
bed195a7	f24	p0	2024-09-22 15:11:14	main.cpp	14	14	Temporary storage variables for user input
bed195a7	f24	p0	2024-09-22 15:11:14	main.cpp	44	44	For invalid commands
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	10	10	Map class definition & comments
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	25	25	If existing board, clear it; can't use clear command as it will print "success"
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	34	34	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	39	39	Add the first object as head
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	44	44	Add any other object to the end of the list
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	48	48	If object already exists at the position, update it; don't continue
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	63	63	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	68	68	Calculate the vector at the given position by going through every object and using superposition
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	72	72	If object is at the position, skip it; object has 0 effect at that position
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	77	77	Coefficient of the calculation depends on the object type
bed195a7	f24	p0	2024-09-22 15:11:14	map.cpp	86	86	Clear, ensure that the board is not empty
bed195a7	f24	p0	2024-09-22 15:11:14	map.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:11:14	map.hpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:11:14	map.hpp	68	69	Number of columns in the map\nNumber of rows in the map
bed195a7	f24	p0	2024-09-22 15:11:14	map.hpp	71	72	K constant for calculations\nHead of the linked list of objects
bed195a7	f24	p0	2024-09-22 15:11:14	node.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:11:14	node.cpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:11:14	node.cpp	17	17	Return different coefficients for vector calculations based on object type
bed195a7	f24	p0	2024-09-22 15:11:14	node.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:11:14	node.hpp	41	42	Next node\nObject type: 'G' for Goal, 'O' for Obstacle
bed195a7	f24	p0	2024-09-22 15:11:14	node.hpp	45	46	X-coordinate of the node\nY-coordinate of the node
bed195a7	f24	p0	2024-09-22 15:35:47	main.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:35:47	main.cpp	10	10	Contains the Node and Map classes
bed195a7	f24	p0	2024-09-22 15:35:47	main.cpp	14	14	Temporary storage variables for user input
bed195a7	f24	p0	2024-09-22 15:35:47	main.cpp	44	44	For invalid commands
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	10	10	Map class definition & comments
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	25	25	If existing board, clear it; can't use clear command as it will print "success"
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	34	34	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	39	39	Add the first object as head
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	44	44	Add any other object to the end of the list
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	48	48	If object already exists at the position, update it; don't continue
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	63	63	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	68	68	Calculate the vector at the given position by going through every object and using superposition
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	72	72	If object is at the position, skip it; object has 0 effect at that position
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	77	77	Coefficient of the calculation depends on the object type
bed195a7	f24	p0	2024-09-22 15:35:47	map.cpp	86	86	Clear, ensure that the board is not empty
bed195a7	f24	p0	2024-09-22 15:35:47	map.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:35:47	map.hpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:35:47	map.hpp	68	69	Number of columns in the map\nNumber of rows in the map
bed195a7	f24	p0	2024-09-22 15:35:47	map.hpp	71	72	K constant for calculations\nHead of the linked list of objects
bed195a7	f24	p0	2024-09-22 15:35:47	node.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:35:47	node.cpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:35:47	node.cpp	17	17	Return different coefficients for vector calculations based on object type
bed195a7	f24	p0	2024-09-22 15:35:47	node.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:35:47	node.hpp	41	42	Next node\nObject type: 'G' for Goal, 'O' for Obstacle
bed195a7	f24	p0	2024-09-22 15:35:47	node.hpp	45	46	X-coordinate of the node\nY-coordinate of the node
bed195a7	f24	p0	2024-09-22 15:37:10	main.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:37:10	main.cpp	10	10	Contains the Node and Map classes
bed195a7	f24	p0	2024-09-22 15:37:10	main.cpp	14	14	Temporary storage variables for user input
bed195a7	f24	p0	2024-09-22 15:37:10	main.cpp	44	44	For invalid commands
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	10	10	Map class definition & comments
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	25	25	If existing board, clear it; can't use clear command as it will print "success"
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	34	34	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	39	39	Add the first object as head
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	44	44	Add any other object to the end of the list
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	48	48	If object already exists at the position, update it; don't continue
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	63	63	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	68	68	Calculate the vector at the given position by going through every object and using superposition
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	72	72	If object is at the position, skip it; object has 0 effect at that position
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	77	77	Coefficient of the calculation depends on the object type
bed195a7	f24	p0	2024-09-22 15:37:10	map.cpp	86	86	Clear, ensure that the board is not empty
bed195a7	f24	p0	2024-09-22 15:37:10	map.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:37:10	map.hpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:37:10	map.hpp	68	69	Number of columns in the map\nNumber of rows in the map
bed195a7	f24	p0	2024-09-22 15:37:10	map.hpp	71	72	K constant for calculations\nHead of the linked list of objects
bed195a7	f24	p0	2024-09-22 15:37:10	node.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:37:10	node.cpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:37:10	node.cpp	17	17	Return different coefficients for vector calculations based on object type
bed195a7	f24	p0	2024-09-22 15:37:10	node.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:37:10	node.hpp	41	42	Next node\nObject type: 'G' for Goal, 'O' for Obstacle
bed195a7	f24	p0	2024-09-22 15:37:10	node.hpp	45	46	X-coordinate of the node\nY-coordinate of the node
bed195a7	f24	p0	2024-09-22 15:40:20	main.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:40:20	main.cpp	10	10	Contains the Node and Map classes
bed195a7	f24	p0	2024-09-22 15:40:20	main.cpp	14	14	Temporary storage variables for user input
bed195a7	f24	p0	2024-09-22 15:40:20	main.cpp	44	44	For invalid commands
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	10	10	Map class definition & comments
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	25	25	If existing board, clear it; can't use clear command as it will print "success"
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	34	34	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	39	39	Add the first object as head
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	44	44	Add any other object to the end of the list
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	48	48	If object already exists at the position, update it; don't continue
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	63	63	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	68	68	Calculate the vector at the given position by going through every object and using superposition
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	72	72	If object is at the position, skip it; object has 0 effect at that position
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	77	77	Coefficient of the calculation depends on the object type
bed195a7	f24	p0	2024-09-22 15:40:20	map.cpp	86	86	Clear, ensure that the board is not empty
bed195a7	f24	p0	2024-09-22 15:40:20	map.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:40:20	map.hpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:40:20	map.hpp	68	69	Number of columns in the map\nNumber of rows in the map
bed195a7	f24	p0	2024-09-22 15:40:20	map.hpp	71	72	K constant for calculations\nHead of the linked list of objects
bed195a7	f24	p0	2024-09-22 15:40:20	node.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:40:20	node.cpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:40:20	node.cpp	17	17	Return different coefficients for vector calculations based on object type
bed195a7	f24	p0	2024-09-22 15:40:20	node.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:40:20	node.hpp	41	42	Next node\nObject type: 'G' for Goal, 'O' for Obstacle
bed195a7	f24	p0	2024-09-22 15:40:20	node.hpp	45	46	X-coordinate of the node\nY-coordinate of the node
bed195a7	f24	p0	2024-09-22 15:43:52	main.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:43:52	main.cpp	10	10	Contains the Node and Map classes
bed195a7	f24	p0	2024-09-22 15:43:52	main.cpp	14	14	Temporary storage variables for user input
bed195a7	f24	p0	2024-09-22 15:43:52	main.cpp	44	44	For invalid commands
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	10	10	Map class definition & comments
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	25	25	If existing board, clear it; can't use clear command as it will print "success"
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	34	34	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	39	39	Add the first object as head
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	44	44	Add any other object to the end of the list
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	48	48	If object already exists at the position, update it; don't continue
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	63	63	Bound checking the input
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	68	68	Calculate the vector at the given position by going through every object and using superposition
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	72	72	If object is at the position, skip it; object has 0 effect at that position
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	77	77	Coefficient of the calculation depends on the object type
bed195a7	f24	p0	2024-09-22 15:43:52	map.cpp	86	86	Clear, ensure that the board is not empty
bed195a7	f24	p0	2024-09-22 15:43:52	map.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:43:52	map.hpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:43:52	map.hpp	68	69	Number of columns in the map\nNumber of rows in the map
bed195a7	f24	p0	2024-09-22 15:43:52	map.hpp	71	72	K constant for calculations\nHead of the linked list of objects
bed195a7	f24	p0	2024-09-22 15:43:52	node.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:43:52	node.cpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 15:43:52	node.cpp	17	17	Return different coefficients for vector calculations based on object type
bed195a7	f24	p0	2024-09-22 15:43:52	node.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 15:43:52	node.hpp	41	42	Next node\nObject type: 'G' for Goal, 'O' for Obstacle
bed195a7	f24	p0	2024-09-22 15:43:52	node.hpp	45	46	X-coordinate of the node\nY-coordinate of the node
bed195a7	f24	p0	2024-09-22 19:05:05	main.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 19:05:05	main.cpp	10	10	Contains the Node and Map classes
bed195a7	f24	p0	2024-09-22 19:05:05	main.cpp	14	14	Temporary storage variables for user input
bed195a7	f24	p0	2024-09-22 19:05:05	main.cpp	44	44	For invalid commands
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	10	10	Map class definition & comments
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	25	25	If existing board, clear it; can't use clear command as it will print "success"
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	34	34	Bound checking the input
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	39	39	Add the first object as head
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	44	44	Add any other object to the end of the list
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	48	48	If object already exists at the position, update it; don't continue
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	63	63	Bound checking the input
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	68	68	Calculate the vector at the given position by going through every object and using superposition
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	72	72	If object is at the position, skip it; object has 0 effect at that position
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	77	77	Coefficient of the calculation depends on the object type
bed195a7	f24	p0	2024-09-22 19:05:05	map.cpp	86	86	Clear, ensure that the board is not empty
bed195a7	f24	p0	2024-09-22 19:05:05	map.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 19:05:05	map.hpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 19:05:05	map.hpp	68	69	Number of columns in the map\nNumber of rows in the map
bed195a7	f24	p0	2024-09-22 19:05:05	map.hpp	71	72	K constant for calculations\nHead of the linked list of objects
bed195a7	f24	p0	2024-09-22 19:05:05	node.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 19:05:05	node.cpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 19:05:05	node.cpp	17	17	Return different coefficients for vector calculations based on object type
bed195a7	f24	p0	2024-09-22 19:05:05	node.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 19:05:05	node.hpp	41	42	Next node\nObject type: 'G' for Goal, 'O' for Obstacle
bed195a7	f24	p0	2024-09-22 19:05:05	node.hpp	45	46	X-coordinate of the node\nY-coordinate of the node
bed195a7	f24	p0	2024-09-22 23:00:51	main.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 23:00:51	main.cpp	10	10	Contains the Node and Map classes
bed195a7	f24	p0	2024-09-22 23:00:51	main.cpp	14	14	Temporary storage variables for user input
bed195a7	f24	p0	2024-09-22 23:00:51	main.cpp	44	44	For invalid commands
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	10	10	Map class definition & comments
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	25	25	If existing board, clear it; can't use clear command as it will print "success"
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	34	34	Bound checking the input
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	39	39	Add the first object as head
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	44	44	Add any other object to the end of the list
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	48	48	If object already exists at the position, update it; don't continue
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	63	63	Bound checking the input
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	68	68	Calculate the vector at the given position by going through every object and using superposition
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	72	72	If object is at the position, skip it; object has 0 effect at that position
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	77	77	Coefficient of the calculation depends on the object type
bed195a7	f24	p0	2024-09-22 23:00:51	map.cpp	86	86	Clear, ensure that the board is not empty
bed195a7	f24	p0	2024-09-22 23:00:51	map.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 23:00:51	map.hpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 23:00:51	map.hpp	68	69	Number of columns in the map\nNumber of rows in the map
bed195a7	f24	p0	2024-09-22 23:00:51	map.hpp	71	72	K constant for calculations\nHead of the linked list of objects
bed195a7	f24	p0	2024-09-22 23:00:51	node.cpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 23:00:51	node.cpp	6	6	Node class definition & comments
bed195a7	f24	p0	2024-09-22 23:00:51	node.cpp	17	17	Return different coefficients for vector calculations based on object type
bed195a7	f24	p0	2024-09-22 23:00:51	node.hpp	1	4	ECE250 Project 0\nAuthor: Krish Patel\nProfessor: Ladan Tahvildari\nSeptember 23, 2024
bed195a7	f24	p0	2024-09-22 23:00:51	node.hpp	41	42	Next node\nObject type: 'G' for Goal, 'O' for Obstacle
bed195a7	f24	p0	2024-09-22 23:00:51	node.hpp	45	46	X-coordinate of the node\nY-coordinate of the node
bfb66a64	f24	p0	2024-09-19 03:02:56	grid.cpp	51	51	disallow any other operations
bfb66a64	f24	p0	2024-09-19 03:02:56	grid.cpp	61	61	obstacle = positive
bfb66a64	f24	p0	2024-09-19 03:02:56	grid.cpp	63	64	storing in terms of x + y\nhashed 1D positions by z = columns*x + y, because each row has column values, and we need to jump x rows
bfb66a64	f24	p0	2024-09-19 03:02:56	grid.h	15	15	calculate potentials from a point
bfb66a64	f24	p0	2024-09-19 03:02:56	grid.h	19	19	obstacles or goals
bfb66a64	f24	p0	2024-09-19 03:02:56	grid.h	23	23	k can be a decimal number
bfb66a64	f24	p0	2024-09-19 03:02:56	main.cpp	3	3	Grid already exists with including grid.h. Now the programmer can just modify / move seamlessly
bfb66a64	f24	p0	2024-09-19 03:02:56	main.cpp	19	19	if Goal, mul = 1. if Obstacle, mul = -1
bfb66a64	f24	p0	2024-09-22 15:13:06	grid.cpp	8	8	avoid reallocation
bfb66a64	f24	p0	2024-09-22 15:13:06	grid.cpp	20	20	initializes to nullptr for safety
bfb66a64	f24	p0	2024-09-22 15:13:06	grid.cpp	35	35	disallow any other operations
bfb66a64	f24	p0	2024-09-22 15:13:06	grid.cpp	76	76	obstacle = positive
bfb66a64	f24	p0	2024-09-22 15:13:06	grid.cpp	78	79	storing in terms of x + y\nhashed 1D positions by z = columns*x + y, because each row has column values, and we need to jump x rows
bfb66a64	f24	p0	2024-09-22 15:13:06	grid.cpp	94	94	reverse hash
bfb66a64	f24	p0	2024-09-22 15:13:06	grid.h	15	15	calculate potentials from a point
bfb66a64	f24	p0	2024-09-22 15:13:06	grid.h	19	20	hashed 2d grid to 1d array, can inverse the hasher to get (x, y) from an index\nobstacles or goals - simply stores multiplier to potential (-1 or 1)
bfb66a64	f24	p0	2024-09-22 15:13:06	grid.h	24	24	k can be a decimal number
bfb66a64	f24	p0	2024-09-22 15:13:06	main.cpp	3	3	Grid already exists with including grid.h. Now the programmer can just modify / move seamlessly
bfb66a64	f24	p0	2024-09-22 15:13:06	main.cpp	19	19	if Goal, mul = 1. if Obstacle, mul = -1
bfb66a64	f24	p0	2024-09-22 16:41:59	grid.cpp	8	8	avoid reallocation
bfb66a64	f24	p0	2024-09-22 16:41:59	grid.cpp	20	20	initializes to nullptr for safety
bfb66a64	f24	p0	2024-09-22 16:41:59	grid.cpp	35	35	disallow any other operations
bfb66a64	f24	p0	2024-09-22 16:41:59	grid.cpp	76	76	obstacle = positive
bfb66a64	f24	p0	2024-09-22 16:41:59	grid.cpp	78	79	storing in terms of x + y\nhashed 1D positions by z = columns*x + y, because each row has column values, and we need to jump x rows
bfb66a64	f24	p0	2024-09-22 16:41:59	grid.cpp	94	94	reverse hash
bfb66a64	f24	p0	2024-09-22 16:41:59	grid.h	15	15	calculate potentials from a point
bfb66a64	f24	p0	2024-09-22 16:41:59	grid.h	19	20	hashed 2d grid to 1d array, can inverse the hasher to get (x, y) from an index\nobstacles or goals - simply stores multiplier to potential (-1 or 1)
bfb66a64	f24	p0	2024-09-22 16:41:59	grid.h	24	24	k can be a decimal number
bfb66a64	f24	p0	2024-09-22 16:41:59	main.cpp	3	3	Grid already exists with including grid.h. Now the programmer can just modify / move seamlessly
bfb66a64	f24	p0	2024-09-22 16:41:59	main.cpp	19	19	if Goal, mul = 1. if Obstacle, mul = -1
bfb66a64	f24	p0	2024-09-23 09:19:10	grid.cpp	8	8	avoid reallocation
bfb66a64	f24	p0	2024-09-23 09:19:10	grid.cpp	20	20	initializes to nullptr for safety
bfb66a64	f24	p0	2024-09-23 09:19:10	grid.cpp	35	35	disallow any other operations
bfb66a64	f24	p0	2024-09-23 09:19:10	grid.cpp	76	76	obstacle = positive
bfb66a64	f24	p0	2024-09-23 09:19:10	grid.cpp	78	79	storing in terms of x + y\nhashed 1D positions by z = columns*x + y, because each row has column values, and we need to jump x rows
bfb66a64	f24	p0	2024-09-23 09:19:10	grid.cpp	94	94	reverse hash
bfb66a64	f24	p0	2024-09-23 09:19:10	grid.h	15	15	calculate potentials from a point
bfb66a64	f24	p0	2024-09-23 09:19:10	grid.h	19	20	hashed 2d grid to 1d array, can inverse the hasher to get (x, y) from an index\nobstacles or goals - simply stores multiplier to potential (-1 or 1)
bfb66a64	f24	p0	2024-09-23 09:19:10	grid.h	24	24	k can be a decimal number
bfb66a64	f24	p0	2024-09-23 09:19:10	main.cpp	3	3	Grid already exists with including grid.h. Now the programmer can just modify / move seamlessly
bfb66a64	f24	p0	2024-09-23 09:19:10	main.cpp	19	19	if Goal, mul = 1. if Obstacle, mul = -1
bfb66a64	f24	p0	2024-09-23 21:13:37	grid.cpp	8	8	avoid reallocation
bfb66a64	f24	p0	2024-09-23 21:13:37	grid.cpp	20	20	initializes to nullptr for safety
bfb66a64	f24	p0	2024-09-23 21:13:37	grid.cpp	35	35	disallow any other operations
bfb66a64	f24	p0	2024-09-23 21:13:37	grid.cpp	76	76	obstacle = positive
bfb66a64	f24	p0	2024-09-23 21:13:37	grid.cpp	78	79	storing in terms of x + y\nhashed 1D positions by z = columns*x + y, because each row has column values, and we need to jump x rows
bfb66a64	f24	p0	2024-09-23 21:13:37	grid.cpp	94	94	reverse hash
bfb66a64	f24	p0	2024-09-23 21:13:37	grid.h	15	15	calculate potentials from a point
bfb66a64	f24	p0	2024-09-23 21:13:37	grid.h	19	20	hashed 2d grid to 1d array, can inverse the hasher to get (x, y) from an index\nobstacles or goals - simply stores multiplier to potential (-1 or 1)
bfb66a64	f24	p0	2024-09-23 21:13:37	grid.h	24	24	k can be a decimal number
bfb66a64	f24	p0	2024-09-23 21:13:37	main.cpp	3	3	Grid already exists with including grid.h. Now the programmer can just modify / move seamlessly
bfb66a64	f24	p0	2024-09-23 21:13:37	main.cpp	19	19	if Goal, mul = 1. if Obstacle, mul = -1
bfb66a64	f24	p0	2024-09-23 21:50:49	grid.cpp	8	8	avoid reallocation
bfb66a64	f24	p0	2024-09-23 21:50:49	grid.cpp	20	20	initializes to nullptr for safety
bfb66a64	f24	p0	2024-09-23 21:50:49	grid.cpp	35	35	disallow any other operations
bfb66a64	f24	p0	2024-09-23 21:50:49	grid.cpp	76	76	obstacle = positive
bfb66a64	f24	p0	2024-09-23 21:50:49	grid.cpp	78	79	storing in terms of x + y\nhashed 1D positions by z = columns*x + y, because each row has column values, and we need to jump x rows
bfb66a64	f24	p0	2024-09-23 21:50:49	grid.cpp	94	94	reverse hash
bfb66a64	f24	p0	2024-09-23 21:50:49	grid.h	15	15	calculate potentials from a point
bfb66a64	f24	p0	2024-09-23 21:50:49	grid.h	19	20	hashed 2d grid to 1d array, can inverse the hasher to get (x, y) from an index\nobstacles or goals - simply stores multiplier to potential (-1 or 1)
bfb66a64	f24	p0	2024-09-23 21:50:49	grid.h	24	24	k can be a decimal number
bfb66a64	f24	p0	2024-09-23 21:50:49	main.cpp	3	3	Grid already exists with including grid.h. Now the programmer can just modify / move seamlessly
bfb66a64	f24	p0	2024-09-23 21:50:49	main.cpp	19	19	if Goal, mul = 1. if Obstacle, mul = -1
c331ab08	f24	p0	2024-09-17 19:50:14	main.cpp	7	7	If-elses to interpret commands
c331ab08	f24	p0	2024-09-17 19:50:14	main.cpp	42	42	Array to store command + parameters, size 4 since longest command is point + 3 params
c331ab08	f24	p0	2024-09-17 19:50:14	main.cpp	47	47	Separate input line into strings separated by whitespace, store in words array
c331ab08	f24	p0	2024-09-17 19:50:14	my_map.cpp	19	19	Initialize dimensions with given values
c331ab08	f24	p0	2024-09-17 19:50:14	my_map.cpp	23	23	Dynamically allocate 2d array
c331ab08	f24	p0	2024-09-17 19:50:14	my_map.cpp	29	29	K should be 1 by default
c331ab08	f24	p0	2024-09-17 19:50:14	my_map.cpp	47	47	Flag to multiply calculation depending on if point is goal or obstacle
c331ab08	f24	p0	2024-09-17 19:50:14	my_map.h	13	13	Member functions to execute input commands
c331ab08	f24	p0	2024-09-17 19:50:14	my_map.h	21	21	Member variables/array
c331ab08	f24	p0	2024-09-17 19:50:14	my_map.h	26	26	Function to calculate potential, used by other functions
c331ab08	f24	p0	2024-09-18 21:33:42	main.cpp	7	7	If-elses to interpret commands
c331ab08	f24	p0	2024-09-18 21:33:42	main.cpp	42	42	Array to store command + parameters, size 4 since longest command is point + 3 params
c331ab08	f24	p0	2024-09-18 21:33:42	main.cpp	47	47	Separate input line into strings separated by whitespace, store in words array
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	12	12	Delete existing map if it exists
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	23	23	Initialize dimensions with given values
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	27	27	Dynamically allocate 2d array
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	36	36	K should be 1 by default
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	45	45	Perform potential calculation given coordinates and point location
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	56	56	Flag to multiply calculation depending on if point is goal or obstacle
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	59	59	map[x][y][1] = 0 if there's no point, 1 if obstacle, -1 if goal
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	61	61	If there exists the same type of point, nothing changes
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	65	65	If there's the opposite point, the potential changes twice as much (remove existing, add opposite)
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	70	70	Calculate potential change for each cell
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	85	85	Check bounds
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	90	90	X and Y potential is always the same, so stored potential value is used twice
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	114	114	All potentials are added as a factor of constant k, multiplying by ratio updates to new k
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.cpp	127	127	Delete dynamically allocated memory
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.h	12	12	Member functions to execute input commands
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.h	20	20	Member variables/array
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.h	24	25	3d Array to store potential and point info at each cell\nmap[x][y][0] stores potential, map[x][y][1] stores if there's existing point
c331ab08	f24	p0	2024-09-18 21:33:42	my_map.h	28	28	Function to calculate potential, used by other functions
c331ab08	f24	p0	2024-09-18 22:14:12	main.cpp	7	7	If-elses to interpret commands
c331ab08	f24	p0	2024-09-18 22:14:12	main.cpp	42	42	Array to store command + parameters, size 4 since longest command is point + 3 params
c331ab08	f24	p0	2024-09-18 22:14:12	main.cpp	47	47	Separate input line into strings separated by whitespace, store in words array
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	12	12	Delete existing map if it exists
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	23	23	Initialize dimensions with given values
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	27	27	Dynamically allocate 2d array
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	36	36	K should be 1 by default
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	45	45	Perform potential calculation given coordinates and point location
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	56	56	Flag to multiply calculation depending on if point is goal or obstacle
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	59	59	map[x][y][1] = 0 if there's no point, 1 if obstacle, -1 if goal
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	61	61	If there exists the same type of point, nothing changes
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	65	65	If there's the opposite point, the potential changes twice as much (remove existing, add opposite)
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	70	70	Calculate potential change for each cell
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	85	85	Check bounds
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	90	90	X and Y potential is always the same, so stored potential value is used twice
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	115	115	All potentials are added as a factor of constant k, multiplying by ratio updates to new k
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.cpp	128	128	Delete dynamically allocated memory
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.h	12	12	Member functions to execute input commands
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.h	20	20	Member variables/array
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.h	24	25	3d Array to store potential and point info at each cell\nmap[x][y][0] stores potential, map[x][y][1] stores if there's existing point
c331ab08	f24	p0	2024-09-18 22:14:12	my_map.h	28	28	Function to calculate potential, used by other functions
c331ab08	f24	p0	2024-09-18 23:55:38	main.cpp	7	7	If-elses to interpret commands
c331ab08	f24	p0	2024-09-18 23:55:38	main.cpp	41	41	Array to store command + parameters, size 4 since longest command is point + 3 params
c331ab08	f24	p0	2024-09-18 23:55:38	main.cpp	46	46	Separate input line into strings separated by whitespace, store in words array
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	12	12	Delete existing map if it exists
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	24	24	Initialize dimensions with given values
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	28	28	Dynamically allocate 2d array
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	37	37	K should be 1 by default
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	46	46	Perform potential calculation given coordinates and point location
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	57	57	Flag to multiply calculation depending on if point is goal or obstacle
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	60	60	map[x][y][1] = 0 if there's no point, 1 if obstacle, -1 if goal
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	62	62	If there exists the same type of point, nothing changes
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	66	66	If there's the opposite point, the potential changes twice as much (remove existing, add opposite)
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	71	71	Calculate potential change for each cell
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	86	86	Check bounds
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	91	91	X and Y potential is always the same, so stored potential value is used twice
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	116	116	All potentials are added as a factor of constant k, multiplying by ratio updates to new k
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.cpp	129	129	Delete dynamically allocated memory
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.h	12	12	Member functions to execute input commands
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.h	20	20	Member variables/array
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.h	24	25	3d Array to store potential and point info at each cell\nmap[x][y][0] stores potential, map[x][y][1] stores if there's existing point
c331ab08	f24	p0	2024-09-18 23:55:38	my_map.h	28	28	Function to calculate potential, used by other functions
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	1	4	#include <iostream>\n#include "potFieldNav.hpp"\n#include <cmath>\nusing namespace std;
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	6	22	//Constructor\nPot_field_nav::Pot_field_nav(unsigned int X, unsigned int Y, unsigned int K)\n{\nx_loc = X;\ny_loc = Y;\nk_size = K;\nrow = X;\ncol = Y;\narr_pot_field = NULL;\np_next = NULL;\ngoalCount = 0;\nobstacleCount = 0;\ngoalX = new unsigned int[x_loc * y_loc];\ngoalY = new unsigned int[x_loc * y_loc];\nobstacleX = new unsigned int [x_loc * y_loc];\nobstacleY = new unsigned int [x_loc*y_loc];\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	24	26	Pot_field_nav::~Pot_field_nav(){\nclear();\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	28	32	//Member functions value\nvoid Pot_field_nav::create(unsigned int X, unsigned int Y)\n{\n//if created map exists\nclear();
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	34	36	row = X;\ncol = Y;\nk_val = 1;
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	38	44	arr_pot_field = new unsigned int * [row];\nfor (unsigned int i = 0; i < row; ++i)\n{\narr_pot_field[i] = new unsigned int [col];\n}\ncout << "success" <<endl;\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	46	68	void Pot_field_nav::point(char T, unsigned int X, unsigned int Y) {\n// Check if the position is within bounds\nif (X < row && Y < col) {\nif (T == 'G') {\narr_pot_field[X][Y] = 0; // Set potential at goal location to 0\ngoalX[goalCount] = X; // Store the goal's X coordinate\ngoalY[goalCount] = Y; // Store the goal's Y coordinate\ngoalCount++;\ncomputePotentials();\nstd::cout << "success" << std::endl;\n} else if (T == 'O') {\narr_pot_field[X][Y] = 0; // Set potential at obstacle location to 0\nobstacleX[obstacleCount] = X; // Store the obstacle's X coordinate\nobstacleY[obstacleCount] = Y; // Store the obstacle's Y coordinate\nobstacleCount++;\ncomputePotentials();\nstd::cout << "success" << std::endl;\n}\n}\nelse {\nstd::cout << "failure" << std::endl; // If out of bounds\n}\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	71	81	void Pot_field_nav::clear()\n{\nif (arr_pot_field != nullptr)\n{\nfor (unsigned int i = 0; i < row; ++i)\n{\ndelete[] arr_pot_field[i];\n}\ndelete[] arr_pot_field;\narr_pot_field = nullptr;\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	83	94	goalCount = 0;\nobstacleCount = 0;\nif (arr_pot_field != nullptr)\n{\ncout << "failure" <<endl;\n}\ncout << "success" <<endl;\n}\nvoid Pot_field_nav::exit()\n{\nclear();\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	96	107	void Pot_field_nav::update(float K)\n{\nif (K > 0)\n{\nk_val = K;\n//computeFieldX();\n//computeFieldY();\n//computePotentials();\ncout<< "success" << endl;\n}\ncout << "failure" <<endl;\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	109	121	void Pot_field_nav::move(unsigned int X, unsigned int Y)\n{\nif (X< row && Y<col)\n{\nfloat potentialX = computeFieldX(X, Y);\nfloat potentialY = computeFieldY(X, Y);\nstd::cout << "Potential at (" << X << ", " << Y << "): "\n<< "Px: " << potentialX << ", "\n<< "Py: " << potentialY << std::endl;\n} else {\nstd::cout << "failure" << std::endl;\n}\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	123	129	float Pot_field_nav::computeFieldX(unsigned int X, unsigned int Y)\n{\nfloat potentialX = 0.0f;\nfor (unsigned int i = 0; i < goalCount; ++i)\n{\nunsigned int goalXpos = goalX[i];\nunsigned int goalYpos = goalY[i];
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	131	136	float dist = sqrt(pow((X - goalXpos), 2) + pow((Y - goalYpos), 2));\nif (dist > 0)\n{\npotentialX -= k_val / dist;\n}\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	138	140	for (unsigned int o = 0; o < obstacleCount; ++o) {\nunsigned int obstacleXpos = obstacleX[o];\nunsigned int obstacleYpos = obstacleY[o];
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	142	148	float dist = sqrt(pow((X - obstacleXpos), 2) + pow((Y - obstacleYpos), 2));\nif (dist > 0) {\npotentialX += k_val / dist; // Repulsive potential\n}\n}\nreturn potentialX;\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	150	156	float Pot_field_nav::computeFieldY(unsigned int X, unsigned int Y)\n{\nfloat potentialY = 0.0f;\nfor (unsigned int i=0; i < goalCount; ++i)\n{\nunsigned int goalXpos = goalX[i];\nunsigned int goalYpos = goalY[i];
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	158	165	float dist = sqrt(pow((X - goalXpos), 2) + pow((Y - goalYpos), 2));\nif (dist > 0)\n{\npotentialY -= k_val / dist;\n}\nfor (unsigned int o = 0; o < obstacleCount; ++o) {\nunsigned int obstacleXpos = obstacleX[o];\nunsigned int obstacleYpos = obstacleY[o];
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	167	174	float dist = sqrt(pow((X - obstacleXpos), 2) + pow((Y - obstacleYpos), 2));\nif (dist > 0) {\npotentialY += k_val / dist; // Repulsive potential\n}\n}\nreturn potentialY;\n}\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	176	182	void Pot_field_nav::computePotentials()\n{    // Reset potentials\nfor (unsigned int i = 0; i < row; ++i) {\nfor (unsigned int j = 0; j < col; ++j) {\narr_pot_field[i][j] = 0; // Reset potential at all points\n}\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	184	187	// Calculate potentials from goals\nfor (unsigned int g = 0; g < goalCount; ++g) {\nunsigned int goalXpos = goalX[g];\nunsigned int goalYpos = goalY[g];
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	189	197	for (unsigned int i = 0; i < row; ++i) {\nfor (unsigned int j = 0; j < col; ++j) {\nfloat dist = sqrt(pow((i - goalXpos), 2) + pow((j - goalYpos), 2));\nif (dist > 0) {\narr_pot_field[i][j] -= k_val / dist; // Attractive potential\n}\n}\n}\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	199	202	// Calculate potentials from obstacles\nfor (unsigned int o = 0; o < obstacleCount; ++o) {\nunsigned int obstacleXpos = obstacleX[o];\nunsigned int obstacleYpos = obstacleY[o];
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	204	213	for (unsigned int i = 0; i < row; ++i) {\nfor (unsigned int j = 0; j < col; ++j) {\nfloat dist = sqrt(pow((i - obstacleXpos), 2) + pow((j - obstacleYpos), 2));\nif (dist > 0) {\narr_pot_field[i][j] += k_val / dist; // Repulsive potential\n}\n}\n}\n}\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	219	219	Constructor
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	233	233	Destructor
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	237	237	Create the grid
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	252	252	Add a point (goal or obstacle)
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	254	254	Clear the grid
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	276	276	Move to a specific point and output potential
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	285	289	if (i==3 && j ==3)\n{\ncout <<k_val<<endl;\ncout << "at 3,3 move " <<arr_pot_field[3][3] <<endl;\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	306	306	Update potentials for all other points based on the new goal
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	314	314	Update potential for goal
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	317	324	if (i == 7 && j == 7)\n{\ncout << "Goal 7 ,7 " << arr_pot_field[7][7] <<endl;\n}\nif (i == 0 && j == 7)\n{\ncout << "Goal 0, 7 " << arr_pot_field[0][7] <<endl;\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	331	331	Set potential at the obstacle location to a high value (optional)
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	333	333	Update potentials for all other points based on the new obstacle
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	342	343	Update potential for obstacle\ncout << arr_pot_field[i][j] << endl;
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	345	356	if (i == 3 && j == 3)\n{\ncout << "Obstacle 3, 3 " << arr_pot_field[3][3] <<endl;\n}\nif (i == 3 && j == 4)\n{\ncout << "Obstacle 3, 4 " <<arr_pot_field[3][4] <<endl;\n}\nif (i == 4 && j == 3)\n{\ncout << "Obstacle 4 , 3 " << arr_pot_field[4][3] <<endl;\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	360	360	You can decide how to represent obstacles
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	364	364	If out of bounds
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	393	420	void Pot_field_nav::point(char T, unsigned int X, unsigned int Y) {\nif (X < row && Y < col) {\nfor (int i = 0; i < row; ++i)\n{\nfor (int j = 0; j < col; ++j)\n{\nif (T == 'G')\n{\nif (X == i && Y == j)\n{\narr_pot_field[i][j] -= 0;\n//cout << "success" << endl;\n}\nelse\n{\narr_pot_field[i][j] -= (k_val / sqrt(pow((i - X), 2) + pow((j - Y), 2)));\nif (i == 0 && j == 0)\n{\ncout << arr_pot_field[i][j] << endl;\n}\n//cout << "success" << endl;\n}\n}\nelse if (T == 'O')\n{\nif (X == i && Y == j)\n{\narr_pot_field[i][j] += 0;
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	422	422	//cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	424	432	}\nelse\n{\narr_pot_field[i][j] += (k_val / sqrt(pow((i - X), 2) + pow((j - Y), 2)));\nif (i == 0 && j == 0)\n{\ncout << arr_pot_field[i][j] << endl;\n}\n//cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	434	438	}\n}\n}\n}\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	GridDefinitions.cpp	440	444	else\n{\ncout << "failure" << endl;\n}\n}
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	10	10	Initialize Pot_field_nav with default parameters
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	16	16	Changed to float to match the update function parameter type
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	19	19	Open the input file
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	25	25	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	33	33	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	40	40	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	44	44	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	47	47	Ensure K is float
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	49	49	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 12:01:21	main.cpp	52	53	cout << "success" << endl;\nExit the loop
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	6	6	For std::string
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	11	11	Constructor
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	17	17	Member functions
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	28	33	Member variables for robot and goal positions\nRobot's X position\nRobot's Y position\nGoal's X position\nGoal's Y position\nSize parameter K
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	35	37	Potential value for obstacles\nPotential value for goal X\nPotential value for goal Y
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	43	43	Dynamic 2D array for potential field
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	45	49	Number of rows in the grid\nNumber of columns in the grid\nK value for potential calculations\nPotential in the X direction\nPotential in the Y direction
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	51	51	Pointers for potential linked list implementation (if needed)
c59eb9b7	f24	p0	2024-09-23 12:01:21	potFieldNav.hpp	56	56	POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	6	6	Constructor
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	20	20	Destructor
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	24	24	Create the grid
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	39	39	Add a point (goal or obstacle)
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	41	41	Clear the grid
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	63	63	Move to a specific point and output potential
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	73	73	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	89	89	Update potentials for all other points based on the new goal
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	97	97	Update potential for goal
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	104	104	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	106	106	Set potential at the obstacle location to a high value (optional)
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	108	108	Update potentials for all other points based on the new obstacle
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	117	118	Update potential for obstacle\ncout << arr_pot_field[i][j] << endl;
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	122	122	You can decide how to represent obstacles
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	124	125	cout << "obstacle success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;\ncout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:43:15	GridDefinitions.cpp	128	128	If out of bounds
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	10	10	Initialize Pot_field_nav with default parameters
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	16	16	Changed to float to match the update function parameter type
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	19	19	Open the input file
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	25	25	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	33	33	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	40	40	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	44	44	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	47	47	Ensure K is float
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	49	49	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:43:15	main.cpp	52	53	cout << "success" << endl;\nExit the loop
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	1	2	#ifndef POT_FIELD_NAV_H\n#define POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	6	6	For std::string
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	11	11	Constructor
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	17	17	Member functions
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	28	33	Member variables for robot and goal positions\nRobot's X position\nRobot's Y position\nGoal's X position\nGoal's Y position\nSize parameter K
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	35	37	Potential value for obstacles\nPotential value for goal X\nPotential value for goal Y
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	43	43	Dynamic 2D array for potential field
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	45	49	Number of rows in the grid\nNumber of columns in the grid\nK value for potential calculations\nPotential in the X direction\nPotential in the Y direction
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	51	51	Pointers for potential linked list implementation (if needed)
c59eb9b7	f24	p0	2024-09-23 13:43:15	potFieldNav.hpp	56	56	#endif // POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	6	6	Constructor
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	20	20	Destructor
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	24	24	Create the grid
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	39	39	Add a point (goal or obstacle)
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	41	41	Clear the grid
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	63	63	Move to a specific point and output potential
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	73	73	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	89	89	Update potentials for all other points based on the new goal
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	97	97	Update potential for goal
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	104	104	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	106	106	Set potential at the obstacle location to a high value (optional)
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	108	108	Update potentials for all other points based on the new obstacle
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	117	118	Update potential for obstacle\ncout << arr_pot_field[i][j] << endl;
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	122	122	You can decide how to represent obstacles
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	124	125	cout << "obstacle success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;\ncout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:54:37	GridDefinitions.cpp	128	128	If out of bounds
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	10	10	Initialize Pot_field_nav with default parameters
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	16	16	Changed to float to match the update function parameter type
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	19	19	Open the input file
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	25	25	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	33	33	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	40	40	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	44	44	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	47	47	Ensure K is float
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	49	49	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 13:54:37	main.cpp	52	53	cout << "success" << endl;\nExit the loop
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	1	2	#ifndef POT_FIELD_NAV_H\n#define POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	6	6	For std::string
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	11	11	Constructor
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	17	17	Member functions
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	28	33	Member variables for robot and goal positions\nRobot's X position\nRobot's Y position\nGoal's X position\nGoal's Y position\nSize parameter K
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	35	37	Potential value for obstacles\nPotential value for goal X\nPotential value for goal Y
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	43	43	Dynamic 2D array for potential field
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	45	49	Number of rows in the grid\nNumber of columns in the grid\nK value for potential calculations\nPotential in the X direction\nPotential in the Y direction
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	51	51	Pointers for potential linked list implementation (if needed)
c59eb9b7	f24	p0	2024-09-23 13:54:37	potFieldNav.hpp	56	56	#endif // POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	6	6	Constructor
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	31	31	Create the grid
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	46	46	Add a point (goal or obstacle)
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	48	48	Clear the grid
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	70	70	Move to a specific point and output potential
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	80	80	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	96	96	Update potentials for all other points based on the new goal
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	104	104	Update potential for goal
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	111	111	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	113	113	Set potential at the obstacle location to a high value (optional)
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	115	115	Update potentials for all other points based on the new obstacle
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	124	125	Update potential for obstacle\ncout << arr_pot_field[i][j] << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	129	129	You can decide how to represent obstacles
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	131	132	cout << "obstacle success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;\ncout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	GridDefinitions.cpp	135	135	If out of bounds
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	10	10	Initialize Pot_field_nav with default parameters
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	16	16	Changed to float to match the update function parameter type
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	19	19	Open the input file
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	25	25	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	33	33	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	40	40	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	44	44	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	47	47	Ensure K is float
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	49	49	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	52	52	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 14:44:43	main.cpp	54	54	Exit the loop
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	1	2	#ifndef POT_FIELD_NAV_H\n#define POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	6	6	For std::string
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	11	11	Constructor
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	17	17	Member functions
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	24	24	Member variables for robot and goal positions
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	28	28	Dynamic 2D array for potential field
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	30	34	Number of rows in the grid\nNumber of columns in the grid\nK value for potential calculations\nPotential in the X direction\nPotential in the Y direction
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	36	36	Pointers for potential linked list implementation (if needed)
c59eb9b7	f24	p0	2024-09-23 14:44:43	potFieldNav.hpp	41	41	#endif // POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	6	6	Constructor
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	31	31	Create the grid
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	52	52	Add a point (goal or obstacle)e xi
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	54	54	Clear the grid
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	76	76	Move to a specific point and output potential
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	80	80	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	93	93	Update potentials for all other points based on the new goal
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	101	101	Update potential for goal
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	108	108	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	110	110	Set potential at the obstacle location to a high value (optional)
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	112	112	Update potentials for all other points based on the new obstacle
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	121	122	Update potential for obstacle\ncout << arr_pot_field[i][j] << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	126	126	You can decide how to represent obstacles
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	128	129	cout << "obstacle success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;\ncout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	GridDefinitions.cpp	132	132	If out of bounds
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	10	10	Initialize Pot_field_nav with default parameters
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	16	16	Changed to float to match the update function parameter type
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	19	19	Open the input file
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	25	25	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	33	33	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	40	40	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	44	44	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	47	47	Ensure K is float
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	49	49	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	52	52	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 16:41:30	main.cpp	54	54	Exit the loop
c59eb9b7	f24	p0	2024-09-23 16:41:30	potFieldNav.hpp	1	2	#ifndef POT_FIELD_NAV_H\n#define POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 16:41:30	potFieldNav.hpp	6	6	For std::string
c59eb9b7	f24	p0	2024-09-23 16:41:30	potFieldNav.hpp	11	11	Constructor
c59eb9b7	f24	p0	2024-09-23 16:41:30	potFieldNav.hpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 16:41:30	potFieldNav.hpp	17	17	Member functions
c59eb9b7	f24	p0	2024-09-23 16:41:30	potFieldNav.hpp	24	24	Member variables for robot and goal positions
c59eb9b7	f24	p0	2024-09-23 16:41:30	potFieldNav.hpp	28	28	Dynamic 2D array for potential field
c59eb9b7	f24	p0	2024-09-23 16:41:30	potFieldNav.hpp	30	32	Number of rows in the grid\nNumber of columns in the grid\nK value for potential calculations
c59eb9b7	f24	p0	2024-09-23 16:41:30	potFieldNav.hpp	35	35	#endif // POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	6	6	Constructor
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	15	15	Destructor
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	35	35	Create the grid
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	62	62	Add a point (goal or obstacle)e xi
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	64	64	Clear the grid
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	95	95	Move to a specific point and output potential
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	99	99	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	119	119	Update potential for goal
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	123	123	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	136	137	Update potential for obstacle\ncout << arr_pot_field[i][j] << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	141	141	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	156	156	Update potential for the new goal
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	160	160	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	162	162	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	164	164	Set potential at the obstacle location to a high value (optional)
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	166	166	Update potentials for all other points based on the new obstacle
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	175	176	Update potential for obstacle\ncout << arr_pot_field[i][j] << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	180	182	cout << "success" << endl;\ncout << "obstacle success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;\ncout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	GridDefinitions.cpp	188	188	If out of bounds
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	10	10	Initialize Pot_field_nav with default parameters
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	16	16	Changed to float to match the update function parameter type
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	22	22	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	30	30	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	37	37	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	41	41	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	44	44	Ensure K is float
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	46	46	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	49	49	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	51	51	Exit the loop
c59eb9b7	f24	p0	2024-09-23 19:48:19	main.cpp	58	58	Open the input file
c59eb9b7	f24	p0	2024-09-23 19:48:19	potFieldNav.hpp	1	2	#ifndef POT_FIELD_NAV_H\n#define POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 19:48:19	potFieldNav.hpp	6	6	For std::string
c59eb9b7	f24	p0	2024-09-23 19:48:19	potFieldNav.hpp	11	11	Constructor
c59eb9b7	f24	p0	2024-09-23 19:48:19	potFieldNav.hpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 19:48:19	potFieldNav.hpp	17	17	Member functions
c59eb9b7	f24	p0	2024-09-23 19:48:19	potFieldNav.hpp	24	24	Member variables for robot and goal positions
c59eb9b7	f24	p0	2024-09-23 19:48:19	potFieldNav.hpp	28	28	Dynamic 2D array for potential field
c59eb9b7	f24	p0	2024-09-23 19:48:19	potFieldNav.hpp	31	33	Number of rows in the grid\nNumber of columns in the grid\nK value for potential calculations
c59eb9b7	f24	p0	2024-09-23 19:48:19	potFieldNav.hpp	36	36	#endif // POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	6	6	Constructor
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	15	15	Destructor
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	35	35	Create the grid
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	62	62	Add a point (goal or obstacle)e xi
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	64	64	Clear the grid
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	95	95	Move to a specific point and output potential
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	99	99	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	119	119	Update potential for goal
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	123	123	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	136	137	Update potential for obstacle\ncout << arr_pot_field[i][j] << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	141	141	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	156	156	Update potential for the new goal
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	160	160	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	162	162	cout << "GOAL success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	164	164	Set potential at the obstacle location to a high value (optional)
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	166	166	Update potentials for all other points based on the new obstacle
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	175	176	Update potential for obstacle\ncout << arr_pot_field[i][j] << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	180	182	cout << "success" << endl;\ncout << "obstacle success" << arr_pot_field[X][Y] << "X Y " << X << " " << Y << endl;\ncout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	GridDefinitions.cpp	188	188	If out of bounds
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	10	10	Initialize Pot_field_nav with default parameters
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	16	16	Changed to float to match the update function parameter type
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	22	22	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	30	30	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	37	37	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	41	41	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	44	44	Ensure K is float
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	46	46	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	49	49	cout << "success" << endl;
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	51	51	Exit the loop
c59eb9b7	f24	p0	2024-09-23 21:42:04	main.cpp	58	58	Open the input file
c59eb9b7	f24	p0	2024-09-23 21:42:04	potFieldNav.hpp	1	2	#ifndef POT_FIELD_NAV_H\n#define POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 21:42:04	potFieldNav.hpp	6	6	For std::string
c59eb9b7	f24	p0	2024-09-23 21:42:04	potFieldNav.hpp	11	11	Constructor
c59eb9b7	f24	p0	2024-09-23 21:42:04	potFieldNav.hpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 21:42:04	potFieldNav.hpp	17	17	Member functions
c59eb9b7	f24	p0	2024-09-23 21:42:04	potFieldNav.hpp	24	24	Member variables for robot and goal positions
c59eb9b7	f24	p0	2024-09-23 21:42:04	potFieldNav.hpp	28	28	Dynamic 2D array for potential field
c59eb9b7	f24	p0	2024-09-23 21:42:04	potFieldNav.hpp	31	33	Number of rows in the grid\nNumber of columns in the grid\nK value for potential calculations
c59eb9b7	f24	p0	2024-09-23 21:42:04	potFieldNav.hpp	36	36	#endif // POT_FIELD_NAV_H
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	6	6	Constructor
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	11	12	initialize 2D array for storing the potential field value at each coordinate on the grid\ninitialize 2D array for storing contribution: either 'G' or 'O'
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	15	15	Destructor
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	35	35	Create the grid
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	37	37	making sure that the map gets deleted/cleared before setting up a new one with correct memory allocation
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	58	58	filling the non-contributed elements with space to indicate they are not obstacles or goals
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	63	63	Add a point (goal or obstacle)e xi
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	65	65	Clear the grid
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	78	78	remember to set up the 2D array for obstacle or goal contribution alongside the potential field value array storing corresponding values
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	97	97	Move to a specific point and output potential
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	100	101	check the bounds are valid\nO(1) retrieval potential field value running time
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	111	112	breaking two cases\nprevious has 'G' or 'O' and overwrites
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	123	123	Update potential for goal
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	139	139	Update potential for obstacle
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	146	146	no previous 'O' or 'G' and want to store with a new contribution
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	158	158	Update potential for the new goal
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	164	164	Set potential at the obstacle location to a high value (optional)
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	166	166	Update potentials for all other points based on the new obstacle
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	175	175	Update potential for obstacle
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	184	184	for out of bounds
c59eb9b7	f24	p0	2024-09-23 21:56:11	GridDefinitions.cpp	198	198	simply calculates the ratio of k constants without recalculating through the nested for loops
c59eb9b7	f24	p0	2024-09-23 21:56:11	main.cpp	10	10	Initialize Pot_field_nav with default parameters
c59eb9b7	f24	p0	2024-09-23 21:56:11	main.cpp	16	16	Changed to double to match the update function parameter type
c59eb9b7	f24	p0	2024-09-23 21:56:11	main.cpp	40	40	Ensure K is float
c59eb9b7	f24	p0	2024-09-23 21:56:11	main.cpp	45	45	Exit the loop
c59eb9b7	f24	p0	2024-09-23 21:56:11	potFieldNav.hpp	6	6	For std::string
c59eb9b7	f24	p0	2024-09-23 21:56:11	potFieldNav.hpp	11	11	Constructor
c59eb9b7	f24	p0	2024-09-23 21:56:11	potFieldNav.hpp	14	14	Destructor
c59eb9b7	f24	p0	2024-09-23 21:56:11	potFieldNav.hpp	17	17	Member functions
c59eb9b7	f24	p0	2024-09-23 21:56:11	potFieldNav.hpp	26	26	Dynamic 2D array for potential field
c59eb9b7	f24	p0	2024-09-23 21:56:11	potFieldNav.hpp	29	31	Number of rows in the grid\nNumber of columns in the grid\nK value for potential calculations
c59eb9b7	f24	p0	2024-09-23 21:56:11	potFieldNav.hpp	34	34	POT_FIELD_NAV_H
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	30	30	destructor
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	36	36	insert function
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	49	49	move function
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	61	61	update the k value
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	74	74	clear field function
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	85	86	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	93	93	position checker
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	99	99	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	104	105	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	110	111	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.cpp	129	129	clear field in destructor
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	12	12	Pointer to 2D array of Point objects
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	14	14	Default constructor
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	17	17	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	20	20	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	23	23	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	26	26	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	29	29	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	32	32	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	36	38	Length of the field\nWidth of the field\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	40	40	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	43	43	Helper method to calculate the potential for the entire field
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-22 13:48:52	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-22 13:48:52	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-22 13:48:52	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-22 13:48:52	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-22 13:48:52	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-22 13:48:52	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-22 13:48:52	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-22 13:48:52	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-22 13:48:52	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	28	28	destructor
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	34	34	insert function
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	47	47	move function
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	60	60	update the k value
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	83	83	clear field function
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	94	95	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	102	102	position checker
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	108	108	clear field in destructor
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	151	151	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	156	157	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.cpp	162	163	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	12	12	Pointer to 2D array of Point objects
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	14	14	Default constructor
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	17	17	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	20	20	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	23	23	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	26	26	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	29	29	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	32	32	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	36	38	Length of the field\nWidth of the field\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	40	40	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	43	44	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	48	49	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-22 14:00:19	Field.hpp	53	53	FIELD_HPP
c61cfbbd	f24	p0	2024-09-22 14:00:19	Main.cpp	19	19	Free the previous field
c61cfbbd	f24	p0	2024-09-22 14:00:19	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-22 14:00:19	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-22 14:00:19	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-22 14:00:19	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-22 14:00:19	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-22 14:00:19	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-22 14:00:19	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-22 14:00:19	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	28	28	destructor
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	34	34	insert function
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	53	53	move function
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	66	66	update the k value
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	89	89	clear field function
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	98	98	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	100	100	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	102	102	Set potential to zero
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	109	109	position checker
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	115	115	clear field in destructor
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	158	158	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	163	164	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.cpp	169	170	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	12	12	Pointer to 2D array of Point objects
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	14	14	Default constructor
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	17	17	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	20	20	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	23	23	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	26	26	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	29	29	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	32	32	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	36	38	Length of the field\nWidth of the field\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	40	40	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	43	44	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	48	49	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-22 14:24:02	Field.hpp	53	53	FIELD_HPP
c61cfbbd	f24	p0	2024-09-22 14:24:02	Main.cpp	19	19	Free the previous field
c61cfbbd	f24	p0	2024-09-22 14:24:02	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-22 14:24:02	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-22 14:24:02	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-22 14:24:02	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-22 14:24:02	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-22 14:24:02	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-22 14:24:02	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-22 14:24:02	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	28	28	destructor
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	34	34	insert function
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	55	55	move function
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	68	68	update the k value
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	91	91	clear field function
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	100	100	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	102	102	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	104	104	Set potential to zero
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	111	111	position checker
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	117	117	clear field in destructor
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	160	160	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	165	166	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.cpp	171	172	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	12	12	Pointer to 2D array of Point objects
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	14	14	Default constructor
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	17	17	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	20	20	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	23	23	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	26	26	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	29	29	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	32	32	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	36	38	Length of the field\nWidth of the field\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	40	40	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	43	44	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	48	49	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-22 15:05:19	Field.hpp	53	53	FIELD_HPP
c61cfbbd	f24	p0	2024-09-22 15:05:19	Main.cpp	19	19	Free the previous field
c61cfbbd	f24	p0	2024-09-22 15:05:19	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-22 15:05:19	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-22 15:05:19	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-22 15:05:19	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-22 15:05:19	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-22 15:05:19	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-22 15:05:19	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-22 15:05:19	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	28	28	destructor
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	34	34	insert function
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	55	55	move function
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	68	68	update the k value
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	91	91	clear field function
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	100	100	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	102	102	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	104	104	Set potential to zero
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	111	111	position checker
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	117	117	clear field in destructor
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	160	160	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	165	166	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.cpp	171	172	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-22 15:19:32	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-22 15:19:32	Main.cpp	19	19	Free the previous field
c61cfbbd	f24	p0	2024-09-22 15:19:32	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-22 15:19:32	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-22 15:19:32	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-22 15:19:32	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-22 15:19:32	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-22 15:19:32	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-22 15:19:32	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-22 15:19:32	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	28	28	destructor
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	34	34	insert function
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	55	55	move function
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	68	68	update the k value
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	91	91	clear field function
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	100	100	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	102	102	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	104	104	Set potential to zero
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	111	111	position checker
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	117	117	clear field in destructor
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	160	160	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	165	166	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.cpp	171	172	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-22 15:57:22	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-22 15:57:22	Main.cpp	19	19	Free the previous field
c61cfbbd	f24	p0	2024-09-22 15:57:22	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-22 15:57:22	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-22 15:57:22	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-22 15:57:22	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-22 15:57:22	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-22 15:57:22	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-22 15:57:22	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-22 15:57:22	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	32	32	destructor
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	38	38	insert function
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	59	59	move function
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	73	73	position checker
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	79	79	update the k value
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	101	101	clear field function
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	110	110	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	112	112	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	114	114	Set potential to zero
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	124	124	clear field in destructor
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	169	169	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	174	175	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.cpp	180	181	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-22 17:14:48	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-22 17:14:48	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-22 17:14:48	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-22 17:14:48	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-22 17:14:48	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-22 17:14:48	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-22 17:14:48	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-22 17:14:48	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-22 17:14:48	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	32	32	destructor
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	38	38	insert function
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	59	59	move function
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	73	73	position checker
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	79	79	update the k value
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	101	101	clear field function
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	110	110	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	112	112	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	114	114	Set potential to zero
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	124	124	clear field in destructor
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	169	169	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	174	175	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.cpp	180	181	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-22 18:23:16	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-22 18:23:16	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-22 18:23:16	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-22 18:23:16	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-22 18:23:16	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-22 18:23:16	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-22 18:23:16	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-22 18:23:16	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-22 18:23:16	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	32	32	destructor
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	38	38	insert function
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	59	59	move function
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	73	73	position checker
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	79	79	update the k value
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	101	101	clear field function
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	110	110	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	112	112	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	114	114	Set potential to zero
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	124	124	clear field in destructor
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	169	169	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	174	175	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.cpp	180	181	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-22 18:25:38	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-22 18:25:38	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-22 18:25:38	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-22 18:25:38	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-22 18:25:38	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-22 18:25:38	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-22 18:25:38	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-22 18:25:38	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-22 18:25:38	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	32	32	destructor
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	38	38	insert function
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	59	59	move function
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	73	73	position checker
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	79	79	update the k value
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	101	101	clear field function
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	110	110	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	112	112	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	114	114	Set potential to zero
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	124	124	clear field in destructor
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	169	169	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	174	175	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.cpp	180	181	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-23 10:09:51	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-23 10:09:51	Main.cpp	49	49	Free the allocated memory
c61cfbbd	f24	p0	2024-09-23 10:09:51	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-23 10:09:51	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-23 10:09:51	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-23 10:09:51	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-23 10:09:51	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-23 10:09:51	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-23 10:09:51	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-23 10:09:51	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	29	29	destructor
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	35	35	insert function
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	56	56	move function
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	70	70	position checker
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	76	76	update the k value
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	98	98	clear field function
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	107	107	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	109	109	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	111	111	Set potential to zero
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	121	121	clear field in destructor
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	166	166	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	171	172	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.cpp	177	178	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-23 10:25:29	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-23 10:25:29	Main.cpp	49	49	Free the allocated memory
c61cfbbd	f24	p0	2024-09-23 10:25:29	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-23 10:25:29	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-23 10:25:29	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-23 10:25:29	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-23 10:25:29	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-23 10:25:29	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-23 10:25:29	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-23 10:25:29	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	29	29	destructor
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	35	35	insert function
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	56	56	move function
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	70	70	position checker
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	76	76	update the k value
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	98	98	clear field function
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	107	107	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	109	109	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	111	111	Set potential to zero
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	121	121	clear field in destructor
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	166	166	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	171	172	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.cpp	177	178	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-23 10:33:09	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-23 10:33:09	Main.cpp	49	49	Free the allocated memory
c61cfbbd	f24	p0	2024-09-23 10:33:09	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-23 10:33:09	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-23 10:33:09	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-23 10:33:09	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-23 10:33:09	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-23 10:33:09	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-23 10:33:09	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-23 10:33:09	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	31	31	destructor
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	36	36	Ensure the old field is deleted before allocating a new one
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	40	40	insert function
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	63	63	move function
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	77	77	position checker
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	83	83	update the k value
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	105	105	clear field function
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	114	114	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	116	116	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	118	118	Set potential to zero
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	126	126	clear field in destructor
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	171	171	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	176	177	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.cpp	182	183	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-23 11:10:58	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-23 11:10:58	Main.cpp	48	48	Free the allocated memory
c61cfbbd	f24	p0	2024-09-23 11:10:58	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-23 11:10:58	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-23 11:10:58	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-23 11:10:58	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-23 11:10:58	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-23 11:10:58	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-23 11:10:58	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-23 11:10:58	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	31	31	destructor
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	36	36	Ensure the old field is deleted before allocating a new one
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	40	40	insert function
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	63	63	move function
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	77	77	position checker
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	83	83	update the k value
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	105	105	clear field function
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	114	114	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	116	116	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	118	118	Set potential to zero
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	126	126	clear field in destructor
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	171	171	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	176	177	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.cpp	182	183	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-23 12:27:22	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-23 12:27:22	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-23 12:27:22	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-23 12:27:22	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-23 12:27:22	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-23 12:27:22	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-23 12:27:22	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-23 12:27:22	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-23 12:27:22	Point.hpp	22	22	POINT_HPP
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	7	7	constructor
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	31	31	destructor
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	36	36	Ensure the old field is deleted before allocating a new one
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	40	40	insert function
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	63	63	move function
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	77	77	position checker
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	83	83	update the k value
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	105	105	clear field function
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	114	114	Iterate over rows (length)
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	116	116	Iterate over columns (width)
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	118	118	Set potential to zero
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	126	126	clear field in destructor
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	171	171	calculates the potential of the entire field
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	176	177	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.cpp	182	183	Row index\nColumn index
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	12	15	Pointer to 2D array of Point objects\nLength of the field, amount of rows, y variable\nWidth of the field, amount of colums,\nConstant for potential field calculations
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	17	17	Default constructor
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	20	20	Constructor to initialize the field with length and width
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	23	23	Destructor to clear the field
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	26	26	Method to insert goals or obstacles
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	29	29	Method to move the robot and get the potential
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	32	32	Method to update the constant 'k'
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	35	35	Method to clear the field (called by the destructor)
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	38	38	Helper method to check if a position is valid
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	41	42	Helper method to calculate the potential for the entire field\nvoid calculate_potential();
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	46	47	Helper method to help delete dynamic allocations\nclear field in destructor
c61cfbbd	f24	p0	2024-09-23 13:51:05	Field.hpp	51	51	FIELD_HPP
c61cfbbd	f24	p0	2024-09-23 13:51:05	Point.cpp	3	3	constructor
c61cfbbd	f24	p0	2024-09-23 13:51:05	Point.cpp	11	11	destructor
c61cfbbd	f24	p0	2024-09-23 13:51:05	Point.cpp	14	14	accessors & mutators
c61cfbbd	f24	p0	2024-09-23 13:51:05	Point.hpp	6	8	'G' for goal, 'O' for obstacle, or ' ' for empty space\nPotential in the x-direction\nPotential in the y-direction
c61cfbbd	f24	p0	2024-09-23 13:51:05	Point.hpp	10	10	Default constructor
c61cfbbd	f24	p0	2024-09-23 13:51:05	Point.hpp	13	13	Destructor
c61cfbbd	f24	p0	2024-09-23 13:51:05	Point.hpp	16	16	Mutator to set potential
c61cfbbd	f24	p0	2024-09-23 13:51:05	Point.hpp	22	22	POINT_HPP
c8f55dfa	f24	p0	2024-09-23 18:02:08	main.cpp	10	10	Main loop
c8f55dfa	f24	p0	2024-09-23 18:02:08	main.cpp	12	12	CREATE command
c8f55dfa	f24	p0	2024-09-23 18:02:08	main.cpp	14	14	Dimensions
c8f55dfa	f24	p0	2024-09-23 18:02:08	main.cpp	19	19	new map with N rows and M columns
c8f55dfa	f24	p0	2024-09-23 18:02:08	main.cpp	22	22	POINT command
c8f55dfa	f24	p0	2024-09-23 18:02:08	main.cpp	37	37	MOVE command
c8f55dfa	f24	p0	2024-09-23 18:02:08	main.cpp	52	52	Handle CLEAR command
c8f55dfa	f24	p0	2024-09-23 18:02:08	main.cpp	64	64	UPDATE command
c8f55dfa	f24	p0	2024-09-23 18:02:08	main.cpp	78	78	EXIT command
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	4	4	map with dimensions N x M
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	6	6	create method
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	20	20	Create function
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	34	34	Initialize potential to 0
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	36	36	Set all cells to empty
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	43	43	Check position is in bounds
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	56	56	Calculate potentials for each point
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	60	60	Negative for goal, positive for obstacle
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	62	62	Calculate potentials for other points
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	85	85	Recompute potentials after adding new point
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	91	91	Get the potential at position (X, Y) and return it through Px and Py
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	101	101	Clear the map by resetting
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.cpp	113	113	Update K and recompute potential
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.h	6	11	rows in map\ncolumns in the map\nK for potential\n2D array for x component of potential\n2D array for y component of potential\n2D array for    'G' for goal, 'O' for obstacle, 'E' for empty
c8f55dfa	f24	p0	2024-09-23 18:02:08	Map.h	13	14	Check if the position is within map bounds\nRecompute potential field based on points
c8f55dfa	f24	p0	2024-09-23 21:10:39	main.cpp	10	10	Main loop
c8f55dfa	f24	p0	2024-09-23 21:10:39	main.cpp	12	12	CREATE command
c8f55dfa	f24	p0	2024-09-23 21:10:39	main.cpp	14	14	Dimensions
c8f55dfa	f24	p0	2024-09-23 21:10:39	main.cpp	19	19	new map with N rows and M columns
c8f55dfa	f24	p0	2024-09-23 21:10:39	main.cpp	22	22	POINT command
c8f55dfa	f24	p0	2024-09-23 21:10:39	main.cpp	37	37	MOVE command
c8f55dfa	f24	p0	2024-09-23 21:10:39	main.cpp	52	52	Handle CLEAR command
c8f55dfa	f24	p0	2024-09-23 21:10:39	main.cpp	64	64	UPDATE command
c8f55dfa	f24	p0	2024-09-23 21:10:39	main.cpp	78	78	EXIT command
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	4	4	map with dimensions N x M
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	6	6	create method
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	20	20	Create function
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	34	34	Initialize potential to 0
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	36	36	Set all cells to empty
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	43	43	Check position is in bounds
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	56	56	Calculate potentials for each point
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	60	60	Negative for goal, positive for obstacle
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	62	62	Calculate potentials for other points
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	85	85	Recompute potentials after adding new point
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	91	91	Get the potential at position (X, Y) and return it through Px and Py
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	101	101	Clear the map by resetting
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.cpp	113	113	Update K and recompute potential
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.h	6	11	rows in map\ncolumns in the map\nK for potential\n2D array for x component of potential\n2D array for y component of potential\n2D array for    'G' for goal, 'O' for obstacle, 'E' for empty
c8f55dfa	f24	p0	2024-09-23 21:10:39	Map.h	13	14	Check if the position is within map bounds\nRecompute potential field based on points
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	20	20	__COMO_VERSION__ = VRR
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	50	50	__INTEL_COMPILER_BUILD_DATE = YYYYMMDD
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	54	54	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	92	92	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	124	124	__BORLANDC__ = 0xVRR
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	130	130	__WATCOMC__ = VVRR
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	139	139	__WATCOMC__ = VVRP + 1100
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	149	149	__SUNPRO_CC = 0xVRRP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	154	154	__SUNPRO_CC = 0xVRP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	162	162	__HP_aCC = VVRRPP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	169	169	__DECCXX_VER = VVRRTPPPP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	176	176	__IBMCPP__ = VRP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	199	199	__IBMCPP__ = VRP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	206	206	__IBMCPP__ = VRP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	234	234	__TI_COMPILER_VERSION__ = VVVRRRPPP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	265	265	__GHS_VERSION_NUMBER = VVVVRP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	284	284	__ARMCC_VERSION = VRRPPPP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	289	289	__ARMCC_VERSION = VRPPPP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	305	305	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	327	327	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	364	364	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	369	369	_MSC_FULL_VER = VVRRPPPPP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	372	372	_MSC_FULL_VER = VVRRPPPP
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	383	383	__VERSIONNUM__ = 0xVVRRPPTT
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	411	411	unknown compiler
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	435	435	Identify known platforms by name.
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	527	527	unknown platform
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	535	535	regular Integrity
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	542	542	unknown platform
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	583	583	unknown architecture
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	594	594	unknown architecture
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	629	629	unknown architecture
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	649	649	unknown architecture
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	666	666	unknown architecture
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	704	704	Convert integer to decimal digit literals.
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	715	715	Convert integer to hex digit literals.
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	726	726	Construct a string literal encoding the version number.
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	730	730	Construct a string literal encoding the version number components.
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	748	748	Construct a string literal encoding the internal version number.
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	759	759	Construct a string literal encoding the version number components.
c917a4a4	f24	p0	2024-09-22 19:25:50	CMakeCXXCompilerId.cpp	828	828	--------------------------------------------------------------------------
c917a4a4	f24	p0	2024-09-22 19:25:50	main.cpp	9	9	'input' stores the command entered by the user, continuously receives user input until "EXIT" is entered
c917a4a4	f24	p0	2024-09-22 19:25:50	main.cpp	12	14	The first input is stored in 'h', the second input is stored in 'w'\nCalls the initialize function\n"POINT" command
c917a4a4	f24	p0	2024-09-22 19:25:50	main.cpp	19	19	"MOVE" command
c917a4a4	f24	p0	2024-09-22 19:25:50	main.cpp	23	23	"CLEAR" command
c917a4a4	f24	p0	2024-09-22 19:25:50	main.cpp	25	25	"UPDATE" command
c917a4a4	f24	p0	2024-09-22 19:25:50	main.cpp	28	29	Even though it’s entered as new_scale, it will be passed to the function in the map.cpp file as "factor"\nbecause the function signature is void Grid::adjust(double factor)
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	3	3	Constructor
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	5	5	Destructor
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	9	17	The reason for using void: The function performs the task of creating and initializing the array, but there's no need to return any value.\nFree existing memory to prevent memory leaks.\nHeight\nWidth\nint a=10; int*&a p is a pointer that stores the address of a, pointer array = an array of pointers that store memory addresses; pointing to memory locations.\nA 2D array is implemented using pointer arrays; the vertical direction is managed by a pointer array, and each pointer points to a row array. Using 'new' allows for dynamic memory allocation that can be freed when necessary. We use double because the array may contain decimal values.\nfield_values = a pointer array used to implement the 2D array. new double*[height] dynamically allocates memory for the vertical direction of the array.\nAt this point, height number of pointers are created. This means field_values will contain pointers to each row.\ne.g., field_values[2] -> points to the third row (not allocated yet).
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	19	20	Starting from the first row (i=0), create arrays for each row until height, forming rows in the vertical direction.\ne.g., if h=3, w=4, then i=0, and field_values[0] = new double[4] = a row with 4 double elements in the first row.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	22	22	Array initialization: When i=0, for the first row, visit columns j=0, 1, 2, 3, and initialize each value to 0.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	25	26	Check if the array has been successfully initialized.\nIf initialized, print "success".
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	29	31	Adds the target point 'G' or obstacle 'O' at a specific coordinate on the map. The target point exerts an attractive force = reduces the potential value, and the obstacle exerts a repulsive force = increases the potential value.\nchar stores a single character, and letter = 'G' or 'O'.\nIf the array is not initialized or if the x, y coordinates are out of bounds = failure.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	36	38	-1 for attractive force = reduces potential value, 1 for repulsive force = increases potential value. This is because, in this potential field, the robot finds the target point by moving towards decreasing potential values (0).\nHence, setting the impact to -1 reduces the potential value, creating an attractive effect that guides the robot towards the target point.\nIf 'G' is received, return -1; if false, return 1 (Conditional expression: ? value when true : value when false).
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	40	40	Calculate potential values for all cells on the map. For each cell, calculate the distance to the given coordinate (x, y), then update the potential value based on that distance.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	42	45	Use the given formula (distance between points).\nEnsure that we do not calculate the distance to itself.\nfield_values[i][j] stores the potential value at coordinate i, j. The new potential value is added to the current value. scale_factor = K, and dividing by distance is done because the effect is inversely proportional to the distance. The closer the target, the greater the effect on the potential value, and the further away, the less the effect.\ne.g., if the target point is at (2, 2) and the current cell is at (3, 3), the distance is sqrt(2). field_values[3][3] += -1 * scale_factor / sqrt(2);
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	53	53	Using the potential values (field_values[i][j]) calculated earlier, this function prints the potential value at the specific coordinate x, y.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	59	59	The potential values updated in the place function are printed through the navigate function.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	63	66	Resets the entire map to its initial state.\nInitialization is the process of allocating memory and preparing the data structure for use. If the map hasn't been created yet, there's nothing to reset.\ninitialize is the process of buying a new notebook (allocating new memory) and preparing it for use.\nreset is like erasing a used notebook and getting it ready to be reused.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	79	81	This function changes the scale_factor, which affects the entire map. It adjusts the strength of the potential field.\nThe factor is the value that will be assigned to scale_factor.\nFactor must be greater than 0.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	90	90	Check if field_values has been dynamically allocated (not nullptr).
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	92	92	Delete the memory allocated to each row.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	94	95	Delete the entire array (also removes the pointer array pointing to each row).\nSet to nullptr to prevent accidental access to invalid memory.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.cpp	97	98	Set is_initialized to false to indicate the array is no longer initialized.\nSince the array has been deleted, the initialized state is reset to uninitialized, requiring new memory allocation for future use.
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.h	5	5	Included because sqrt is used
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.h	9	12	Dimensions of the grid\nArray to store potential field values\nConstant K\nTo check if the array has been initialized
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.h	14	14	Function to reset potential values
c917a4a4	f24	p0	2024-09-22 19:25:50	Map.h	17	23	Constructor\nDestructor\nFunction to create the array\nFunction to add a goal or obstacle\nFunction to navigate\nFunction to reset the potential field\nFunction to update the constant K
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	20	20	__COMO_VERSION__ = VRR
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	50	50	__INTEL_COMPILER_BUILD_DATE = YYYYMMDD
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	54	54	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	92	92	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	124	124	__BORLANDC__ = 0xVRR
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	130	130	__WATCOMC__ = VVRR
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	139	139	__WATCOMC__ = VVRP + 1100
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	149	149	__SUNPRO_CC = 0xVRRP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	154	154	__SUNPRO_CC = 0xVRP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	162	162	__HP_aCC = VVRRPP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	169	169	__DECCXX_VER = VVRRTPPPP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	176	176	__IBMCPP__ = VRP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	199	199	__IBMCPP__ = VRP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	206	206	__IBMCPP__ = VRP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	234	234	__TI_COMPILER_VERSION__ = VVVRRRPPP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	265	265	__GHS_VERSION_NUMBER = VVVVRP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	284	284	__ARMCC_VERSION = VRRPPPP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	289	289	__ARMCC_VERSION = VRPPPP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	305	305	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	327	327	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	364	364	_MSC_VER = VVRR
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	369	369	_MSC_FULL_VER = VVRRPPPPP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	372	372	_MSC_FULL_VER = VVRRPPPP
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	383	383	__VERSIONNUM__ = 0xVVRRPPTT
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	411	411	unknown compiler
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	435	435	Identify known platforms by name.
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	527	527	unknown platform
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	535	535	regular Integrity
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	542	542	unknown platform
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	583	583	unknown architecture
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	594	594	unknown architecture
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	629	629	unknown architecture
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	649	649	unknown architecture
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	666	666	unknown architecture
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	704	704	Convert integer to decimal digit literals.
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	715	715	Convert integer to hex digit literals.
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	726	726	Construct a string literal encoding the version number.
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	730	730	Construct a string literal encoding the version number components.
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	748	748	Construct a string literal encoding the internal version number.
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	759	759	Construct a string literal encoding the version number components.
c917a4a4	f24	p0	2024-11-18 22:28:52	CMakeCXXCompilerId.cpp	828	828	--------------------------------------------------------------------------
c917a4a4	f24	p0	2024-11-18 22:28:52	main.cpp	9	9	'input' stores the command entered by the user, continuously receives user input until "EXIT" is entered
c917a4a4	f24	p0	2024-11-18 22:28:52	main.cpp	12	14	The first input is stored in 'h', the second input is stored in 'w'\nCalls the initialize function\n"POINT" command
c917a4a4	f24	p0	2024-11-18 22:28:52	main.cpp	19	19	"MOVE" command
c917a4a4	f24	p0	2024-11-18 22:28:52	main.cpp	23	23	"CLEAR" command
c917a4a4	f24	p0	2024-11-18 22:28:52	main.cpp	25	25	"UPDATE" command
c917a4a4	f24	p0	2024-11-18 22:28:52	main.cpp	28	29	Even though it’s entered as new_scale, it will be passed to the function in the map.cpp file as "factor"\nbecause the function signature is void Grid::adjust(double factor)
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	3	3	Constructor
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	5	5	Destructor
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	9	17	The reason for using void: The function performs the task of creating and initializing the array, but there's no need to return any value.\nFree existing memory to prevent memory leaks.\nHeight\nWidth\nint a=10; int*&a p is a pointer that stores the address of a, pointer array = an array of pointers that store memory addresses; pointing to memory locations.\nA 2D array is implemented using pointer arrays; the vertical direction is managed by a pointer array, and each pointer points to a row array. Using 'new' allows for dynamic memory allocation that can be freed when necessary. We use double because the array may contain decimal values.\nfield_values = a pointer array used to implement the 2D array. new double*[height] dynamically allocates memory for the vertical direction of the array.\nAt this point, height number of pointers are created. This means field_values will contain pointers to each row.\ne.g., field_values[2] -> points to the third row (not allocated yet).
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	19	20	Starting from the first row (i=0), create arrays for each row until height, forming rows in the vertical direction.\ne.g., if h=3, w=4, then i=0, and field_values[0] = new double[4] = a row with 4 double elements in the first row.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	22	22	Array initialization: When i=0, for the first row, visit columns j=0, 1, 2, 3, and initialize each value to 0.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	25	26	Check if the array has been successfully initialized.\nIf initialized, print "success".
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	29	31	Adds the target point 'G' or obstacle 'O' at a specific coordinate on the map. The target point exerts an attractive force = reduces the potential value, and the obstacle exerts a repulsive force = increases the potential value.\nchar stores a single character, and letter = 'G' or 'O'.\nIf the array is not initialized or if the x, y coordinates are out of bounds = failure.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	36	38	-1 for attractive force = reduces potential value, 1 for repulsive force = increases potential value. This is because, in this potential field, the robot finds the target point by moving towards decreasing potential values (0).\nHence, setting the impact to -1 reduces the potential value, creating an attractive effect that guides the robot towards the target point.\nIf 'G' is received, return -1; if false, return 1 (Conditional expression: ? value when true : value when false).
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	40	40	Calculate potential values for all cells on the map. For each cell, calculate the distance to the given coordinate (x, y), then update the potential value based on that distance.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	42	45	Use the given formula (distance between points).\nEnsure that we do not calculate the distance to itself.\nfield_values[i][j] stores the potential value at coordinate i, j. The new potential value is added to the current value. scale_factor = K, and dividing by distance is done because the effect is inversely proportional to the distance. The closer the target, the greater the effect on the potential value, and the further away, the less the effect.\ne.g., if the target point is at (2, 2) and the current cell is at (3, 3), the distance is sqrt(2). field_values[3][3] += -1 * scale_factor / sqrt(2);
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	53	53	Using the potential values (field_values[i][j]) calculated earlier, this function prints the potential value at the specific coordinate x, y.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	59	59	The potential values updated in the place function are printed through the navigate function.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	63	66	Resets the entire map to its initial state.\nInitialization is the process of allocating memory and preparing the data structure for use. If the map hasn't been created yet, there's nothing to reset.\ninitialize is the process of buying a new notebook (allocating new memory) and preparing it for use.\nreset is like erasing a used notebook and getting it ready to be reused.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	79	81	This function changes the scale_factor, which affects the entire map. It adjusts the strength of the potential field.\nThe factor is the value that will be assigned to scale_factor.\nFactor must be greater than 0.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	90	90	Check if field_values has been dynamically allocated (not nullptr).
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	92	92	Delete the memory allocated to each row.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	94	95	Delete the entire array (also removes the pointer array pointing to each row).\nSet to nullptr to prevent accidental access to invalid memory.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.cpp	97	98	Set is_initialized to false to indicate the array is no longer initialized.\nSince the array has been deleted, the initialized state is reset to uninitialized, requiring new memory allocation for future use.
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.h	5	5	Included because sqrt is used
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.h	9	12	Dimensions of the grid\nArray to store potential field values\nConstant K\nTo check if the array has been initialized
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.h	14	14	Function to reset potential values
c917a4a4	f24	p0	2024-11-18 22:28:52	Map.h	17	23	Constructor\nDestructor\nFunction to create the array\nFunction to add a goal or obstacle\nFunction to navigate\nFunction to reset the potential field\nFunction to update the constant K
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	6	6	Change to store double values
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	12	12	Clear previous map memory (if any) before reallocating
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	17	17	Free inner-most arrays
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	19	19	Free middle arrays
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	21	21	Free outer array
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	26	26	Free previous memory if map exists
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	29	29	Set new dimensions
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	34	35	Allocate memory for the new 3D map array\nNow a 3D array of doubles
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	39	39	Initialize potentials to ⟨0.0, 0.0⟩
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	47	47	Add a goal (G) or obstacle (O) at position (xG, yG)
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	59	59	Recalculate potentials for all points based on the new goal/obstacle
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	63	63	Potential is zero at the goal/obstacle location
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	68	68	Prevent division by zero
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	71	71	Apply attractive force for goal
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	75	75	Apply repulsive force for obstacle
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	93	93	Output the potentials at position (x, y)
cc34e9df	f24	p0	2024-09-16 20:23:31	main.cpp	131	131	Destructor to automatically clear memory when the Map object is destroyed
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	3	3	Destructor to automatically clear memory when the Map object is destroyed
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	8	8	This function clears the allocated memory for the map.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	12	12	Free "x" direction arrays.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	14	15	Free outermost array, the "y" direction arrays.\nAvoid dangling pointer
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	19	19	This creates a map of size N x M.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	21	21	Free previous memory if a map exists.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	24	24	Set variable value dependent on the array's properties.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	30	30	Allocate memory for the new 3D map array (3rd element stores point type)
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	43	43	This adds a Goal or Obstacle at position (xG, yG).
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	45	45	Ensures that the map is created and the coordinates are within bounds
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	60	60	This gives back the potential at (x, y).
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	62	62	Ensures that the data input is within the limits of the map & that there is a map.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	73	73	x Move and y Move
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	79	79	big o of M then N
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	82	82	Runs O(1)
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	87	87	cout << "GOAL " << distance << "v_ " << val << endl;
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	92	92	cout << "OBSTANCLE " << distance << " k_" << K << " v_ " << val << endl;
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	98	98	cout << val << endl;
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	104	104	This sets all the map potentials to 0.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	106	106	Ensures that we have a map before doing anything.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	112	112	Iterate over all potentials and set each one back to 0.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	125	125	This updates the value of K used in potential calculations.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	127	127	Check if the new value of K is valid (must be positive)
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	144	144	To store the input.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	147	147	We create an instance of the Map.
cc34e9df	f24	p0	2024-09-17 19:55:51	main.cpp	150	150	Loop to process commands
cc34e9df	f24	p0	2024-09-17 19:55:51	main.hpp	6	8	Include stringstream\nInclude string for getline\nRequired for ceil function
cc34e9df	f24	p0	2024-09-17 19:55:51	main.hpp	14	17	3D array to store potential values and type of each cell\nNumber of rows in the map\nNumber of columns in the map\nConstant used for potential calculations
cc34e9df	f24	p0	2024-09-17 19:55:51	main.hpp	19	19	Function to recalculate potentials
cc34e9df	f24	p0	2024-09-17 19:55:51	main.hpp	22	22	Destructor
cc34e9df	f24	p0	2024-09-17 19:55:51	main.hpp	25	25	Member functions
cc34e9df	f24	p0	2024-09-17 19:55:51	main.hpp	34	34	MAIN_H
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	3	3	This destructor will automatically clear the memory when the Map object is destroyed
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	8	8	This function will clear the allocated memory that was used for the map.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	10	10	Just ensuring that the map exists
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	12	12	Free "x" direction arrays.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	14	15	Free outermost array, the "y" direction arrays.\nRemoving the pointer, to avoid dangling pointer
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	19	19	This creates a map of size N x M (XxY).
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	21	21	Basically "Deletes Map" (Free previous memory if a map exists).
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	24	24	Set variable value dependent on the array's properties.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	30	30	Allocate memory for the new 2D array
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	33	33	Making sub-arrays of size N.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	35	35	Default Value for each grid is X, which means it is neither a Goal or Object.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	42	42	This adds a Goal or Obstacle at position (xG, yG).
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	45	45	Ensures that the map is created and the coordinates are within bounds
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	51	51	Sets the grid to type T (Object, or Goal).
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	61	61	This gives back the potential at (x, y).
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	63	63	Ensures that the data input is within the limits of the map & that there is a map.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	69	69	we get the potential at point x,y from the function "calcPotField" and then just output it.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	75	76	Calculates the potential at grid xM,yM.\nx Move and y Move
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	80	81	big o of M then N\nlogic inside the for loops Runs O(1)
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	83	83	Itterates over the whole map and calculates the potential at the point.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	88	88	Calculates the distance from the the point xM yM to each grid point
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	90	90	If distance is 0 we skip it.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	109	109	This removes all positions of the Goals and Objects.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	111	111	Ensures that we have a map before doing anything.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	117	117	Iterate over map and sets all values back to X.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	130	130	This updates the value of K used in potential calculations.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	132	132	Check if the new value of K is valid (must be positive)
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	145	145	To store the input.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	148	148	We create an instance of the Map.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.cpp	151	151	Loop to process commands
cc34e9df	f24	p0	2024-09-23 12:33:46	main.hpp	4	5	input/output\nUsed for math
cc34e9df	f24	p0	2024-09-23 12:33:46	main.hpp	11	14	2D array to store the location of the Goals and Obstacles\nNumber of rows in the map\nNumber of columns in the map\nConstant used for potential calculations
cc34e9df	f24	p0	2024-09-23 12:33:46	main.hpp	16	16	Calculates the potential at grid xM,yM by itterating over the whole map.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.hpp	19	19	This function will clear the allocated memory that was used for the map.
cc34e9df	f24	p0	2024-09-23 12:33:46	main.hpp	23	23	Destructor
cc34e9df	f24	p0	2024-09-23 12:33:46	main.hpp	26	26	Member functions
cc34e9df	f24	p0	2024-09-23 12:33:46	main.hpp	34	34	MAIN_H
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	1	1	This destructor will automatically clear the memory when the Map object is destroyed
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	6	6	This function will clear the allocated memory that was used for the map.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	8	8	Just ensuring that the map exists
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	10	10	Free "x" direction arrays.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	12	13	Free outermost array, the "y" direction arrays.\nRemoving the pointer, to avoid dangling pointer
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	17	17	This creates a map of size N x M (XxY).
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	19	19	Basically "Deletes Map" (Free previous memory if a map exists).
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	22	22	Set variable value dependent on the array's properties.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	28	28	Allocate memory for the new 2D array
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	31	31	Making sub-arrays of size N.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	33	33	Default Value for each grid is X, which means it is neither a Goal or Object.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	40	40	This adds a Goal or Obstacle at position (xG, yG).
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	43	43	Ensures that the map is created and the coordinates are within bounds
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	49	49	Sets the grid to type T (Object, or Goal).
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	59	59	This gives back the potential at (x, y).
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	61	61	Ensures that the data input is within the limits of the map & that there is a map.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	67	67	we get the potential at point x,y from the function "calcPotField" and then just output it.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	73	74	Calculates the potential at grid xM,yM.\nx Move and y Move
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	78	79	big o of M then N\nlogic inside the for loops Runs O(1)
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	81	81	Itterates over the whole map and calculates the potential at the point.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	86	86	Calculates the distance from the the point xM yM to each grid point
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	88	88	If distance is 0 we skip it.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	107	107	This removes all positions of the Goals and Objects.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	109	109	Ensures that we have a map before doing anything.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	115	115	Iterate over map and sets all values back to X.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	128	128	This updates the value of K used in potential calculations.
cc34e9df	f24	p0	2024-09-23 12:46:47	logic.cpp	130	130	Check if the new value of K is valid (must be positive)
cc34e9df	f24	p0	2024-09-23 12:46:47	main.cpp	6	6	To store the input.
cc34e9df	f24	p0	2024-09-23 12:46:47	main.cpp	9	9	We create an instance of the Map.
cc34e9df	f24	p0	2024-09-23 12:46:47	main.cpp	12	12	Loop to process commands
cc34e9df	f24	p0	2024-09-23 12:46:47	main.hpp	4	5	input/output\nUsed for math
cc34e9df	f24	p0	2024-09-23 12:46:47	main.hpp	11	14	2D array to store the location of the Goals and Obstacles\nNumber of rows in the map\nNumber of columns in the map\nConstant used for potential calculations
cc34e9df	f24	p0	2024-09-23 12:46:47	main.hpp	16	16	Calculates the potential at grid xM,yM by itterating over the whole map.
cc34e9df	f24	p0	2024-09-23 12:46:47	main.hpp	19	19	This function will clear the allocated memory that was used for the map.
cc34e9df	f24	p0	2024-09-23 12:46:47	main.hpp	23	23	Destructor
cc34e9df	f24	p0	2024-09-23 12:46:47	main.hpp	26	26	Member functions
cc34e9df	f24	p0	2024-09-23 12:46:47	main.hpp	34	34	MAIN_H
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	1	1	This destructor will automatically clear the memory when the Map object is destroyed
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	6	6	This function will clear the allocated memory that was used for the map.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	8	8	Just ensuring that the map exists
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	10	10	Free "x" direction arrays.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	12	13	Free outermost array, the "y" direction arrays.\nRemoving the pointer, to avoid dangling pointer
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	17	17	This creates a map of size N x M (XxY).
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	19	19	Basically "Deletes Map" (Free previous memory if a map exists).
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	22	22	Set variable value dependent on the array's properties.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	28	28	Allocate memory for the new 2D array
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	31	31	Making sub-arrays of size N.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	33	33	Default Value for each grid is X, which means it is neither a Goal or Object.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	40	40	This adds a Goal or Obstacle at position (xG, yG).
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	43	43	Ensures that the map is created and the coordinates are within bounds
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	49	49	Sets the grid to type T (Object, or Goal).
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	59	59	This gives back the potential at (x, y).
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	61	61	Ensures that the data input is within the limits of the map & that there is a map.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	67	67	we get the potential at point x,y from the function "calcPotField" and then just output it.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	73	74	Calculates the potential at grid xM,yM.\nx Move and y Move
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	78	79	big o of M then N\nlogic inside the for loops Runs O(1)
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	81	81	Itterates over the whole map and calculates the potential at the point.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	86	86	Calculates the distance from the the point xM yM to each grid point
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	88	88	If distance is 0 we skip it.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	107	107	This removes all positions of the Goals and Objects.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	109	109	Ensures that we have a map before doing anything.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	115	115	Iterate over map and sets all values back to X.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	128	128	This updates the value of K used in potential calculations.
cc34e9df	f24	p0	2024-09-23 12:55:58	logic.cpp	130	130	Check if the new value of K is valid (must be positive)
cc34e9df	f24	p0	2024-09-23 12:55:58	main.cpp	6	6	To store the input.
cc34e9df	f24	p0	2024-09-23 12:55:58	main.cpp	9	9	We create an instance of the Map.
cc34e9df	f24	p0	2024-09-23 12:55:58	main.cpp	12	12	Loop to process commands
cc34e9df	f24	p0	2024-09-23 12:55:58	main.hpp	4	5	input/output\nUsed for math
cc34e9df	f24	p0	2024-09-23 12:55:58	main.hpp	11	14	2D array to store the location of the Goals and Obstacles\nNumber of rows in the map\nNumber of columns in the map\nConstant used for potential calculations
cc34e9df	f24	p0	2024-09-23 12:55:58	main.hpp	16	16	Calculates the potential at grid xM,yM by itterating over the whole map.
cc34e9df	f24	p0	2024-09-23 12:55:58	main.hpp	19	19	This function will clear the allocated memory that was used for the map.
cc34e9df	f24	p0	2024-09-23 12:55:58	main.hpp	23	23	Destructor
cc34e9df	f24	p0	2024-09-23 12:55:58	main.hpp	26	26	Member functions
cc34e9df	f24	p0	2024-09-23 12:55:58	main.hpp	34	34	MAIN_H
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.cpp	5	5	Constructor: Initializes the map and sets all potential values to (0, 0)
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.cpp	14	14	Deallocate the array of row pointers
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.cpp	19	19	Previous map deletion
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.cpp	30	30	Allocate new memory for the map
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.hpp	7	7	Initialize to (0,0)
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.hpp	12	14	Dimensions of the map\nConstant for potential calculation\n2D array for potential values
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.hpp	21	21	Create a new map with different dimensions
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.hpp	24	24	Add a goal ('G') or obstacle ('O') at position (x, y)
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.hpp	27	27	Clear the map of all goals and obstacles
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.hpp	30	30	Update the constant K
cd36fde8	f24	p0	2024-09-23 15:55:07	PotentialField.hpp	33	33	Get the direction for the robot to move at position (x, y)
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.cpp	5	5	Constructor: Initializes the map and sets all potential values to (0, 0)
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.cpp	14	14	Deallocate the array of row pointers
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.cpp	20	20	Previous map deletion
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.cpp	32	32	Allocate new memory for the map
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.hpp	7	7	Initialize to (0,0)
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.hpp	12	14	Dimensions of the map\nConstant for potential calculation\n2D array for potential values
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.hpp	21	21	Create a new map with different dimensions
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.hpp	24	24	Add a goal ('G') or obstacle ('O') at position (x, y)
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.hpp	27	27	Clear the map of all goals and obstacles
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.hpp	30	30	Update the constant K
cd36fde8	f24	p0	2024-09-23 16:06:34	PotentialField.hpp	33	33	Get the direction for the robot to move at position (x, y)
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.cpp	5	5	Constructor: Initializes the map and sets all potential values to (0, 0)
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.cpp	11	11	Delete the dynamically allocated memory for the map
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.cpp	17	17	Set to nullptr to avoid double deletion
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.cpp	22	22	Previous map deletion (only if map is not null)
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.cpp	28	28	Reset the map pointer
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.cpp	34	34	Allocate new memory for the map
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.hpp	7	7	Initialize to (0,0)
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.hpp	12	14	Dimensions of the map\nConstant for potential calculation\n2D array for potential values
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.hpp	21	21	Create a new map with different dimensions
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.hpp	24	24	Add a goal ('G') or obstacle ('O') at position (x, y)
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.hpp	27	27	Clear the map of all goals and obstacles
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.hpp	30	30	Update the constant K
cd36fde8	f24	p0	2024-09-23 16:11:11	PotentialField.hpp	33	33	Get the direction for the robot to move at position (x, y)
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.cpp	5	5	Constructor: Initializes the map and sets all potential values to (0, 0)
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.cpp	11	11	Delete the dynamically allocated memory for the map
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.cpp	33	33	Allocate new memory for the map
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.hpp	7	7	Initialize to (0,0)
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.hpp	12	14	Dimensions of the map\nConstant for potential calculation\n2D array for potential values
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.hpp	21	21	Create a new map with different dimensions
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.hpp	24	24	Add a goal ('G') or obstacle ('O') at position (x, y)
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.hpp	27	27	Clear the map of all goals and obstacles
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.hpp	30	30	Update the constant K
cd36fde8	f24	p0	2024-09-23 16:45:03	PotentialField.hpp	33	33	Get the direction for the robot to move at position (x, y)
ce7c555a	f24	p0	2024-09-21 15:52:11	main.cpp	9	9	int val;
ce7c555a	f24	p0	2024-09-21 15:52:11	main.cpp	11	11	read commands
ce7c555a	f24	p0	2024-09-21 15:52:11	main.cpp	15	15	delete existing field
ce7c555a	f24	p0	2024-09-21 15:52:11	main.cpp	40	40	if (pf != nullptr) {
ce7c555a	f24	p0	2024-09-21 15:52:11	main.cpp	42	42	}
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	5	5	Constructor to create a map with all potential vectors set to <0, 0>
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	8	8	a = new char*[rows];
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	12	12	a[i] = new char[cols];
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	16	16	N for None, G for Goal, O for Obstacle
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	23	23	Destructor to deallocate the 2D array
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	27	27	delete[] a[i];
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	30	30	delete[] a;
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	33	33	Function to compute potentials of each grid at position (X, Y) due to a goal or obstacle
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	35	35	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	44	44	need something when dist =0? when it's on the goal or obstable?
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	49	49	Function to add a new goal or obstacle and recomputes the potential of all points in the map
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	53	53	Add goal
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	56	56	Add obstacle
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	65	65	Function to get the potential at a point
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	74	74	Function to clear the map
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	90	90	Function to update the value of K
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.cpp	94	95	clear();  // Reset map first\nrecompute
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.h	7	7	status G for Goals, O for Obstacles, N for None
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.h	16	16	char** a;
ce7c555a	f24	p0	2024-09-21 15:52:11	PotentialField.h	29	29	POTENTIALFIELD_H
ce7c555a	f24	p0	2024-09-21 17:14:24	main.cpp	9	9	int val;
ce7c555a	f24	p0	2024-09-21 17:14:24	main.cpp	11	11	read commands
ce7c555a	f24	p0	2024-09-21 17:14:24	main.cpp	15	15	delete existing field
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	5	5	Constructor to create a map with all potential vectors set to <0, 0>
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	8	8	a = new char*[rows];
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	11	11	a[i] = new char[cols];
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	15	15	N for None, G for Goal, O for Obstacle
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	22	22	Destructor to deallocate the 2D array
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	26	26	delete[] a[i];
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	29	29	delete[] a;
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	32	32	Function to compute potentials of each grid at position (X, Y) due to a goal or obstacle
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	34	34	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	48	48	Function to add a new goal or obstacle and recomputes the potential of all points in the map
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	50	50	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	63	63	Function to add a new goal or obstacle and recomputes the potential of all points in the map
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	72	72	Add goal
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	79	79	Add obstacle
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	88	88	Function to get the potential at a point
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	97	97	Function to clear the map
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	107	107	mapCreated = false;
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	113	113	Function to update the value of K
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.cpp	117	118	clear();  // Reset map first\nrecompute
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.h	7	7	status G for Goals, O for Obstacles, N for None
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.h	16	16	char** a;
ce7c555a	f24	p0	2024-09-21 17:14:24	PotentialField.h	31	31	POTENTIALFIELD_H
ce7c555a	f24	p0	2024-09-22 17:39:13	main.cpp	9	9	int val;
ce7c555a	f24	p0	2024-09-22 17:39:13	main.cpp	11	11	read commands
ce7c555a	f24	p0	2024-09-22 17:39:13	main.cpp	15	15	delete existing field
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	5	5	Constructor: Initializes all potential values to 0 and sets the status to 'N'
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	19	19	'N' means None
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	26	26	Destructor: Frees memory allocated for the potential field arrays
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	38	38	Computes potentials for all points based on the goal or obstacle at (x, y)
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	40	40	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	53	53	Overwrites the potential values when a goal or obstacle is removed
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	55	55	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	68	68	Adds a point (goal or obstacle) to the field and updates potentials
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	76	76	Set goal
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	83	83	Set obstacle
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	91	91	Prints the potential at a specific (X, Y) point
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	100	100	Clears all potentials and resets the field
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	107	107	Reset to None
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.cpp	115	115	Updates the K constant and recomputes all potentials
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.h	7	10	x-components of potential field\ny-components of potential field\nstatus of each point: 'N' for None, 'G' for Goal, 'O' for Obstacle\nconstant K
ce7c555a	f24	p0	2024-09-22 17:39:13	PotentialField1.h	26	26	POTENTIALFIELD_H
ce7c555a	f24	p0	2024-09-22 18:33:30	main.cpp	9	9	int val;
ce7c555a	f24	p0	2024-09-22 18:33:30	main.cpp	11	11	read commands
ce7c555a	f24	p0	2024-09-22 18:33:30	main.cpp	15	15	delete existing field
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	5	5	Constructor: Initializes all potential values to 0 and sets the status to 'N'
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	19	19	'N' means None
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	26	26	Destructor: Frees memory allocated for the potential field arrays
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	38	38	Computes potentials for all points based on the goal or obstacle at (x, y)
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	40	40	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	53	53	Overwrites the potential values
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	55	55	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	68	68	Adds a point (goal or obstacle) to the field and updates potentials
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	78	78	Set goal
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	87	87	Set obstacle
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	95	95	Prints the potential at a specific (X, Y) point
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	104	104	Clears all potentials and resets the field
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	111	111	Reset to None
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.cpp	119	119	Updates the K constant and recomputes all potentials
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.h	7	10	x-components of potential field\ny-components of potential field\nstatus of each point: 'N' for None, 'G' for Goal, 'O' for Obstacle\nconstant K
ce7c555a	f24	p0	2024-09-22 18:33:30	PotentialField1.h	26	26	POTENTIALFIELD_H
ce7c555a	f24	p0	2024-09-22 21:50:23	main.cpp	9	9	int val;
ce7c555a	f24	p0	2024-09-22 21:50:23	main.cpp	11	11	read commands
ce7c555a	f24	p0	2024-09-22 21:50:23	main.cpp	15	15	delete existing field
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	5	5	constructor: initializes all potential values to <0.0, 0.0> and sets the status to 'N'
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	11	11	allocate 2D arrays
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	19	19	'N' means None
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	26	26	destructor: frees memory allocated for the potential field arrays
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	38	38	computes potentials for all cells based on the goal or obstacle at (x, y)
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	40	40	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	53	53	before calculationg potential values due to a new G or O, subtract a potential value of an old G or O (overwrite)
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	55	55	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	68	68	adds a G or O to the map and updates potentials
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	71	71	if there is an existing old G or O, overwrite
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	79	79	update the status: set G
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	82	82	update the status: set O
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	90	90	prints the potential at a specific (X, Y) cell
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	99	99	clears all potentials and resets the map
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	106	106	reset status
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.cpp	114	114	updates the K constant and recomputes all potentials
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.h	7	10	x-components of potential values\ny-components of potential values\nstatus of each cell: 'N' for None, 'G' for Goal, 'O' for Obstacle\nconstant K
ce7c555a	f24	p0	2024-09-22 21:50:23	PotentialField1.h	26	26	POTENTIALFIELD_H
ce7c555a	f24	p0	2024-09-23 21:18:50	main.cpp	9	9	int val;
ce7c555a	f24	p0	2024-09-23 21:18:50	main.cpp	11	11	read commands
ce7c555a	f24	p0	2024-09-23 21:18:50	main.cpp	15	15	delete existing field
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	5	5	constructor: initializes all potential values to <0.0, 0.0> and sets the status to 'N'
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	11	11	allocate 2D arrays
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	19	19	'N' means None
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	26	26	destructor: frees memory allocated for the potential field arrays
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	38	38	computes potentials for all cells based on the goal or obstacle at (x, y)
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	40	40	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	53	53	before calculationg potential values due to a new G or O, subtract a potential value of an old G or O (overwrite)
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	55	55	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	68	68	adds a G or O to the map and updates potentials
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	71	71	if there is an existing old G or O, overwrite
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	79	79	update the status: set G
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	82	82	update the status: set O
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	90	90	prints the potential at a specific (X, Y) cell
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	99	99	clears all potentials and resets the map
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	106	106	reset status
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.cpp	114	114	updates the K constant and recomputes all potentials
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.h	7	10	x-components of potential values\ny-components of potential values\nstatus of each cell: 'N' for None, 'G' for Goal, 'O' for Obstacle\nconstant K
ce7c555a	f24	p0	2024-09-23 21:18:50	PotentialField1.h	26	26	POTENTIALFIELD_H
ce7c555a	f24	p0	2024-09-23 22:50:50	main.cpp	9	9	int val;
ce7c555a	f24	p0	2024-09-23 22:50:50	main.cpp	11	11	read commands
ce7c555a	f24	p0	2024-09-23 22:50:50	main.cpp	15	15	delete existing map
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	5	5	constructor: initializesq all potential values to <0.0, 0.0> and sets the status to 'N'
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	11	11	allocate 2D arrays
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	19	19	'N' means None
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	26	26	destructor: frees memory allocated for the potential field arrays
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	38	38	computes potentials for all cells based on the goal or obstacle at (x, y)
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	40	40	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	53	53	before calculationg potential values due to a new G or O, subtract a potential value of an old G or O (overwrite)
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	55	55	Negative for goals, positive for obstacles
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	68	68	adds a G or O to the map and updates potentials
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	71	71	if there is an existing old G or O, overwrite
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	79	79	update the status: set G
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	82	82	update the status: set O
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	90	90	prints the potential at a (X, Y) cell
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	99	99	clears all potentials and resets the map
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	106	106	reset status
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.cpp	114	114	updates the K constant and recomputes all potentials
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.h	7	10	x-components of potential values\ny-components of potential values\nstatus of each cell: 'N' for None, 'G' for Goal, 'O' for Obstacle\nconstant K
ce7c555a	f24	p0	2024-09-23 22:50:50	PotentialField.h	25	25	POTENTIALFIELD_H
d045513d	f24	p0	2024-09-22 11:50:25	cell.cpp	2	2	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-22 11:50:25	cell.cpp	4	4	setting the constructor to default values
d045513d	f24	p0	2024-09-22 11:50:25	cell.cpp	7	7	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-22 11:50:25	cell.cpp	9	9	method for setting potential
d045513d	f24	p0	2024-09-22 11:50:25	cell.cpp	12	12	method for getting potential
d045513d	f24	p0	2024-09-22 11:50:25	cell.h	11	11	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-22 11:50:25	cell.h	14	14	Default constructor
d045513d	f24	p0	2024-09-22 11:50:25	cell.h	17	17	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-22 11:50:25	cell.h	19	19	all of the methods are defined in the header files, but the actual code for the member functions are in the cell.cpp file
d045513d	f24	p0	2024-09-22 11:50:25	cell.h	21	22	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-22 11:50:25	cell.h	24	25	method to set the state using a boolean, 0 for goal and 1 for obstacle\nmethod to get the state value
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	5	5	change grid to gridArray
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	7	7	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	10	10	allocating memory for the rows star what does it do
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	12	12	allocating memory for the columns
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	18	18	destructor to dynamically delete memory
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	20	20	checking if array is empty
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	22	23	deleting array of cells\ngridArray[i] = nullptr;
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	25	25	delete array of row pointers
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	30	30	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	32	32	method for setting row
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	35	35	method for getting column
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	57	57	clears the array of all obstacles and goals and resets the potentials in it to <0,0>
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	67	67	double grid:: calcPot(int n, int m, int k){//make void
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	69	69	double pot = 0.0;
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	75	75	run through array and set pot of eerything equal 0
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	87	87	gridArray[x][y].setPotential(gridArray[x][y].getPotential() + pot);
d045513d	f24	p0	2024-09-22 11:50:25	grid.cpp	111	111	return totPot;
d045513d	f24	p0	2024-09-22 11:50:25	grid.h	14	14	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-22 11:50:25	grid.h	17	17	default constructor
d045513d	f24	p0	2024-09-22 11:50:25	grid.h	20	20	destructor
d045513d	f24	p0	2024-09-22 11:50:25	grid.h	23	23	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-22 11:50:25	grid.h	25	25	all of the methods are defined in the header files, but the actual code for the member functions are in the cell.cpp file
d045513d	f24	p0	2024-09-22 11:50:25	grid.h	27	28	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-22 11:50:25	Main.cpp	4	5	main class\npointer to the grid class
d045513d	f24	p0	2024-09-22 11:50:25	Main.cpp	7	7	initializing variables
d045513d	f24	p0	2024-09-22 11:50:25	Main.cpp	13	13	parsing the input cmd
d045513d	f24	p0	2024-09-22 11:50:25	Main.cpp	15	17	if the grid already exists\ndelete the grid_ptr\nset it to nullptr
d045513d	f24	p0	2024-09-22 11:50:25	Main.cpp	20	22	making the array\nsetting the k value to 1 as required from project guidelines\noutputting success if the grid does not already exist
d045513d	f24	p0	2024-09-22 11:50:25	Main.cpp	27	30	checking if inputs are positive and within array size limits set by create\nsetting state\nrecalculating potential due to the new obstacle or goal added\noutputting success if the x and y given are within array and positive
d045513d	f24	p0	2024-09-22 11:50:25	Main.cpp	69	69	Clean up
d045513d	f24	p0	2024-09-22 12:03:44	cell.cpp	2	2	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-22 12:03:44	cell.cpp	4	4	setting the constructor to default values
d045513d	f24	p0	2024-09-22 12:03:44	cell.cpp	7	7	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-22 12:03:44	cell.cpp	9	9	method for setting potential
d045513d	f24	p0	2024-09-22 12:03:44	cell.cpp	12	12	method for getting potential
d045513d	f24	p0	2024-09-22 12:03:44	cell.h	11	11	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-22 12:03:44	cell.h	14	14	Default constructor
d045513d	f24	p0	2024-09-22 12:03:44	cell.h	17	17	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-22 12:03:44	cell.h	19	19	all of the methods are defined in the header files, but the actual code for the member functions are in the cell.cpp file
d045513d	f24	p0	2024-09-22 12:03:44	cell.h	21	22	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-22 12:03:44	cell.h	24	25	method to set the state using a boolean, 0 for goal and 1 for obstacle\nmethod to get the state value
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	5	5	change grid to gridArray
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	7	7	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	10	10	allocating memory for the rows star what does it do
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	12	12	allocating memory for the columns
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	18	18	destructor to dynamically delete memory
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	20	20	checking if array is empty
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	22	23	deleting array of cells\ngridArray[i] = nullptr;
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	25	25	delete array of row pointers
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	30	30	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	32	32	method for setting row
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	35	35	method for getting column
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	57	57	clears the array of all obstacles and goals and resets the potentials in it to <0,0>
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	67	67	double grid:: calcPot(int n, int m, int k){//make void
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	69	69	double pot = 0.0;
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	75	75	run through array and set pot of eerything equal 0
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	87	87	gridArray[x][y].setPotential(gridArray[x][y].getPotential() + pot);
d045513d	f24	p0	2024-09-22 12:03:44	grid.cpp	111	111	return totPot;
d045513d	f24	p0	2024-09-22 12:03:44	grid.h	14	14	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-22 12:03:44	grid.h	17	17	default constructor
d045513d	f24	p0	2024-09-22 12:03:44	grid.h	20	20	destructor
d045513d	f24	p0	2024-09-22 12:03:44	grid.h	23	23	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-22 12:03:44	grid.h	25	25	all of the methods are defined in the header files, but the actual code for the member functions are in the cell.cpp file
d045513d	f24	p0	2024-09-22 12:03:44	grid.h	27	28	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-22 12:03:44	Main.cpp	4	5	main class\npointer to the grid class
d045513d	f24	p0	2024-09-22 12:03:44	Main.cpp	7	7	initializing variables
d045513d	f24	p0	2024-09-22 12:03:44	Main.cpp	13	13	parsing the input cmd
d045513d	f24	p0	2024-09-22 12:03:44	Main.cpp	15	17	if the grid already exists\ndelete the grid_ptr\nset it to nullptr
d045513d	f24	p0	2024-09-22 12:03:44	Main.cpp	20	22	making the array\nsetting the k value to 1 as required from project guidelines\noutputting success if the grid does not already exist
d045513d	f24	p0	2024-09-22 12:03:44	Main.cpp	27	30	checking if inputs are positive and within array size limits set by create\nsetting state\nrecalculating potential due to the new obstacle or goal added\noutputting success if the x and y given are within array and positive
d045513d	f24	p0	2024-09-22 12:03:44	Main.cpp	69	69	Clean up
d045513d	f24	p0	2024-09-22 12:25:49	cell.cpp	2	2	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-22 12:25:49	cell.cpp	4	4	setting the constructor to default values
d045513d	f24	p0	2024-09-22 12:25:49	cell.cpp	7	7	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-22 12:25:49	cell.cpp	9	9	method for setting potential
d045513d	f24	p0	2024-09-22 12:25:49	cell.cpp	12	12	method for getting potential
d045513d	f24	p0	2024-09-22 12:25:49	cell.h	11	11	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-22 12:25:49	cell.h	14	14	Default constructor
d045513d	f24	p0	2024-09-22 12:25:49	cell.h	17	17	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-22 12:25:49	cell.h	19	19	all of the methods are defined in the header files, but the actual code for the member functions are in the cell.cpp file
d045513d	f24	p0	2024-09-22 12:25:49	cell.h	21	22	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-22 12:25:49	cell.h	24	25	method to set the state using a boolean, 0 for goal and 1 for obstacle\nmethod to get the state value
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	5	5	change grid to gridArray
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	7	7	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	10	10	allocating memory for the rows star what does it do
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	12	12	allocating memory for the columns
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	18	18	destructor to dynamically delete memory
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	20	20	checking if array is empty
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	22	23	deleting array of cells\ngridArray[i] = nullptr;
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	25	25	delete array of row pointers
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	30	30	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	32	32	method for setting row
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	35	35	method for getting column
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	57	57	clears the array of all obstacles and goals and resets the potentials in it to <0,0>
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	67	67	double grid:: calcPot(int n, int m, int k){//make void
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	69	69	double pot = 0.0;
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	75	75	run through array and set pot of eerything equal 0
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	87	87	gridArray[x][y].setPotential(gridArray[x][y].getPotential() + pot);
d045513d	f24	p0	2024-09-22 12:25:49	grid.cpp	111	111	return totPot;
d045513d	f24	p0	2024-09-22 12:25:49	grid.h	14	14	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-22 12:25:49	grid.h	17	17	default constructor
d045513d	f24	p0	2024-09-22 12:25:49	grid.h	20	20	destructor
d045513d	f24	p0	2024-09-22 12:25:49	grid.h	23	23	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-22 12:25:49	grid.h	25	25	all of the methods are defined in the header files, but the actual code for the member functions are in the cell.cpp file
d045513d	f24	p0	2024-09-22 12:25:49	grid.h	27	28	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-22 12:25:49	Main.cpp	4	5	main class\npointer to the grid class
d045513d	f24	p0	2024-09-22 12:25:49	Main.cpp	7	7	initializing variables
d045513d	f24	p0	2024-09-22 12:25:49	Main.cpp	13	13	parsing the input cmd
d045513d	f24	p0	2024-09-22 12:25:49	Main.cpp	15	17	if the grid already exists\ndelete the grid_ptr\nset it to nullptr
d045513d	f24	p0	2024-09-22 12:25:49	Main.cpp	20	22	making the array\nsetting the k value to 1 as required from project guidelines\noutputting success if the grid does not already exist
d045513d	f24	p0	2024-09-22 12:25:49	Main.cpp	27	30	checking if inputs are positive and within array size limits set by create\nsetting state\nrecalculating potential due to the new obstacle or goal added\noutputting success if the x and y given are within array and positive
d045513d	f24	p0	2024-09-22 12:25:49	Main.cpp	69	69	Clean up
d045513d	f24	p0	2024-09-22 23:54:26	cell.cpp	2	2	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-22 23:54:26	cell.cpp	4	4	setting the constructor to default values
d045513d	f24	p0	2024-09-22 23:54:26	cell.cpp	7	7	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-22 23:54:26	cell.cpp	9	9	method for setting potential
d045513d	f24	p0	2024-09-22 23:54:26	cell.cpp	12	12	method for getting potential
d045513d	f24	p0	2024-09-22 23:54:26	cell.h	11	11	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-22 23:54:26	cell.h	14	14	Default constructor
d045513d	f24	p0	2024-09-22 23:54:26	cell.h	17	17	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-22 23:54:26	cell.h	19	19	all of the methods are defined in the header files, but the actual code for the member functions are in the cell.cpp file
d045513d	f24	p0	2024-09-22 23:54:26	cell.h	21	22	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-22 23:54:26	cell.h	24	25	method to set the state using a boolean, 0 for goal and 1 for obstacle\nmethod to get the state value
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	5	5	change grid to gridArray
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	7	7	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	10	10	allocating memory for the rows star what does it do
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	12	12	allocating memory for the columns
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	18	18	destructor to dynamically delete memory
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	20	20	checking if array is empty
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	22	23	deleting array of cells\ngridArray[i] = nullptr;
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	25	25	delete array of row pointers
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	30	30	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	32	32	method for setting row
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	35	35	method for getting column
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	57	57	clears the array of all obstacles and goals and resets the potentials in it to <0,0>
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	67	67	double grid:: calcPot(int n, int m, int k){//make void
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	69	69	double pot = 0.0;
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	75	75	run through array and set pot of eerything equal 0
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	87	87	gridArray[x][y].setPotential(gridArray[x][y].getPotential() + pot);
d045513d	f24	p0	2024-09-22 23:54:26	grid.cpp	111	111	return totPot;
d045513d	f24	p0	2024-09-22 23:54:26	grid.h	14	14	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-22 23:54:26	grid.h	17	17	default constructor
d045513d	f24	p0	2024-09-22 23:54:26	grid.h	20	20	destructor
d045513d	f24	p0	2024-09-22 23:54:26	grid.h	23	23	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-22 23:54:26	grid.h	25	25	all of the methods are defined in the header files, but the actual code for the member functions are in the cell.cpp file
d045513d	f24	p0	2024-09-22 23:54:26	grid.h	27	28	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-22 23:54:26	Main.cpp	4	5	main class\npointer to the grid class
d045513d	f24	p0	2024-09-22 23:54:26	Main.cpp	7	7	initializing variables
d045513d	f24	p0	2024-09-22 23:54:26	Main.cpp	13	13	parsing the input cmd
d045513d	f24	p0	2024-09-22 23:54:26	Main.cpp	15	17	if the grid already exists\ndelete the grid_ptr\nset it to nullptr
d045513d	f24	p0	2024-09-22 23:54:26	Main.cpp	20	22	making the array\nsetting the k value to 1 as required from project guidelines\noutputting success if the grid does not already exist
d045513d	f24	p0	2024-09-22 23:54:26	Main.cpp	27	30	checking if inputs are positive and within array size limits set by create\nsetting state\nrecalculating potential due to the new obstacle or goal added\noutputting success if the x and y given are within array and positive
d045513d	f24	p0	2024-09-22 23:54:26	Main.cpp	69	69	Clean up
d045513d	f24	p0	2024-09-23 20:08:52	cell.cpp	2	2	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-23 20:08:52	cell.cpp	4	4	setting the constructor to default values
d045513d	f24	p0	2024-09-23 20:08:52	cell.cpp	7	7	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-23 20:08:52	cell.cpp	9	9	method for setting potential
d045513d	f24	p0	2024-09-23 20:08:52	cell.cpp	12	12	method for getting potential
d045513d	f24	p0	2024-09-23 20:08:52	cell.h	11	11	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-23 20:08:52	cell.h	14	14	Default constructor
d045513d	f24	p0	2024-09-23 20:08:52	cell.h	17	17	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-23 20:08:52	cell.h	19	20	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-23 20:08:52	cell.h	22	23	method to set the state using a boolean, 0 for goal and 1 for obstacle\nmethod to get the state value
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	6	6	declaring constructor in the cpp file
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	9	9	allocating memory for the rows
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	11	11	allocating memory for the columns
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	17	17	destructor to dynamically delete memory
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	19	19	checking if array is empty
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	21	21	deleting array of cells
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	23	23	delete array of row pointers
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	28	28	getters (accessors) , setters mutators
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	30	30	method for setting row
d045513d	f24	p0	2024-09-23 20:08:52	grid.cpp	33	33	method for getting column
d045513d	f24	p0	2024-09-23 20:08:52	grid.h	14	14	constructor to initialize all the attributes
d045513d	f24	p0	2024-09-23 20:08:52	grid.h	17	17	default constructor
d045513d	f24	p0	2024-09-23 20:08:52	grid.h	20	20	destructor
d045513d	f24	p0	2024-09-23 20:08:52	grid.h	23	23	Getters (Accessors), Setters (Mutators)
d045513d	f24	p0	2024-09-23 20:08:52	grid.h	25	26	method to set potential using a double value\nmethod to get potential value
d045513d	f24	p0	2024-09-23 20:08:52	Main.cpp	5	5	pointer to the grid class
d045513d	f24	p0	2024-09-23 20:08:52	Main.cpp	7	7	initializing variables
d045513d	f24	p0	2024-09-23 20:08:52	Main.cpp	13	13	parsing the input cmd
d045513d	f24	p0	2024-09-23 20:08:52	Main.cpp	15	17	if the grid already exists\ndelete the grid_ptr\nset it to nullptr
d045513d	f24	p0	2024-09-23 20:08:52	Main.cpp	20	22	making the array\nsetting the k value to 1 as required from project guidelines\noutputting success if the grid does not already exist
d045513d	f24	p0	2024-09-23 20:08:52	Main.cpp	27	30	checking if inputs are positive and within array size limits set by create\nsetting state\nrecalculating potential due to the new obstacle or goal added\noutputting success if the x and y given are within array and positive
d6adda26	f24	p0	2024-09-23 12:17:11	main.cpp	9	9	Handle the "CREATE" command: Initializes a grid with specified dimensions.
d6adda26	f24	p0	2024-09-23 12:17:11	main.cpp	19	19	Handle the "POINT" command: Updates the potential field based on a goal or obstacle.
d6adda26	f24	p0	2024-09-23 12:17:11	main.cpp	30	30	Handle the "MOVE" command: Outputs the potential at the specified grid coordinates.
d6adda26	f24	p0	2024-09-23 12:17:11	main.cpp	40	40	Handle the "CLEAR" command: Resets all potentials in the grid to their initial state.
d6adda26	f24	p0	2024-09-23 12:17:11	main.cpp	44	44	Handle the "UPDATE" command: Updates the constant factor 'K' used in potential calculations.
d6adda26	f24	p0	2024-09-23 12:17:11	main.cpp	54	54	Handle the "EXIT" command: Terminates the command processing loop.
d6adda26	f24	p0	2024-09-23 12:17:11	main.cpp	57	57	Handle any invalid command input.
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	4	4	Constructor
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	7	7	Destructor
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	17	17	Create Grid
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	28	28	Inital value for K
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	30	30	Allocate Memory for grid
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	35	36	Initialize potential.x to 0.0\nInitialize potential.y to 0.0
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	41	41	Clear Grid
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	45	46	Clear potential.x to 0.0\nClear potential.y to 0.0
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	51	51	Update Constant K
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	58	58	Update the potentials based on goals or obstacles
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	60	60	1 for Goal, 2 for Obstacle
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	64	64	Skip calculation for the point itself
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	71	71	Goal
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	74	74	Obstacle
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	82	82	Get potential at a specific position
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	90	90	Manually calculate Square root
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	104	104	Manually calculate power
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.cpp	106	106	Any number to the power of 0 is 1.
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.h	4	5	First potential value\nSecond potential value
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.h	12	14	Gride Dimention\nPotential Calculation Constant\nPotential's 2D Array
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.h	17	18	Constructor\nDestructor
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.h	20	24	Grid Creation\nClear Grid\nUpdates goals and obstacles\nUpdate constant\nFind potential at new position
d6adda26	f24	p0	2024-09-23 12:17:11	PotentialField.h	29	30	Getter for N\nGetter for M
d6adda26	f24	p0	2024-09-23 19:30:53	main.cpp	9	9	Handle the "CREATE" command: Initializes a grid with specified dimensions.
d6adda26	f24	p0	2024-09-23 19:30:53	main.cpp	19	19	Handle the "POINT" command: Updates the potential field based on a goal or obstacle.
d6adda26	f24	p0	2024-09-23 19:30:53	main.cpp	30	30	Handle the "MOVE" command: Outputs the potential at the specified grid coordinates.
d6adda26	f24	p0	2024-09-23 19:30:53	main.cpp	40	40	Handle the "CLEAR" command: Resets all potentials in the grid to their initial state.
d6adda26	f24	p0	2024-09-23 19:30:53	main.cpp	44	44	Handle the "UPDATE" command: Updates the constant factor 'K' used in potential calculations.
d6adda26	f24	p0	2024-09-23 19:30:53	main.cpp	54	54	Handle the "EXIT" command: Terminates the command processing loop.
d6adda26	f24	p0	2024-09-23 19:30:53	main.cpp	57	57	Handle any invalid command input.
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	4	4	Constructor
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	7	7	Destructor
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	17	17	Create Grid
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	28	28	Inital value for K
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	30	30	Allocate Memory for grid
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	35	36	Initialize potential.x to 0.0\nInitialize potential.y to 0.0
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	41	41	Clear Grid
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	45	46	Clear potential.x to 0.0\nClear potential.y to 0.0
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	51	51	Update Constant K
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	58	58	Update the potentials based on goals or obstacles
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	60	60	1 for Goal, 2 for Obstacle
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	64	64	Skip calculation for the point itself
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	71	71	Goal
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	74	74	Obstacle
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	82	82	Get potential at a specific position
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	90	90	Manually calculate Square root
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	104	104	Manually calculate power
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.cpp	106	106	Any number to the power of 0 is 1.
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.h	4	5	First potential value\nSecond potential value
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.h	12	14	Gride Dimention\nPotential Calculation Constant\nPotential's 2D Array
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.h	17	18	Constructor\nDestructor
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.h	20	24	Grid Creation\nClear Grid\nUpdates goals and obstacles\nUpdate constant\nFind potential at new position
d6adda26	f24	p0	2024-09-23 19:30:53	PotentialField.h	29	30	Getter for N\nGetter for M
d7a7a1b7	f24	p0	2024-09-19 16:06:54	main.cpp	13	13	we should always return success after creating the array
d7a7a1b7	f24	p0	2024-09-19 16:06:54	main.cpp	21	21	we check to make sure point is valid, if it is then we add the point and print success
d7a7a1b7	f24	p0	2024-09-19 16:06:54	main.cpp	37	37	first check if the point is in bounds, then we can do the move
d7a7a1b7	f24	p0	2024-09-19 16:06:54	main.cpp	51	51	if clear successful, then success
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	25	25	checking if the coordinates given are outside of the array
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	32	32	if we already have an array, deallocate it
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	47	47	allocate a new array of size N*M, N rows and M columms
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	53	53	set up each of the elements to be 0 to avoid garbage values
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	65	65	since the goal provides a negative sign in the potential value calculation, we store -1, else we store 1 for an obstacle
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	78	78	the final potiential value, it will be the sum of the potiential values in the array
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	84	84	we want to skip our current position as specificed in the document
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	88	88	get the sign of the potiential value
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	90	90	formula for getting the potiential
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	95	95	add our current potiential to the sum
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	104	104	if the array exists, clear it, else we can return false since there is nothing to clear
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.cpp	119	119	basic check to see if K is greater than 0, and set it to the new value
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.h	3	3	storing the size of the 2D array (N*M), storing the K value and the array
d7a7a1b7	f24	p0	2024-09-19 16:06:54	potentialfield.h	14	14	helper function to check if the point is out of bounds, reason for making it public is in potentialfield.cpp to handle move
d7a7a1b7	f24	p0	2024-09-19 16:22:42	main.cpp	13	13	we should always return success after creating the array
d7a7a1b7	f24	p0	2024-09-19 16:22:42	main.cpp	21	21	we check to make sure point is valid, if it is then we add the point and print success
d7a7a1b7	f24	p0	2024-09-19 16:22:42	main.cpp	37	37	first check if the point is in bounds, then we can do the move
d7a7a1b7	f24	p0	2024-09-19 16:22:42	main.cpp	51	51	if clear successful, then success
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	25	25	checking if the coordinates given are outside of the array
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	32	32	if we already have an array, deallocate it
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	47	47	allocate a new array of size N*M, N rows and M columms
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	53	53	set up each of the elements to be 0 to avoid garbage values
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	65	65	since the goal provides a negative sign in the potential value calculation, we store -1, else we store 1 for an obstacle
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	78	78	the final potiential value, it will be the sum of the potiential values in the array
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	84	84	we want to skip our current position as specificed in the document
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	88	88	get the sign of the potiential value
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	90	90	formula for getting the potiential
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	95	95	add our current potiential to the sum
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	104	104	if the array exists, clear it, else we can return false since there is nothing to clear
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.cpp	119	119	basic check to see if K is greater than 0, and set it to the new value
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.h	3	3	storing the size of the 2D array (N*M), storing the K value and the array
d7a7a1b7	f24	p0	2024-09-19 16:22:42	potentialfield.h	14	14	helper function to check if the point is out of bounds, reason for making it public is in potentialfield.cpp to handle move
d7a7a1b7	f24	p0	2024-09-21 16:11:01	main.cpp	13	13	we should always return success after creating the array
d7a7a1b7	f24	p0	2024-09-21 16:11:01	main.cpp	21	21	we check to make sure point is valid, if it is then we add the point and print success
d7a7a1b7	f24	p0	2024-09-21 16:11:01	main.cpp	37	37	first check if the point is in bounds, then we can do the move
d7a7a1b7	f24	p0	2024-09-21 16:11:01	main.cpp	51	51	if clear successful, then success
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	25	25	checking if the coordinates given are outside of the array
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	32	32	if we already have an array, deallocate it
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	47	47	allocate a new array of size N*M, N rows and M columms
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	53	53	set up each of the elements to be 0 to avoid garbage values
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	65	65	since the goal provides a negative sign in the potential value calculation, we store -1, else we store 1 for an obstacle
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	78	78	the final potiential value, it will be the sum of the potiential values in the array
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	84	84	we want to skip our current position as specificed in the document
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	88	88	get the sign of the potiential value
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	90	90	formula for getting the potiential
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	95	95	add our current potiential to the sum
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	104	104	if the array exists, clear it, else we can return false since there is nothing to clear
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.cpp	119	119	basic check to see if K is greater than 0, and set it to the new value
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.h	3	3	storing the size of the 2D array (N*M), storing the K value and the array
d7a7a1b7	f24	p0	2024-09-21 16:11:01	potentialfield.h	14	14	helper function to check if the point is out of bounds, reason for making it public is in potentialfield.cpp to handle move
d7a7a1b7	f24	p0	2024-09-23 10:52:17	main.cpp	13	13	we should always return success after creating the array
d7a7a1b7	f24	p0	2024-09-23 10:52:17	main.cpp	21	21	we check to make sure point is valid, if it is then we add the point and print success
d7a7a1b7	f24	p0	2024-09-23 10:52:17	main.cpp	37	37	first check if the point is in bounds, then we can do the move
d7a7a1b7	f24	p0	2024-09-23 10:52:17	main.cpp	51	51	if clear successful, then success
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.cpp	29	29	checking if the coordinates given are outside of the array
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.cpp	36	36	if we already have the array, deallocate it
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.cpp	52	52	allocate new arrays of size N*M, N rows and M columms
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.cpp	60	60	set up each of the elements to be 0 to avoid garbage values
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.cpp	71	71	since the goal provides a negative sign in the potential value calculation, we store -1, else we store 1 for an obstacle
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.cpp	81	81	recompute the potential values of all points with the new point
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.cpp	93	93	if the array exists, clear it, else we can return false since there is nothing to clear
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.cpp	108	108	check to see if K is greater than 0, and set it to the new value
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.cpp	113	113	recompute the potential values of all points with the new K value
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.h	3	3	storing the size of the 2D array (N*M), storing the K value and the array
d7a7a1b7	f24	p0	2024-09-23 10:52:17	potentialfield.h	17	17	helper function to check if the point is out of bounds, reason for making it public is in potentialfield.cpp to handle move
d7a7a1b7	f24	p0	2024-09-23 11:00:59	main.cpp	13	13	we should always return success after creating the array
d7a7a1b7	f24	p0	2024-09-23 11:00:59	main.cpp	21	21	we check to make sure point is valid, if it is then we add the point and print success
d7a7a1b7	f24	p0	2024-09-23 11:00:59	main.cpp	37	37	first check if the point is in bounds, then we can do the move
d7a7a1b7	f24	p0	2024-09-23 11:00:59	main.cpp	51	51	if clear successful, then success
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.cpp	29	29	checking if the coordinates given are outside of the array
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.cpp	36	36	if we already have the array, deallocate it
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.cpp	52	52	allocate new arrays of size N*M, N rows and M columms
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.cpp	60	60	set up each of the elements to be 0 to avoid garbage values
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.cpp	71	71	since the goal provides a negative sign in the potential value calculation, we store -1, else we store 1 for an obstacle
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.cpp	81	81	recompute the potential values of all points with the new point
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.cpp	93	93	if the array exists, clear it, else we can return false since there is nothing to clear
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.cpp	108	108	check to see if K is greater than 0, and set it to the new value
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.cpp	113	113	recompute the potential values of all points with the new K value
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.h	3	3	storing the size of the 2D array (N*M), storing the K value and the array
d7a7a1b7	f24	p0	2024-09-23 11:00:59	potentialfield.h	17	17	helper function to check if the point is out of bounds, reason for making it public is in potentialfield.cpp to handle move
d7a7a1b7	f24	p0	2024-09-23 15:14:01	main.cpp	13	13	we should always return success after creating the array
d7a7a1b7	f24	p0	2024-09-23 15:14:01	main.cpp	21	21	we check to make sure point is valid, if it is then we add the point and print success
d7a7a1b7	f24	p0	2024-09-23 15:14:01	main.cpp	37	37	first check if the point is in bounds, then we can do the move
d7a7a1b7	f24	p0	2024-09-23 15:14:01	main.cpp	51	51	if clear successful, then success
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	29	29	checking if the coordinates given are outside of the array
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	36	36	if we already have the array, deallocate it
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	52	52	allocate new arrays of size N*M, N rows and M columms
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	60	60	set up each of the elements to be 0 to avoid garbage values
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	71	71	since the goal provides a negative sign in the potential value calculation, we store -1, else we store 1 for an obstacle
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	81	81	recompute the potential values of all points with the new point
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	93	93	if the array exists, clear it, else we can return false since there is nothing to clear
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	108	108	check to see if K is greater than 0, and set it to the new value
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	113	113	recompute the potential values of all points with the new K value
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	124	124	loop through the array for all of the points
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.cpp	127	127	for all of the points, loop again to find the potential value for that element
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.h	3	3	storing the size of the 2D array (N*M), storing the K value and the array
d7a7a1b7	f24	p0	2024-09-23 15:14:01	potentialfield.h	17	17	helper function to check if the point is out of bounds, reason for making it public is in potentialfield.cpp to handle move
d9d50c66	f24	p0	2024-09-23 04:25:40	main.cpp	9	9	Parse inputs
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	7	7	Constructor / CREATE command
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	11	13	creates the 2d array representing the grid\narray of pointers for each row\npopulate each row with columns
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	17	17	Deconstructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	20	20	clear the potential grid array
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	23	23	clears each row of the array
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	30	30	clear the linked list of potential points
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	40	40	POINT command
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	43	43	checks if the provided coordinates are in range
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	45	45	if there isn't already a goal or obstacle at the specified cooridnates:
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	52	52	overwrite existing goal/obstacle if it already exists at the specified coordinates
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	55	55	loop through linked list to find the desired point, then overwrite info
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	70	70	MOVE command
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	73	73	checks if the provided coordinates are in range
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	78	78	CLEAR command
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	81	81	clear the linked list of potential points
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	90	90	clear the potential vectors from the grid
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	103	103	UPDATE command
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	106	106	updates k if the new value is valid
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	116	116	Function to add new Potential_Point to linked list
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	119	119	insert point at start if linked list is empty
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	123	124	pointer to current last point\nfind the pointer to the last point and add the new point to the end
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	132	132	Function to recalculate potentials throughout the grid
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	135	135	for each spot in the grid
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	140	140	first clear the existing vector there
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	143	143	if there are any points in the linked list, loop through all points and incrementally calculate the x and y potential at the current spot in the grid for each obstacle/goal
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid_Definitions.cpp	155	155	end condition
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid.hpp	8	8	Constructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid.hpp	11	11	Deconstructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid.hpp	14	14	member functions
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid.hpp	22	26	number of rows in the grid\nnumber of columns in the grid\nconstant k used in the potential equation\ndynamically allocated 2D array of Potential_Vector objects representing the direction of potential at each location in the grid\npointer to the first point in the linked list
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid.hpp	28	28	private functions for linked list
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Grid.hpp	32	32	helper functions
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Point_Definitions.cpp	4	4	Constructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Point_Definitions.cpp	9	9	Deconstructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Point.hpp	6	6	Constructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Point.hpp	9	9	Deconstructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Point.hpp	12	16	private:\nx cooridnate of the point\ny coordinate of the point\ntrue if the point is a goal, false if it is an obstacle\npointer to the next point in the linked list
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Vector_Definitions.cpp	4	4	Constructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Vector_Definitions.cpp	8	8	Deconstructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Vector.hpp	6	6	Constructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Vector.hpp	9	9	Deconstructor
d9d50c66	f24	p0	2024-09-23 04:25:40	Potential_Vector.hpp	12	14	x component of the potential vector\ny component of the potential vector\ntrue if the spot is not an obstacle or goal
d9d50c66	f24	p0	2024-09-23 16:37:00	main.cpp	9	9	Parse inputs
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	7	7	Constructor / CREATE command
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	11	13	creates the 2d array representing the grid\narray of pointers for each row\npopulate each row with columns
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	17	17	Deconstructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	20	20	clear the potential grid array
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	23	23	clears each row of the array
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	30	30	clear the linked list of potential points
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	40	40	POINT command
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	43	43	checks if the provided coordinates are in range
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	45	45	if there isn't already a goal or obstacle at the specified cooridnates:
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	52	52	overwrite existing goal/obstacle if it already exists at the specified coordinates
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	55	55	loop through linked list to find the desired point, then overwrite info
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	70	70	MOVE command
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	73	73	checks if the provided coordinates are in range
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	78	78	CLEAR command
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	81	81	clear the linked list of potential points
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	90	90	clear the potential vectors from the grid
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	104	104	UPDATE command
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	107	107	updates k if the new value is valid
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	117	117	Function to add new Potential_Point to linked list
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	120	120	insert point at start if linked list is empty
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	124	125	pointer to current last point\nfind the pointer to the last point and add the new point to the end
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	133	133	Function to recalculate potentials throughout the grid
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	136	136	for each coordinate in the grid
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	141	141	first clear the existing vector there
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	144	144	if there are any points in the linked list, loop through all points and incrementally calculate the x and y potential components at the current coordinates in the grid for each point
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid_Definitions.cpp	156	156	end condition at the end of the list
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid.hpp	8	8	Constructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid.hpp	11	11	Deconstructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid.hpp	14	14	member functions
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid.hpp	22	27	member variables\nnumber of rows in the grid\nnumber of columns in the grid\nconstant k used in the potential equation\ndynamically allocated 2D array of Potential_Vector objects representing the direction of potential at each location in the grid\npointer to the first point in the linked list
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid.hpp	29	29	private functions for linked list
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Grid.hpp	33	33	helper functions
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Point_Definitions.cpp	4	4	Constructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Point_Definitions.cpp	9	9	Deconstructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Point.hpp	6	6	Constructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Point.hpp	9	9	Deconstructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Point.hpp	12	16	member variables\nx cooridnate of the point\ny coordinate of the point\ntrue if the point is a goal, false if it is an obstacle\npointer to the next point in the linked list
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Vector_Definitions.cpp	4	4	Constructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Vector_Definitions.cpp	8	8	Deconstructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Vector.hpp	6	6	Constructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Vector.hpp	9	9	Deconstructor
d9d50c66	f24	p0	2024-09-23 16:37:00	Potential_Vector.hpp	12	15	member variables\nx component of the potential vector\ny component of the potential vector\ntrue if the spot is not an obstacle or goal
d9d50c66	f24	p0	2024-09-23 18:31:07	main.cpp	9	9	Parse inputs
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	7	7	Constructor / CREATE command
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	11	13	creates the 2d array representing the grid\narray of pointers for each row\npopulate each row with columns
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	17	17	Deconstructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	20	20	clear the potential grid array
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	23	23	clears each row of the array
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	30	30	clear the linked list of potential points
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	40	40	POINT command
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	43	43	checks if the provided coordinates are in range
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	45	45	if there isn't already a goal or obstacle at the specified cooridnates:
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	52	52	overwrite existing goal/obstacle if it already exists at the specified coordinates
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	55	55	loop through linked list to find the desired point, then overwrite info
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	70	70	MOVE command
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	73	73	checks if the provided coordinates are in range
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	78	78	CLEAR command
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	81	81	clear the linked list of potential points
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	90	90	clear the potential vectors from the grid
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	104	104	UPDATE command
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	107	107	updates k if the new value is valid
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	117	117	Function to add new Potential_Point to linked list
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	120	120	insert point at start if linked list is empty
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	124	125	pointer to current last point\nfind the pointer to the last point and add the new point to the end
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	133	133	Function to recalculate potentials throughout the grid
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	136	136	for each coordinate in the grid
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	141	141	first clear the existing vector there
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	144	144	if there are any points in the linked list, loop through all points and incrementally calculate the x and y potential components at the current coordinates in the grid for each point
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid_Definitions.cpp	156	156	end condition at the end of the list
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid.hpp	8	8	Constructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid.hpp	11	11	Deconstructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid.hpp	14	14	member functions
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid.hpp	22	27	member variables\nnumber of rows in the grid\nnumber of columns in the grid\nconstant k used in the potential equation\ndynamically allocated 2D array of Potential_Vector objects representing the direction of potential at each location in the grid\npointer to the first point in the linked list
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid.hpp	29	29	private functions for linked list
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Grid.hpp	33	33	helper functions
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Point_Definitions.cpp	4	4	Constructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Point_Definitions.cpp	9	9	Deconstructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Point.hpp	6	6	Constructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Point.hpp	9	9	Deconstructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Point.hpp	12	16	member variables\nx cooridnate of the point\ny coordinate of the point\ntrue if the point is a goal, false if it is an obstacle\npointer to the next point in the linked list
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Vector_Definitions.cpp	4	4	Constructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Vector_Definitions.cpp	8	8	Deconstructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Vector.hpp	6	6	Constructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Vector.hpp	9	9	Deconstructor
d9d50c66	f24	p0	2024-09-23 18:31:07	Potential_Vector.hpp	12	15	member variables\nx component of the potential vector\ny component of the potential vector\ntrue if the spot is not an obstacle or goal
da1bba17	f24	p0	2024-09-22 00:00:00	main.cpp	11	11	CREATE command
da1bba17	f24	p0	2024-09-22 00:00:00	main.cpp	15	15	POINT command
da1bba17	f24	p0	2024-09-22 00:00:00	main.cpp	20	20	MOVE command
da1bba17	f24	p0	2024-09-22 00:00:00	main.cpp	24	24	CLEAR command
da1bba17	f24	p0	2024-09-22 00:00:00	main.cpp	26	26	UPDATE command
da1bba17	f24	p0	2024-09-22 00:00:00	main.cpp	30	30	EXIT command
da1bba17	f24	p0	2024-09-22 00:00:00	Node.h	12	12	Constructor
da1bba17	f24	p0	2024-09-22 00:00:00	Node.h	15	15	Getters
da1bba17	f24	p0	2024-09-22 00:00:00	Node.h	21	21	Setters
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	6	6	Constructor definition
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	14	14	Destructor definition
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	19	19	Create Command: Create a new field
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	30	30	Point Command: Add a goal or obstacle to the linked list
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	39	39	Goals
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	41	41	Obstacles
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	45	45	Check if the point already exists and overwrite it
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	56	56	If point doesn't exist, add a new one
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	63	63	Move Command: Move the robot and display its potential
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	71	71	Print the result with 6 decimal places
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	76	76	Compute the total potential at a point
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	94	94	Clear Command: Clear field
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.cpp	115	115	Update Command: Update K
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.h	14	14	Constructor declaration
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.h	17	17	Destructor declaration
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.h	20	20	Create the field
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.h	23	23	Add a goal or obstacle
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.h	26	26	Get the potential at a point
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.h	29	29	Move the robot
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.h	32	32	Clear the field
da1bba17	f24	p0	2024-09-22 00:00:00	PotentialField.h	35	35	Method to update K
da1bba17	f24	p0	2024-09-22 00:27:20	Node.h	9	9	Constructor
da1bba17	f24	p0	2024-09-22 00:27:20	Node.h	12	12	Getters
da1bba17	f24	p0	2024-09-22 00:27:20	Node.h	18	18	Setters
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	7	7	Constructor definition
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	15	15	Destructor definition
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	18	18	Create Command: Create a new field
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	29	29	Point Command: Add a goal or obstacle to the linked list
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	37	37	Goals
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	39	39	Obstacles
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	43	43	Check if the point already exists and overwrite it
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	53	53	If point doesn't exist, add a new one
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	60	60	Move Command: Move the robot and display its potential
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	68	68	Print the result with 6 decimal places
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	73	73	Compute the total potential at a point
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	91	91	Clear Command: Clear field
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.cpp	111	111	Update Command: Update K
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.h	13	13	Constructor declaration
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.h	16	16	Destructor declaration
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.h	19	19	Create the field
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.h	22	22	Add a goal or obstacle
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.h	25	25	Get the potential at a point
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.h	28	28	Move the robot
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.h	31	31	Clear the field
da1bba17	f24	p0	2024-09-22 00:27:20	PotentialField.h	34	34	Method to update K
da1bba17	f24	p0	2024-09-22 15:13:31	PotentialField.cpp	6	6	Constructor definition
da1bba17	f24	p0	2024-09-22 15:13:31	PotentialField.cpp	9	9	Destructor definition
da1bba17	f24	p0	2024-09-22 15:13:31	PotentialField.cpp	12	12	CREATE Command: Create a new field
da1bba17	f24	p0	2024-09-22 15:13:31	PotentialField.cpp	21	21	POINT Command: Add a goal or obstacle to the linked list
da1bba17	f24	p0	2024-09-22 15:13:31	PotentialField.cpp	44	44	MOVE Command: Move the robot and display its potential
da1bba17	f24	p0	2024-09-22 15:13:31	PotentialField.cpp	59	59	Compute the total potential at a point
da1bba17	f24	p0	2024-09-22 15:13:31	PotentialField.cpp	81	81	CLEAR Command: Clear the field
da1bba17	f24	p0	2024-09-22 15:13:31	PotentialField.cpp	97	97	UPDATE Command: Update K
da1bba17	f24	p0	2024-09-22 15:13:31	PotentialField.cpp	114	114	Update all potentials based on new K value
da1bba17	f24	p0	2024-09-22 16:28:59	PotentialField.cpp	6	6	Constructor definition
da1bba17	f24	p0	2024-09-22 16:28:59	PotentialField.cpp	9	9	Destructor definition
da1bba17	f24	p0	2024-09-22 16:28:59	PotentialField.cpp	12	12	CREATE Command: Create a new field
da1bba17	f24	p0	2024-09-22 16:28:59	PotentialField.cpp	21	21	POINT Command: Add a goal or obstacle to the linked list
da1bba17	f24	p0	2024-09-22 16:28:59	PotentialField.cpp	44	44	MOVE Command: Move the robot and display its potential
da1bba17	f24	p0	2024-09-22 16:28:59	PotentialField.cpp	59	59	Compute the total potential at a point
da1bba17	f24	p0	2024-09-22 16:28:59	PotentialField.cpp	80	80	CLEAR Command: Clear the field
da1bba17	f24	p0	2024-09-22 16:28:59	PotentialField.cpp	96	96	UPDATE Command: Update K
da1bba17	f24	p0	2024-09-22 16:28:59	PotentialField.cpp	113	113	Update all potentials based on new K value
da1bba17	f24	p0	2024-09-23 10:27:52	Node.hpp	9	9	Constructor
da1bba17	f24	p0	2024-09-23 10:27:52	Node.hpp	12	12	Getters
da1bba17	f24	p0	2024-09-23 10:27:52	Node.hpp	18	18	Setters
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.cpp	6	6	Constructor definition
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.cpp	9	9	Destructor definition
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.cpp	12	12	CREATE Command: Create a new field
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.cpp	21	21	POINT Command: Add a goal or obstacle to the linked list
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.cpp	44	44	MOVE Command: Move the robot and display its potential
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.cpp	59	59	Compute the total potential at a point
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.cpp	80	80	CLEAR Command: Clear the field
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.cpp	96	96	UPDATE Command: Update K
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.cpp	113	113	Helper function to update the potentials of all nodes
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.hpp	10	10	Helper function to update all potentials
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.hpp	13	14	Constructor\nDestructor
da1bba17	f24	p0	2024-09-23 10:27:52	PotentialField.hpp	16	21	CREATE Command\nPOINT Command\nMOVE Command\nHelper function to get potential at a point\nCLEAR Command\nUPDATE Command
da1bba17	f24	p0	2024-10-05 22:11:29	Node.hpp	9	9	Constructor
da1bba17	f24	p0	2024-10-05 22:11:29	Node.hpp	12	12	Getters
da1bba17	f24	p0	2024-10-05 22:11:29	Node.hpp	18	18	Setters
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.cpp	5	5	Constructor definition
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.cpp	8	8	Destructor definition
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.cpp	11	11	CREATE Command: Create a new field
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.cpp	20	20	POINT Command: Add a goal or obstacle to the linked list
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.cpp	43	43	MOVE Command: Move the robot and display its potential
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.cpp	58	58	Compute the total potential at a point
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.cpp	79	79	CLEAR Command: Clear the field
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.cpp	95	95	UPDATE Command: Update K
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.cpp	112	112	Helper function to update the potentials of all nodes
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.hpp	10	10	Helper function to update all potentials
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.hpp	13	14	Constructor\nDestructor
da1bba17	f24	p0	2024-10-05 22:11:29	PotentialField.hpp	16	21	CREATE Command\nPOINT Command\nMOVE Command\nHelper function to get potential at a point\nCLEAR Command\nUPDATE Command
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	5	5	Constructor
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	7	7	Initialize grid to nullptr
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	11	11	Initialize with null characters
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	15	15	Destructor
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	28	28	Create grid
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	33	33	Delete existing grid if it exists
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	41	42	Allocate memory for a new grid\nrows
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	44	45	columns\nInitialize with 0.0
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	50	50	Point function
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	69	69	Move function
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	73	73	Out of bounds
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	75	75	Print the value at the specified location
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	79	79	Clear function
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	93	93	Update function
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	98	98	Update K value
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.cpp	101	101	Scale the grid values
dd9eb21b	f24	p0	2024-09-22 21:07:11	potential_grid.h	9	13	Array dimensions\nPoint coordinates\nArray of goals and obstacles\nPotential grid\nScaling factor
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	5	5	Constructor
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	7	7	Initialize grid to nullptr
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	11	11	Initialize with null characters
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	15	15	Destructor
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	18	18	Free goob array
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	20	20	Free the outer array
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	22	22	Check if grid is allocated
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	24	24	Free grid rows
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	26	26	Free the outer grid array
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	30	30	Create grid
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	35	35	Delete existing grid if it exists
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	40	40	Free previously allocated memory
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	43	44	Allocate memory for a new grid\nrows
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	46	47	columns\nInitialize with 0.0
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	58	58	Skip the point itself
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	78	78	Out of bounds
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	81	81	Remove abs() to allow negative values
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	83	83	Convert the value to a string with 6 decimal places
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	87	87	Output the value twice
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	93	93	Clear function
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	112	112	Update K value
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.cpp	115	115	Scale the grid values
dd9eb21b	f24	p0	2024-09-22 22:14:20	potential_grid.h	9	13	Array dimensions\nPoint coordinates\nArray of goals and obstacles\nPotential grid\nScaling factor
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	5	5	Constructor
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	15	15	Destructor
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	17	17	Clean up goals and obstacles array
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	24	24	Clean up the potential grid
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	33	33	Create grid
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	35	35	Delete existing grid if it exists
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	43	43	Delete existing goob array
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	49	49	Update dimensions
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	53	53	Create a new grid
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	57	57	Initialize with 0.0
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	60	60	Recreate goob array
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	70	70	Point function
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	77	77	Skip the point itself
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	94	94	Move function
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	106	106	Output the value twice
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	111	111	Clear function
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	117	117	Clear grid and goob arrays
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	119	120	Reset grid to 0.0\nReset goob to '\\0'
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	125	125	Update function
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.cpp	131	131	Update K value
dd9eb21b	f24	p0	2024-09-23 20:07:33	potential_grid.h	9	13	Array dimensions\nPoint coordinates\nArray of goals and obstacles\nPotential grid\nScaling factor
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	5	5	Constructor - intialize an empty 2d array where each cell holds the value of 0
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	10	10	for every row create a new column
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	16	16	Destructor -
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	18	18	Delete values within the array of goals and obstacles
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	25	25	Delete values within grid
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	35	35	Create grid
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	38	38	Delete existing grid if it exists
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	46	46	Delete existing goob array
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	52	52	Update dimensions
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	56	56	Create a new grid
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	60	60	Intialize each cell with the value 0
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	71	71	Recreate goob (goals + obstacles) array
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	81	81	Point function
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	86	86	Recalculate the entire potential field
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	89	89	set potential back to 0
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	92	93	dont put value in empty cells\ndont put value in the point itself
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	97	98	avoid any errors by not doing division by zero\nAvoid division by zero
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	101	101	if there is a goal
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	104	104	if there is an obstacle
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	116	116	Move function
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	136	136	Output the value and the type of point
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	147	147	Clear function
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	153	153	Clear grid and goob arrays
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	155	156	Reset grid to 0.0\nReset goob to '\\0'
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	161	161	Update function
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.cpp	167	167	Update K value
dd9eb21b	f24	p0	2024-09-23 21:15:35	potential_grid.h	9	13	Array dimensions\nPoint coordinates\nArray of goals and obstacles\nPotential grid\nScaling factor
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	5	5	Constructor - intialize an empty 2d array where each cell holds the value of 0
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	10	10	for every row create a new column
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	16	16	Destructor -
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	18	18	Delete values within the array of goals and obstacles
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	25	25	Delete values within grid
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	35	35	Create grid
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	37	37	Delete existing grid if it exists
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	45	45	Delete existing goob array
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	51	51	Update dimensions
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	55	55	Create a new grid
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	59	59	Initialize with 0.0
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	69	69	Recreate goob (goals + obstacles) array
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	79	79	Point function
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	84	84	Recalculate the entire potential field
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	87	87	Reset the potential
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	90	91	Skip empty cells\nSkip the point itself
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	95	95	Avoid division by zero
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	111	111	Move function
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	130	130	Output the value and the type of point
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	142	142	Clear function
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	148	148	Clear grid and goob arrays
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	150	151	Reset grid to 0.0\nReset goob to '\\0'
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	156	156	Update function
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.cpp	162	162	Update K value
dd9eb21b	f24	p0	2024-09-23 21:26:59	potential_grid.h	9	13	Array dimensions\nPoint coordinates\nArray of goals and obstacles\nPotential grid\nScaling factor
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	5	5	Constructor
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	15	15	Destructor
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	17	17	Clean up goals and obstacles array
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	24	24	Clean up the potential grid
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	33	33	Create grid
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	35	35	Delete existing grid if it exists
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	43	43	Delete existing goob array
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	49	49	Update dimensions
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	53	53	Create a new grid
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	57	57	Initialize with 0.0
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	60	60	Recreate goob array
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	70	70	Point function
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	77	77	Skip the point itself
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	94	94	Move function
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	106	106	Output the value twice
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	111	111	Clear function
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	117	117	Clear grid and goob arrays
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	119	120	Reset grid to 0.0\nReset goob to '\\0'
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	125	125	Update function
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.cpp	131	131	Update K value
dd9eb21b	f24	p0	2024-09-23 21:36:24	potential_grid.h	9	13	Array dimensions\nPoint coordinates\nArray of goals and obstacles\nPotential grid\nScaling factor
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	5	5	Constructor
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	15	15	Destructor
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	17	17	Clean up goals and obstacles array
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	24	24	Clean up the potential grid
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	33	33	Create grid
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	35	35	Delete existing grid if it exists
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	43	43	Delete existing goob array
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	49	49	Update dimensions
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	53	53	Create a new grid
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	57	57	Initialize with 0.0
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	68	68	Recreate goob array
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	78	78	Point function
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	85	85	Skip the point itself
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	102	102	Move function
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	121	121	Output the value twice
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	126	126	Clear function
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	132	132	Clear grid and goob arrays
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	134	135	Reset grid to 0.0\nReset goob to '\\0'
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	140	140	Update function
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.cpp	146	146	Update K value
dd9eb21b	f24	p0	2024-09-23 22:09:43	potential_grid.h	9	13	Array dimensions\nPoint coordinates\nArray of goals and obstacles\nPotential grid\nScaling factor
deb14f4a	f24	p0	2024-09-23 09:02:00	grid.cpp	112	112	Calculate every cell's value
deb14f4a	f24	p0	2024-09-23 09:02:00	grid.cpp	118	118	Search through the grid to find obstacles/goals
e0173775	f24	p0	2024-09-19 19:05:58	potential_field_driver.cpp	21	21	potential_field->printgrid(); //debugging
e0173775	f24	p0	2024-09-19 19:05:58	potential_field_driver.cpp	31	31	potential_field->printgrid(); //debugging
e0173775	f24	p0	2024-09-19 19:05:58	potential_field_driver.cpp	47	47	debugging
e0173775	f24	p0	2024-09-19 19:05:58	potential_field_driver.cpp	49	49	potential_field->printgrid(); //debugging
e0173775	f24	p0	2024-09-19 19:05:58	potential_field_driver.cpp	60	60	potential_field->printgrid(); //debugging
e0173775	f24	p0	2024-09-19 19:05:58	potential_field_driver.cpp	68	69	Debugging\nstd::cout << "Invalid command. Exiting..." << std::endl;
e0173775	f24	p0	2024-09-19 19:05:58	potential_field_driver.cpp	74	74	Clean up memory
e0173775	f24	p0	2024-09-19 19:05:58	potential_field_driver.cpp	77	77	std::cout << "Field deleted" << std::endl;
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.cpp	7	7	Create an array of integer pointers, which will point to the respective row array
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.cpp	11	11	allocate memory to an array of vectors
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.cpp	24	24	Changing the k value of the vectors
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.cpp	26	26	updates value
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.cpp	32	32	updates current k value of the grid
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.cpp	40	40	assuming that the point is inside the grid
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.cpp	52	52	Calculating the potential difference
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.cpp	61	61	already is the same type
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.cpp	69	69	debugging
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.h	19	19	pass the coordinates of the vector
e0173775	f24	p0	2024-09-19 19:05:58	potential_field.h	22	22	debugging
e0173775	f24	p0	2024-09-19 19:05:58	vector.cpp	5	6	Constructors\ninitializing all field potentials to be 0
e0173775	f24	p0	2024-09-19 19:05:58	vector.cpp	13	13	Operator overloaders
e0173775	f24	p0	2024-09-19 19:05:58	vector.cpp	32	32	debugging
e0173775	f24	p0	2024-09-19 19:05:58	vector.h	13	13	Overloaders
e0173775	f24	p0	2024-09-19 19:05:58	vector.h	18	18	debugging
e0173775	f24	p0	2024-09-19 20:48:46	potential_field_driver.cpp	21	21	potential_field->printgrid(); //debugging
e0173775	f24	p0	2024-09-19 20:48:46	potential_field_driver.cpp	31	31	potential_field->printgrid(); //debugging
e0173775	f24	p0	2024-09-19 20:48:46	potential_field_driver.cpp	47	47	debugging
e0173775	f24	p0	2024-09-19 20:48:46	potential_field_driver.cpp	49	49	potential_field->printgrid(); //debugging
e0173775	f24	p0	2024-09-19 20:48:46	potential_field_driver.cpp	60	60	potential_field->printgrid(); //debugging
e0173775	f24	p0	2024-09-19 20:48:46	potential_field_driver.cpp	68	69	Debugging\nstd::cout << "Invalid command. Exiting..." << std::endl;
e0173775	f24	p0	2024-09-19 20:48:46	potential_field_driver.cpp	74	74	Clean up memory
e0173775	f24	p0	2024-09-19 20:48:46	potential_field_driver.cpp	77	77	std::cout << "Field deleted" << std::endl;
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.cpp	7	7	Create an array of integer pointers, which will point to the respective row array
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.cpp	11	11	allocate memory to an array of vectors
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.cpp	24	24	Changing the k value of the vectors
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.cpp	26	26	updates value
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.cpp	32	32	updates current k value of the grid
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.cpp	40	40	assuming that the point is inside the grid
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.cpp	52	52	Calculating the potential difference
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.cpp	61	61	already is the same type
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.cpp	69	69	debugging
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.h	19	19	pass the coordinates of the vector
e0173775	f24	p0	2024-09-19 20:48:46	potential_field.h	22	22	debugging
e0173775	f24	p0	2024-09-19 20:48:46	vector.cpp	5	6	Constructors\ninitializing all field potentials to be 0
e0173775	f24	p0	2024-09-19 20:48:46	vector.cpp	13	13	Operator overloaders
e0173775	f24	p0	2024-09-19 20:48:46	vector.cpp	32	32	debugging
e0173775	f24	p0	2024-09-19 20:48:46	vector.h	13	13	Overloaders
e0173775	f24	p0	2024-09-19 20:48:46	vector.h	18	18	debugging
e0173775	f24	p0	2024-09-23 18:28:21	potential_field_driver.cpp	42	42	Clean up memory
e0173775	f24	p0	2024-09-23 18:28:21	potential_field.cpp	7	7	Create an array of integer pointers, which will point to the respective row array
e0173775	f24	p0	2024-09-23 18:28:21	potential_field.cpp	11	11	allocate memory to an array of vectors
e0173775	f24	p0	2024-09-23 18:28:21	potential_field.cpp	47	47	If the update makes no change to the grid
e0173775	f24	p0	2024-09-23 18:28:21	potential_field.cpp	53	53	If there has been a change
e0173775	f24	p0	2024-09-23 18:28:21	potential_field.cpp	80	80	updates value
e0173775	f24	p0	2024-09-23 18:28:21	potential_field.cpp	86	86	updates current k value of the grid
e0173775	f24	p0	2024-09-23 18:28:21	potential_field.cpp	110	110	debugging
e0173775	f24	p0	2024-09-23 18:28:21	potential_field.h	23	23	debugging
e0173775	f24	p0	2024-09-23 18:28:21	vector.cpp	5	6	Constructors\ninitializing all field potentials to be 0
e0173775	f24	p0	2024-09-23 18:28:21	vector.cpp	13	13	Operator overloaders
e0173775	f24	p0	2024-09-23 18:28:21	vector.cpp	38	38	debugging
e0173775	f24	p0	2024-09-23 18:28:21	vector.h	13	13	Overloaders
e0173775	f24	p0	2024-09-23 18:28:21	vector.h	19	19	debugging
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	23	23	entering the commands
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	25	25	for false inputs, move to next line
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	30	30	take in appropriate amount of args!
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	32	32	take input
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	37	37	create array
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	53	53	CLEAR command
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	60	60	UPDATE command
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	64	64	updates the value of k
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	67	67	EXIT command
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	69	69	leaves loop
e0a4a80f	f24	p0	2024-09-23 17:15:46	main.cpp	74	74	deleting the field and setting the field to nullptr to avoid memory leaks
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	5	5	Constructor
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	8	8	Set the dimensions
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	12	12	default constant K (assume default as 1.0, can be changed later via set_k)
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	21	21	initialize all potentials to 0
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	33	33	Destructor
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	36	36	Deallocate the 2D array
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	47	47	Add a goal or obstacle at (x, y)
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	50	50	Logic to add a point (goal or obstacle)
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	54	54	invalid
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	59	59	check
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	73	73	Find the direction the robot should move from (x, y)
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	76	76	Logic to calculate movement direction
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	90	90	preventing divide-by-0 error
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	94	94	if goal, obstacle_map[x][y] = -1, else 1
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	100	100	print
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	104	104	Clear the entire grid
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	107	108	Logic to reset the grid\n2 for loops; for each element, set to 0 and move on
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	119	119	Set the value of K
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.cpp	122	122	Logic to set the constant K
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.h	11	11	Constructor
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.h	14	14	Destructor
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.h	17	17	Member functions
e0a4a80f	f24	p0	2024-09-23 17:15:46	potential_field.h	24	24	POTENTIAL_FIELD_H
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	1	2	Including libraries and files\nHeader file
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	8	10	Creating variable called "commands" to hold user commands\nCheck to see if the loop has already started\nPointer to a potential_field object, initialized to nullptr, avoiding memory leaks
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	12	12	This is a loop to continuously receive user commands, always running as set to true
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	14	14	If the loop has started, clear the input buffer to discard leftover input
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	16	18	Clear the error\nCreating a temporary variable named trash to hold discarded input\nTaking out the trash lol
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	20	20	Set started to true after the first loop iteration, so on the second go, the error can be caught
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	23	28	Read user command\nIf the input fails, clear the error, discard input, and continue\nClear the error\nCreating a temporary variable named trash to hold discarded input\nTaking out the trash again lol\nSkip to the next loop iteration to allow continued input
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	33	33	Create command
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	36	36	Dimensions for the field
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	38	39	If a field already exists, delete it to avoid memory leaks\nDelete the field, however don't dealocate the memory, as you are going to now create new field
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	41	41	Create a new potential_field object with the given dimensions
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	43	43	Move command
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	46	46	Read the coordinates
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	48	48	Finds the potential at the given coordinates
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	50	50	Point command
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	52	55	Coordinates of the point\nType of point\nRead the point type and coordinates\nAdd the point to the field using the add_point method
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	57	57	Update command
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	60	61	Reads the new value of 'k'\nSet the value of 'k' in the field using the set_k method
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	63	63	Clear command
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	65	65	If the field does not exist, print a failure message
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	68	68	Otherwise, clear the field
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	71	71	Exit command
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	73	73	Breaks out of the loop
e0a4a80f	f24	p0	2024-09-23 18:42:55	main.cpp	77	80	Clean up memory before exiting the program\nDelete the dynamically allocated potential_field object\nSet the pointer to nullptr to avoid memory leaks\nReturn 1 to indicate successful execution
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	1	2	Including libraries and files\nHeader file
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	7	7	Constructor, initializes the grid size (n x m), sets default p value (K), and allocates memory
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	10	12	Number of columns\nNumber of rows\nDefault p value
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	14	14	Dynamically allocating memory for the 2D obstacle_map array as said in documentation
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	21	21	Initializing the obstacle_map with 0, avoiding any obstacles
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	26	26	No obstacles still
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	32	32	Destructor and frees the dynamically allocated memory to avoid memory leaks
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	35	35	Checking that obstacle_map was initialized
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	39	39	Deleting each row of the map
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	41	41	Deleting the array itself now
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	45	47	Adds a point to the obstacle_map based on its type ('G' for goal, 'O' for obstacle)\nt - 'G' (goal) or 'O' (obstacle)\nx, y - coordinates of the point
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	50	50	Check if the point is within valid bounds
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	53	53	Message if out of bounds
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	57	57	Adding a goal point with value -1
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	60	61	Marking coordinate as goal\nConfirmation message of achieving goal
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	63	63	Adding an obstacle point with value 1
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	66	67	similarly, marking this coordinate as obstacle\nConfirmation message of achieving obstacle
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	71	71	Computes the potential field at a specific point (x, y) by summing contributions from all other points in the grid based on their distance and type.
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	74	74	Checking if the point is within bounds
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	77	77	Out-of-bounds error
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	81	81	Total potential field value at point (x, y)
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	83	83	Iterate through the grid to compute potential contributions from each point, starting net value at 0.0
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	90	90	Skip the point itself
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	94	96	Calculate the potential value contribution from point (xg, yg)\nDistance between (x, y) and (xg, yg) is sqrt((x - xg)^2 + (y - yg)^2)\nBasically use the formula in the documentation
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	98	98	Add to total potential, getting net potential value
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	102	102	Output the net calculated potential field value
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	106	106	Resets the obstacle_map by clearing all points, setting values to 0
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	109	109	Set all points in the grid to 0 (no obstacles or goals)
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	117	117	Confirmation message
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	120	120	Sets a new value for the potential field constant K
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	123	123	Ensure the constant is positive
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	126	127	Set the new value of K\nConfirmation message
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.cpp	131	131	Invalid value error
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.h	6	8	array for potential\nconstant for potential field calculations\ndimensions of the grid
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.h	11	11	Constructor
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.h	14	14	Destructor
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.h	17	17	Member functions
e0a4a80f	f24	p0	2024-09-23 18:42:55	potential_field.h	24	24	POTENTIAL_FIELD_H
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	1	2	Including libraries and files\nHeader file
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	8	10	Creating variable called "commands" to hold user commands\nCheck to see if the loop has already started\nPointer to a potential_field object, initialized to nullptr, avoiding memory leaks
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	12	12	This is a loop to continuously receive user commands, always running as set to true
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	14	14	If the loop has started, clear the input buffer to discard leftover input
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	16	18	Clear the error\nCreating a temporary variable named trash to hold discarded input\nTaking out the trash lol
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	20	20	Set started to true after the first loop iteration, so on the second go, the error can be caught
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	23	28	Read user command\nIf the input fails, clear the error, discard input, and continue\nClear the error\nCreating a temporary variable named trash to hold discarded input\nTaking out the trash again lol\nSkip to the next loop iteration to allow continued input
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	31	31	Create command
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	34	34	Dimensions for the field
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	36	37	If a field already exists, delete it to avoid memory leaks\nDelete the field, however don't dealocate the memory, as you are going to now create new field
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	39	39	Create a new potential_field object with the given dimensions
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	41	41	Move command
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	44	44	Read the coordinates
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	46	46	Finds the potential at the given coordinates
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	48	48	Point command
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	50	53	Coordinates of the point\nType of point\nRead the point type and coordinates\nAdd the point to the field using the add_point method
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	55	55	Update command
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	58	59	Reads the new value of 'k'\nSet the value of 'k' in the field using the set_k method
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	61	61	Clear command
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	63	63	If the field does not exist, print a failure message
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	66	66	Otherwise, clear the field
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	69	69	Exit command
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	71	71	Breaks out of the loop
e0a4a80f	f24	p0	2024-09-23 19:13:47	main.cpp	75	78	Clean up memory before exiting the program\nDelete the dynamically allocated potential_field object\nSet the pointer to nullptr to avoid memory leaks\nReturn 1 to indicate successful execution
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	1	2	Including libraries and files\nHeader file
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	7	7	Constructor, initializes the grid size (n x m), sets default p value (K), and allocates memory
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	10	12	Number of columns\nNumber of rows\nDefault p value
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	14	14	Dynamically allocating memory for the 2D obsmap array as said in documentation
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	21	21	Initializing the obsmap with 0, avoiding any obstacles
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	26	26	No obstacles still
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	32	32	Destructor and frees the dynamically allocated memory to avoid memory leaks
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	35	35	Checking that obsmap was initialized
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	39	39	Deleting each row of the map
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	41	41	Deleting the array itself now
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	45	47	Adds a point to the obsmap based on its type ('G' for goal, 'O' for obstacle)\nt - 'G' (goal) or 'O' (obstacle)\nx, y - coordinates of the point
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	50	50	Check if the point is within valid bounds
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	53	53	Message if out of bounds
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	57	57	Adding a goal point with value -1
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	60	61	Marking coordinate as goal\nConfirmation message of achieving goal
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	63	63	Adding an obstacle point with value 1
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	66	67	similarly, marking this coordinate as obstacle\nConfirmation message of achieving obstacle
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	71	71	Computes the potential field at a specific point (x, y) by summing contributions from all other points in the grid based on their distance and type.
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	74	74	Checking if the point is within bounds
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	77	77	Out-of-bounds error
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	81	81	Total potential field value at point (x, y)
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	83	83	Iterate through the grid to compute potential contributions from each point, starting net value at 0.0
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	90	90	Skip the point itself
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	94	96	Calculate the potential value contribution from point (xGoal, yGoal)\nDistance between (x, y) and (xGoal, yGoal) is sqrt((x - xGoal)^2 + (y - yGoal)^2)\nBasically use the formula in the documentation
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	98	98	Add to total potential, getting net potential value
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	102	102	Output the net calculated potential field value
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	106	106	Resets the obsmap by clearing all points, setting values to 0
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	109	109	Set all points in the grid to 0 (no obstacles or goals)
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	117	117	Confirmation message
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	120	120	Sets a new value for the potential field constant K
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	123	123	Ensure the constant is positive
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	126	127	Set the new value of K\nConfirmation message
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.cpp	131	131	Invalid value error
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.h	6	8	Array for potential field\nValue for potential field calculations\nDimensions of the map
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.h	11	11	Constructor
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.h	14	14	Destructor
e0a4a80f	f24	p0	2024-09-23 19:13:47	potential_field.h	17	21	Functions\nMember function for adding points to the grid for obstacles and goals\nMember function for goal path\nMember function for clearing\nMember function for setting potential
e0bea4ca	f24	p0	2024-09-20 22:18:48	grid.cpp	5	7	\nCreate columns for each row
e0bea4ca	f24	p0	2024-09-20 22:18:48	grid.cpp	9	9	Initialize each Point as empty 'E'
e0bea4ca	f24	p0	2024-09-20 22:18:48	grid.h	7	7	Forward declaration of Point class
e0bea4ca	f24	p0	2024-09-20 22:18:48	grid.h	16	17	Constructor for grid\nDestructor for grid
e0bea4ca	f24	p0	2024-09-20 22:18:48	grid.h	19	20	Method to clear the grid\nMethod to get point from grid at point x and y
e0bea4ca	f24	p0	2024-09-20 22:18:48	grid.h	23	23	GRID_H
e0bea4ca	f24	p0	2024-09-20 22:18:48	main.cpp	3	4	Include Grid class\nInclude Point class
e0bea4ca	f24	p0	2024-09-20 22:18:48	point.cpp	8	8	Finds the potential of the point
e0bea4ca	f24	p0	2024-09-20 22:18:48	point.cpp	36	36	Inserts a point into the grid
e0bea4ca	f24	p0	2024-09-20 22:18:48	point.h	8	8	Forward declaration of Grid class to avoid circular dependency
e0bea4ca	f24	p0	2024-09-20 22:18:48	point.h	17	17	Default constructor
e0bea4ca	f24	p0	2024-09-20 22:18:48	point.h	29	29	POINT_H
e0bea4ca	f24	p0	2024-09-20 22:32:19	grid.cpp	5	7	\nCreate columns for each row
e0bea4ca	f24	p0	2024-09-20 22:32:19	grid.cpp	9	9	Initialize each Point as empty 'E'
e0bea4ca	f24	p0	2024-09-20 22:32:19	grid.h	7	7	Forward declaration of Point class
e0bea4ca	f24	p0	2024-09-20 22:32:19	grid.h	16	17	Constructor for grid\nDestructor for grid
e0bea4ca	f24	p0	2024-09-20 22:32:19	grid.h	19	20	Method to clear the grid\nMethod to get point from grid at point x and y
e0bea4ca	f24	p0	2024-09-20 22:32:19	grid.h	23	23	GRID_H
e0bea4ca	f24	p0	2024-09-20 22:32:19	main.cpp	3	4	Include Grid class\nInclude Point class
e0bea4ca	f24	p0	2024-09-20 22:32:19	point.cpp	8	8	Finds the potential of the point
e0bea4ca	f24	p0	2024-09-20 22:32:19	point.cpp	36	36	Inserts a point into the grid
e0bea4ca	f24	p0	2024-09-20 22:32:19	point.h	8	8	Forward declaration of Grid class to avoid circular dependency
e0bea4ca	f24	p0	2024-09-20 22:32:19	point.h	17	17	Default constructor
e0bea4ca	f24	p0	2024-09-20 22:32:19	point.h	29	29	POINT_H
e0bea4ca	f24	p0	2024-09-22 15:08:20	grid.cpp	5	7	\nCreate columns for each row
e0bea4ca	f24	p0	2024-09-22 15:08:20	grid.cpp	9	9	Initialize each Point as empty 'E'
e0bea4ca	f24	p0	2024-09-22 15:08:20	grid.h	7	7	Forward declaration of Point class
e0bea4ca	f24	p0	2024-09-22 15:08:20	grid.h	16	17	Constructor for grid\nDestructor for grid
e0bea4ca	f24	p0	2024-09-22 15:08:20	grid.h	19	20	Method to clear the grid\nMethod to get point from grid at point x and y
e0bea4ca	f24	p0	2024-09-22 15:08:20	grid.h	23	23	GRID_H
e0bea4ca	f24	p0	2024-09-22 15:08:20	main.cpp	3	4	Include Grid class\nInclude Point class
e0bea4ca	f24	p0	2024-09-22 15:08:20	point.cpp	8	8	Finds the potential of the point
e0bea4ca	f24	p0	2024-09-22 15:08:20	point.cpp	36	36	Inserts a point into the grid
e0bea4ca	f24	p0	2024-09-22 15:08:20	point.h	8	8	Forward declaration of Grid class to avoid circular dependency
e0bea4ca	f24	p0	2024-09-22 15:08:20	point.h	17	17	Default constructor
e0bea4ca	f24	p0	2024-09-22 15:08:20	point.h	29	29	POINT_H
e2a8d2ff	f24	p0	2024-09-22 19:39:14	cell.cpp	11	11	to avoid extra calculations using getPotential
e2a8d2ff	f24	p0	2024-09-22 19:39:14	cell.hpp	13	13	Potential
e2a8d2ff	f24	p0	2024-09-22 19:39:14	grid.hpp	9	9	set all point to ''; set potential to 0
e2a8d2ff	f24	p0	2024-09-22 19:39:14	grid.hpp	18	18	pointer to the grid
e2a8d2ff	f24	p0	2024-09-22 19:39:14	grid.hpp	21	21	cannot be modified once map is created
e2a8d2ff	f24	p0	2024-09-23 00:06:46	cell.cpp	12	12	to avoid extra calculations using getPotential
e2a8d2ff	f24	p0	2024-09-23 00:06:46	cell.hpp	13	13	Potential
e2a8d2ff	f24	p0	2024-09-23 00:06:46	grid.hpp	9	9	set all point to ''; set potential to 0
e2a8d2ff	f24	p0	2024-09-23 00:06:46	grid.hpp	18	18	pointer to the grid
e2a8d2ff	f24	p0	2024-09-23 00:06:46	grid.hpp	21	21	cannot be modified once map is created
e2a8d2ff	f24	p0	2024-09-23 10:43:09	cell.cpp	12	12	to avoid extra calculations using getPotential
e2a8d2ff	f24	p0	2024-09-23 10:43:09	cell.hpp	13	13	Potential
e2a8d2ff	f24	p0	2024-09-23 10:43:09	grid.hpp	9	9	set all point to ''; set potential to 0
e2a8d2ff	f24	p0	2024-09-23 10:43:09	grid.hpp	18	18	pointer to the grid
e2a8d2ff	f24	p0	2024-09-23 10:43:09	grid.hpp	21	21	cannot be modified once map is created
e2a8d2ff	f24	p0	2024-09-23 12:10:03	cell.cpp	12	12	to avoid extra calculations using getPotential
e2a8d2ff	f24	p0	2024-09-23 12:10:03	cell.hpp	13	13	Potential
e2a8d2ff	f24	p0	2024-09-23 12:10:03	grid.hpp	9	9	set all point to ''; set potential to 0
e2a8d2ff	f24	p0	2024-09-23 12:10:03	grid.hpp	18	18	pointer to the grid
e2a8d2ff	f24	p0	2024-09-23 12:10:03	grid.hpp	21	21	cannot be modified once map is created
e2afff44	f24	p0	2024-09-23 12:34:50	grid.cpp	12	12	Calculates potential at given point
e2afff44	f24	p0	2024-09-23 12:34:50	grid.cpp	15	15	Handling division by 0
e2afff44	f24	p0	2024-09-23 12:34:50	grid.cpp	23	24	Condition to check to see whether a 2D grid already exists\nIf the grid exists, then i'll just delete it to make way for a new one
e2afff44	f24	p0	2024-09-23 12:34:50	grid.cpp	34	36	We can't create a 2D grid with a negative length and width\nThis is only for the fuzz tests though\nThe autograder one ecenebula will always provide values > 0 (refer to project doc)
e2afff44	f24	p0	2024-09-23 12:34:50	grid.cpp	42	42	Allocate memory and assign values
e2afff44	f24	p0	2024-09-23 12:34:50	grid.cpp	48	48	Allocate memory for each index
e2afff44	f24	p0	2024-09-23 12:34:50	grid.cpp	53	53	Set each point on the grid to 0
e2afff44	f24	p0	2024-09-23 12:34:50	grid.cpp	64	65	Checking for out of bounds\nAlso checking for values < 0
e47c9755	f24	p0	2024-09-13 17:04:18	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-13 17:04:18	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-13 17:25:02	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-13 17:25:02	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-13 17:34:53	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-13 17:34:53	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-13 17:39:56	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-13 17:39:56	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-13 17:51:24	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-13 17:51:24	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-13 22:28:41	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-13 22:28:41	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-13 23:32:50	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-13 23:32:50	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-17 21:11:14	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-17 21:11:14	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-17 22:31:40	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-17 22:31:40	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-19 21:33:38	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-19 21:33:38	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-23 14:05:37	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-23 14:05:37	main.h	16	16	MAIN_H
e47c9755	f24	p0	2024-09-23 14:07:41	main.h	1	3	\nCreated by ericr on 9/6/2024.\n
e47c9755	f24	p0	2024-09-23 14:07:41	main.h	16	16	MAIN_H
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	9	16	Expected to fail\nExpected to fail\nThis should actually be an integer, assuming K is an integer\nAdding a goal at (7, 7)\nAdding an obstacle at (3, 3)\nAdding an obstacle at (3, 4)\nAdding an obstacle at (4, 3)\nAdding a goal at (0, 7)
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	52	52	Dynamically allocating an array of pointers of type Cell (columns)
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	55	55	Setting each index of the array to a object type Cell
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	60	60	Updating program constant
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	67	67	If out of bounds (adjust for zero-indexed)
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	73	73	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	77	77	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	84	84	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	90	90	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	96	96	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	101	101	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	116	116	If out of bounds
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	121	121	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	128	128	If Map DNE
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	133	133	Clearing Map
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-20 01:08:25	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	9	16	Expected to fail\nExpected to fail\nThis should actually be an integer, assuming K is an integer\nAdding a goal at (7, 7)\nAdding an obstacle at (3, 3)\nAdding an obstacle at (3, 4)\nAdding an obstacle at (4, 3)\nAdding a goal at (0, 7)
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	52	52	Dynamically allocating an array of pointers of type Cell (columns)
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	55	55	Setting each index of the array to a object type Cell
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	60	60	Updating program constant
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	67	67	If out of bounds (adjust for zero-indexed)
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	73	73	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	77	77	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	84	84	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	90	90	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	96	96	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	101	101	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	116	116	If out of bounds
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	121	121	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	128	128	If Map DNE
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	133	133	Clearing Map
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-20 01:09:12	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	9	16	Expected to fail\nExpected to fail\nThis should actually be an integer, assuming K is an integer\nAdding a goal at (7, 7)\nAdding an obstacle at (3, 3)\nAdding an obstacle at (3, 4)\nAdding an obstacle at (4, 3)\nAdding a goal at (0, 7)
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	52	52	Dynamically allocating an array of pointers of type Cell (columns)
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	55	55	Setting each index of the array to a object type Cell
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	60	60	Updating program constant
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	67	67	If out of bounds (adjust for zero-indexed)
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	73	73	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	77	77	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	84	84	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	90	90	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	96	96	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	101	101	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	116	116	If out of bounds
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	121	121	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	128	128	If Map DNE
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	133	133	Clearing Map
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-20 01:53:44	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	32	32	Dynamically allocating an array of pointers of type Cell (columns)
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	35	35	Setting each index of the array to a object type Cell
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	40	40	Updating program constant
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	47	47	If out of bounds (adjust for zero-indexed)
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	53	53	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	57	57	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	64	64	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	70	70	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	76	76	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	81	81	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	96	96	If out of bounds
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	101	101	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	108	108	If Map DNE
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	113	113	Clearing Map
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	124	124	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.cpp	138	138	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-20 02:00:19	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	62	62	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	73	73	Dynamically allocating an array of pointers of type Cell (columns)
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	76	76	Setting each index of the array to a object type Cell
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	81	81	Updating program constant
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	88	88	If out of bounds (adjust for zero-indexed)
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	94	94	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	98	98	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	105	105	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	111	111	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	117	117	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	122	122	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	137	137	If out of bounds
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	142	142	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	149	149	If Map DNE
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	154	154	Clearing Map
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	166	166	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.cpp	180	180	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-20 02:45:40	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	62	62	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	73	73	Dynamically allocating an array of pointers of type Cell (columns)
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	76	76	Setting each index of the array to a object type Cell
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	81	81	Updating program constant
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	88	88	If out of bounds (adjust for zero-indexed)
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	94	94	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	98	98	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	105	105	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	111	111	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	117	117	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	122	122	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	137	137	If out of bounds
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	142	142	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	149	149	If Map DNE
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	154	154	Clearing Map
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	166	166	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.cpp	180	180	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-21 14:07:05	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	62	62	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	73	73	Dynamically allocating an array of pointers of type Cell (columns)
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	76	76	Setting each index of the array to a object type Cell
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	81	81	Updating program constant
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	88	88	If out of bounds (adjust for zero-indexed)
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	94	94	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	98	98	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	105	105	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	111	111	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	117	117	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	122	122	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	137	137	If out of bounds
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	142	142	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	149	149	If Map DNE
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	154	154	Clearing Map
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	166	166	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.cpp	180	180	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-21 14:08:05	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	57	57	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	68	68	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	71	71	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	76	76	Updating program constant
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	83	83	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	89	89	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	93	93	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	100	100	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	106	106	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	112	112	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	117	117	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	132	132	If out of bounds
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	137	137	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	144	144	If Map DNE
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	149	149	Clearing Map
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	161	161	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.cpp	175	175	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.hpp	6	8	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-09-21 16:28:11	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	57	57	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	68	68	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	71	71	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	76	76	Updating program constant
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	83	83	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	89	89	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	93	93	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	100	100	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	106	106	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	112	112	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	117	117	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	132	132	If out of bounds
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	137	137	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	144	144	If Map DNE
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	149	149	Clearing Map
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	161	161	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.cpp	175	175	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.hpp	6	8	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-09-21 23:59:21	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-22 13:04:11	main.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:04:11	main.cpp	7	7	Include the header file that contains the class declarations
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	27	27	No dynamic memory or resources to free
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	40	40	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	51	51	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	54	54	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	59	59	Updating program constant
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	66	66	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	72	72	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	76	76	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	83	83	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	89	89	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	95	95	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	100	100	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	115	115	If out of bounds
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	120	120	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	127	127	If Map DNE
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	132	132	Clearing Map
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.hpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.hpp	10	12	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-09-22 13:04:11	p0.hpp	29	29	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-22 13:06:09	main.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:06:09	main.cpp	7	7	Include the header file that contains the class declarations
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	27	27	No dynamic memory or resources to free
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	40	40	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	51	51	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	54	54	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	59	59	Updating program constant
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	66	66	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	72	72	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	76	76	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	83	83	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	89	89	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	95	95	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	100	100	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	115	115	If out of bounds
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	120	120	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	127	127	If Map DNE
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	132	132	Clearing Map
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.hpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.hpp	10	12	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-09-22 13:06:09	p0.hpp	29	29	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-22 13:08:09	main.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:08:09	main.cpp	7	7	Include the header file that contains the class declarations
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	27	27	No dynamic memory or resources to free
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	40	40	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	51	51	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	54	54	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	59	59	Updating program constant
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	66	66	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	72	72	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	76	76	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	83	83	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	89	89	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	95	95	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	100	100	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	115	115	If out of bounds
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	120	120	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	127	127	If Map DNE
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	132	132	Clearing Map
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.hpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.hpp	10	12	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-09-22 13:08:09	p0.hpp	29	29	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	57	57	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	68	68	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	71	71	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	76	76	Updating program constant
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	83	83	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	89	89	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	93	93	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	100	100	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	106	106	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	112	112	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	117	117	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	132	132	If out of bounds
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	137	137	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	144	144	If Map DNE
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	149	149	Clearing Map
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	161	161	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.cpp	175	175	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.hpp	6	8	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-09-22 13:48:50	p0.hpp	25	25	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-22 13:49:23	main.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:49:23	main.cpp	7	7	Include the header file that contains the class declarations
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	27	27	No dynamic memory or resources to free
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	40	40	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	51	51	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	54	54	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	59	59	Updating program constant
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	66	66	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	72	72	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	76	76	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	83	83	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	89	89	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	95	95	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	100	100	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	115	115	If out of bounds
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	120	120	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	127	127	If Map DNE
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	132	132	Clearing Map
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.hpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.hpp	10	12	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-09-22 13:49:23	p0.hpp	29	29	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-09-22 20:33:58	main.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 20:33:58	main.cpp	7	7	Include the header file that contains the class declarations
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	27	27	No dynamic memory or resources to free
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	40	40	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	51	51	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	54	54	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	59	59	Updating program constant
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	66	66	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	72	72	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	76	76	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	83	83	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	89	89	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	95	95	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	100	100	Avoid Divison by Zero
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	115	115	If out of bounds
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	120	120	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	127	127	If Map DNE
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	132	132	Clearing Map
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.hpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.hpp	10	12	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-09-22 20:33:58	p0.hpp	29	29	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-10-03 13:16:26	main.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-10-03 13:16:26	main.cpp	7	7	Include the header file that contains the class declarations
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	27	27	No dynamic memory or resources to free
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	40	40	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	51	51	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	54	54	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	59	59	Updating program constant
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	66	66	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	72	72	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	76	76	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	83	83	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	89	89	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	95	95	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	100	100	Avoid Divison by Zero
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	115	115	If out of bounds
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	120	120	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	127	127	If Map DNE
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	132	132	Clearing Map
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.hpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.hpp	10	12	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-10-03 13:16:26	p0.hpp	29	29	Helper Function - Calculates Grid Potential
e538e5dd	f24	p0	2024-10-03 14:56:48	main.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-10-03 14:56:48	main.cpp	7	7	Include the header file that contains the class declarations
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	27	27	No dynamic memory or resources to free
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	40	40	Deallocating the entire grid if one already exists
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	51	51	Dynamically allocating an array of pointers of type Cell of length n (columns)
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	54	54	Setting each index of the p_grid array to point to another array of type Cell of length m (rows)
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	59	59	Updating program constant
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	66	66	If out of bounds (adjusted for zero-indexing)
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	72	72	If adding a Goal or Obstacles
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	76	76	Adds the point, and updates the potential at ALL points
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	83	83	Loop to move from to every index in the grid (updating the potential one a a time)
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	89	89	Have to traverse the entire grid and update the potentials for one point at a time
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	95	95	Obstacle Operations are Positive - Goals are Negative
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	100	100	Avoid Divison by Zero
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	115	115	If out of bounds
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	120	120	Printing Potential at Point ( X, Y )
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	127	127	If Map DNE
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	132	132	Clearing Map
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	144	144	If K is invalid ( K <= 0 )
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.cpp	158	158	Deallocating the entire grid
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.hpp	1	3	Author : Ruben Rehal\nDate : September 22, 2024\nECE 250 Project 0 : Potential Field Navigation
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.hpp	10	12	Potential at x-coordinate\nPotential at y-coordinate\nDifferentiates between a "Goal" and an "Obstacle"
e538e5dd	f24	p0	2024-10-03 14:56:48	p0.hpp	29	29	Helper Function - Calculates Grid Potential
e56fc7c3	f24	p0	2024-09-18 00:44:47	Point.cpp	14	14	A pretty pointless destructor
e56fc7c3	f24	p0	2024-09-18 00:44:47	Point.hpp	30	30	Potential at this point
e56fc7c3	f24	p0	2024-09-18 00:44:47	Point.hpp	34	34	Goal, obstacle or neither
e56fc7c3	f24	p0	2024-09-19 19:02:33	Point.cpp	14	14	A pretty pointless destructor
e56fc7c3	f24	p0	2024-09-19 19:02:33	Point.hpp	28	28	Potential at this point
e56fc7c3	f24	p0	2024-09-19 19:02:33	Point.hpp	32	32	Goal, obstacle or neither
e56fc7c3	f24	p0	2024-09-22 09:39:45	Point.cpp	14	14	A pretty pointless destructor
e56fc7c3	f24	p0	2024-09-22 09:39:45	Point.hpp	28	28	Potential at this point
e56fc7c3	f24	p0	2024-09-22 09:39:45	Point.hpp	32	32	Goal, obstacle or neither
e56fc7c3	f24	p0	2024-09-22 09:41:51	Point.cpp	14	14	A pretty pointless destructor
e56fc7c3	f24	p0	2024-09-22 09:41:51	Point.hpp	28	28	Potential at this point
e56fc7c3	f24	p0	2024-09-22 09:41:51	Point.hpp	32	32	Goal, obstacle or neither
e5b0f7ad	f24	p0	2024-09-23 22:00:47	main.cpp	8	8	object of my class
e5b0f7ad	f24	p0	2024-09-23 22:00:47	Map_Array.cpp	88	88	changed to bool
e5b0f7ad	f24	p0	2024-09-23 22:00:47	Map_Array.cpp	135	144	for(int i=0; i<N; i++){\nfor(int j=0; j<M; j++){\npotentialx_grid[i][j] = (K/sqrt(pow((i-X),2)+pow((j-Y),2)));\n}\n}\nfor(int i=0; i<N; i++){\nfor(int j=0; j<M; j++){\npotentialy_grid[i][j] = (K/sqrt(pow((i-X),2)+pow((j-Y),2)));\n}\n}
e5b0f7ad	f24	p0	2024-09-23 22:00:47	Map_Array.h	27	28	robot position\nrobot position
e8ccb6a3	f24	p0	2024-09-19 02:16:28	potentialField.cpp	53	53	check if within bounds of array
e8ccb6a3	f24	p0	2024-09-19 02:16:28	potentialField.cpp	58	58	true if G false if O
e8ccb6a3	f24	p0	2024-09-21 16:50:43	main.cpp	22	22	Read x and y from input
e8ccb6a3	f24	p0	2024-09-21 16:50:43	potentialField.cpp	59	59	check if within bounds of array
e8ccb6a3	f24	p0	2024-09-21 16:50:43	potentialField.cpp	62	62	removeFromLists
e8ccb6a3	f24	p0	2024-09-21 16:50:43	potentialField.cpp	66	66	reallocate
e8ccb6a3	f24	p0	2024-09-21 16:50:43	potentialField.cpp	84	84	add to obstacles
e8ccb6a3	f24	p0	2024-09-22 19:11:39	main.cpp	21	21	Read x and y from input
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	4	4	constructor to initialize all member variables
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	7	7	destructor to cleanup allocated memory
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	12	12	create a new potential field with given dimensions
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	18	18	allocate a 2D array for the field
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	23	23	initialize arrays for goals and obstacles
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	33	33	default strength factor
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	38	38	remove a point from the goal and obstacle arrays
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	40	40	remove from goals if present
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	42	42	shift remaining goals to fill the gap
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	50	50	remove from obstacles if present
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	52	52	shift remaining obstacles to fill the gap
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	62	62	add a new point to the field
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	65	65	check if within bounds of array
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	68	68	remove if already exists
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	70	70	add a goal
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	72	72	expand goal array if needed
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	88	88	add an obstacle
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	90	90	expand obstacle array if needed
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	107	107	recalculate potential field
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	111	111	calculate potential field based on goals and obstacles
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	116	116	potential from goals
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	127	127	potential from obstacles
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	138	138	store potentials
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	145	145	get potential at a point
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	148	148	check if within bounds
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	155	155	clear allocated memory and reset variables
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	179	179	update strength factor and recalculate potential
e8ccb6a3	f24	p0	2024-09-22 19:11:39	potentialField.cpp	182	182	cannot be negative
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	3	3	CREATE
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	18	18	Getter and Setter for K, rows, cols
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	20	20	(UPDATE)
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	24	24	EXIT
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	35	36	Getter for Node at position (i, j)\nnot modifying
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	47	47	(POINT) Setter for element at position (i, j)
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	66	66	Function to compute potential
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	73	73	initialize variables to temporarly store PotX and PotY
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	76	76	Loop through grid to sum the potential.
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	80	80	Exclude itself
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	83	83	Goal
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	88	88	Obstacle
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	99	99	CLEAR - handle outside
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	110	110	MOVE rewrite cout
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	120	120	UPDATE
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	135	135	Debug function to display the grid
e9883b70	f24	p0	2024-09-21 12:16:31	grid.cpp	139	139	<< " " << grid[i][j]->getY()
e9883b70	f24	p0	2024-09-21 12:16:31	grid.h	27	27	Debug Function to print Grid
e9883b70	f24	p0	2024-09-21 12:16:31	node.h	18	18	Debug Function to print Node
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	3	3	CREATE
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	18	18	Getter and Setter for K, rows, cols
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	20	20	(UPDATE)
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	24	24	EXIT
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	35	36	Getter for Node at position (i, j)\nnot modifying
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	47	47	(POINT) Setter for element at position (i, j)
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	66	66	Function to compute potential
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	73	73	initialize variables to temporarly store PotX and PotY
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	76	76	Loop through grid to sum the potential.
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	80	80	Exclude itself
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	83	83	Goal
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	88	88	Obstacle
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	99	99	CLEAR - handle outside
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	110	110	MOVE rewrite cout
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	120	120	UPDATE
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	135	135	Debug function to display the grid
e9883b70	f24	p0	2024-09-21 13:05:57	grid.cpp	139	139	<< " " << grid[i][j]->getY()
e9883b70	f24	p0	2024-09-21 13:05:57	grid.h	27	27	Debug Function to print Grid
e9883b70	f24	p0	2024-09-21 13:05:57	node.h	18	18	Debug Function to print Node
e9f2fc86	f24	p0	2024-09-23 22:52:32	grid.cpp	25	25	array width and height will be one greater to include for position x=0 and y=0
e9f2fc86	f24	p0	2024-09-23 22:52:32	grid.cpp	30	30	x + y*m_width gives the index
e9f2fc86	f24	p0	2024-09-23 22:52:32	grid.cpp	60	60	robot is on goal/obstacle
e9f2fc86	f24	p0	2024-09-23 22:52:32	grid.cpp	65	65	to calculate x and y positions from i and j indexes
e9f2fc86	f24	p0	2024-09-23 22:52:32	grid.cpp	73	73	updating the potential
e9f2fc86	f24	p0	2024-09-23 22:52:32	main.cpp	1	6	\nmain.cpp\n250_project0\n\nCreated by Ryan Kumar on 19/9/24.\n
ec831635	f24	p0	2024-09-21 16:48:50	main.cpp	31	31	map.printGrid();
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	10	10	deallocate grid
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	13	13	deallocate grid
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	19	19	if grid hasn't been created
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	24	24	if grid hasn't been created
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	39	39	deallocate grid if grid isn't alr clear
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	45	45	create new grid
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	46	46	deallocate grid if grid isn't alr clear
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	51	51	sets all potential values to 0
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	52	52	create new grid
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	58	58	sets all potential values to 0.0
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	62	62	goals exert -'ve potential, while obstacles exert +'ve potential
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	67	67	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	69	69	goals exert -'ve potential, while obstacles exert +'ve potential
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	74	74	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	79	79	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	86	86	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	90	92	check for zero division (when dist from goal/obstacle is 0)\nif goal, subtract k/ denom\nelse if obstacle add k / denom
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	96	98	check for zero division (when dist from goal/obstacle is 0)\nif goal, subtract k/ denom\nelse if obstacle add k / denom
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	116	116	update K constant
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	117	117	update K constant
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	122	123	void Grid::printGrid()\n{
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.cpp	125	133	for (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < M; j++)\n{\nstd::cout << grid[i][j] << " ";\n}\nstd::cout << std::endl;\n}\n}
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.hpp	9	11	size of N x M grid\npotential field grid\nconstant K, used for potential calculation
ec831635	f24	p0	2024-09-21 16:48:50	potentialFieldNavigation.hpp	27	27	void printGrid();
ec831635	f24	p0	2024-09-21 16:59:12	main.cpp	31	31	map.printGrid();
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	13	13	deallocate grid
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	24	24	if grid hasn't been created
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	46	46	deallocate grid if grid isn't alr clear
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	52	52	create new grid
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	58	58	sets all potential values to 0.0
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	69	69	goals exert -'ve potential, while obstacles exert +'ve potential
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	74	74	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	86	86	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	96	98	check for zero division (when dist from goal/obstacle is 0)\nif goal, subtract k/ denom\nelse if obstacle add k / denom
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	117	117	update K constant
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	122	123	void Grid::printGrid()\n{
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.cpp	125	133	for (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < M; j++)\n{\nstd::cout << grid[i][j] << " ";\n}\nstd::cout << std::endl;\n}\n}
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.hpp	9	11	size of N x M grid\npotential field grid\nconstant K, used for potential calculation
ec831635	f24	p0	2024-09-21 16:59:12	potentialFieldNavigation.hpp	27	27	void printGrid();
ec831635	f24	p0	2024-09-21 18:07:09	main.cpp	31	31	map.printGrid();
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	13	13	deallocate grid
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	24	24	if grid hasn't been created
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	46	46	deallocate grid if grid isn't alr clear
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	52	52	create new grid
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	58	58	sets all potential values to 0.0
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	69	69	goals exert -'ve potential, while obstacles exert +'ve potential
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	74	74	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	86	86	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	96	98	check for zero division (when dist from goal/obstacle is 0)\nif goal, subtract k/ denom\nelse if obstacle add k / denom
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	117	117	update K constant
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.cpp	122	132	void Grid::printGrid()\n{\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < M; j++)\n{\nstd::cout << grid[i][j] << " ";\n}\nstd::cout << std::endl;\n}\n}
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.hpp	9	11	size of N x M grid\npotential field grid\nconstant K, used for potential calculation
ec831635	f24	p0	2024-09-21 18:07:09	potentialFieldNavigation.hpp	27	27	void printGrid();
ec831635	f24	p0	2024-09-23 11:19:48	main.cpp	31	31	map.printGrid();
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	13	13	deallocate grid
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	25	25	if grid hasn't been created
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	35	35	reset grid potential values all to zero
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	47	47	deallocate grid if grid isn't alr clear
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	55	55	create new grid
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	61	61	sets all potential values to 0
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	72	72	goals exert -'ve potential, while obstacles exert +'ve potential
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	77	77	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	92	92	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	102	102	check for zero division (when dist from goal/obstacle is 0)
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	106	107	pow(dx, 2) is not constant so just use * operation\nsqrt() will never execute in O(1) time, however on small, fixed-precision floating-point numbers it should run close
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	123	123	update K constant
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.cpp	128	138	void Grid::printGrid()\n{\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < M; j++)\n{\nstd::cout << grid[i][j] << " ";\n}\nstd::cout << std::endl;\n}\n}
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.hpp	9	11	size of N x M grid\npotential field grid\nconstant K, used for potential calculation
ec831635	f24	p0	2024-09-23 11:19:48	potentialFieldNavigation.hpp	27	27	void printGrid();
ec831635	f24	p0	2024-09-23 13:53:06	main.cpp	31	31	map.printGrid();
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	13	13	deallocate grid
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	24	24	if grid hasn't been created
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	34	34	reset grid potential values all to zero
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	44	44	deallocate grid if grid isn't alr clear
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	54	54	create new grid
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	60	60	sets all potential values to 0
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	71	71	goals exert -'ve potential, while obstacles exert +'ve potential
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	76	76	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	87	87	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	97	97	check for zero division (when dist from goal/obstacle is 0)
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	99	100	pow(dx, 2) is not constant so just use * operation\nsqrt() will never execute in O(1) time, however on small, fixed-precision floating-point numbers it should run close
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	116	116	update K constant
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.cpp	121	131	void Grid::printGrid()\n{\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < M; j++)\n{\nstd::cout << grid[i][j] << " ";\n}\nstd::cout << std::endl;\n}\n}
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.hpp	9	11	size of N x M grid\npotential field grid\nconstant K, used for potential calculation
ec831635	f24	p0	2024-09-23 13:53:06	potentialFieldNavigation.hpp	27	27	void printGrid();
ec831635	f24	p0	2024-09-23 16:20:31	main.cpp	31	31	map.printGrid();
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	13	13	deallocate grid
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	24	24	if grid hasn't been created
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	34	34	reset grid potential values all to zero
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	44	44	deallocate grid if grid isn't alr clear
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	54	54	create new grid
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	60	60	sets all potential values to 0
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	71	71	goals exert -'ve potential, while obstacles exert +'ve potential
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	76	76	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	87	87	check if (x, y) is within bounds
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	97	97	check for zero division (when dist from goal/obstacle is 0)
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	99	100	pow(dx, 2) is not constant so just use * operation\nsqrt() will never execute in O(1) time, however on small, fixed-precision floating-point numbers it should run close
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	116	116	update K constant
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.cpp	121	131	void Grid::printGrid()\n{\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < M; j++)\n{\nstd::cout << grid[i][j] << " ";\n}\nstd::cout << std::endl;\n}\n}
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.hpp	9	11	size of N x M grid\npotential field grid\nconstant K, used for potential calculation
ec831635	f24	p0	2024-09-23 16:20:31	potentialFieldNavigation.hpp	27	27	void printGrid();
ecc0ced1	f24	p0	2024-09-22 19:38:02	functions.cpp	7	7	Functions
ecc0ced1	f24	p0	2024-09-22 19:38:02	functions.cpp	14	20	Debug usage\ncout << "current start.x: " << start.x << endl;\ncout << "current start.y: " << start.y << endl;\ncout << "current end.x: " << end.x << endl;\ncout << "current end.y: " << end.y << endl;\ncout << "current K: " << K << endl;\ncout << "current potential: " << distance << endl;
ecc0ced1	f24	p0	2024-09-22 19:38:02	functions.cpp	57	58	Debug usage\ncout << "current potential_sum with goal_arr: " << potential_sum << endl;
ecc0ced1	f24	p0	2024-09-22 19:38:02	functions.cpp	63	64	Debug usage\ncout << "current potential_sum with obstacle_arr: " << potential_sum << endl;
ecc0ced1	f24	p0	2024-09-22 19:38:02	main.cpp	20	20	Starts from zero.
ecc0ced1	f24	p0	2024-09-22 19:38:02	main.cpp	55	58	Debug usage\nfor (int i = 0; i < goal_arr.size; i++) {\ncout << "goals: (" <<  goal_arr.get(i).x << ", " << goal_arr.get(i).y << ")" << endl;\n}
ecc0ced1	f24	p0	2024-09-22 19:38:02	main.cpp	60	62	for (int i = 0; i < obstacle_arr.size; i++) {\ncout << "obstacles: (" << obstacle_arr.get(i).x << ", " << obstacle_arr.get(i).y << ")" << endl;\n}
ecc0ced1	f24	p0	2024-09-22 19:44:59	functions.cpp	7	7	Functions
ecc0ced1	f24	p0	2024-09-22 19:44:59	functions.cpp	14	20	Debug usage\ncout << "current start.x: " << start.x << endl;\ncout << "current start.y: " << start.y << endl;\ncout << "current end.x: " << end.x << endl;\ncout << "current end.y: " << end.y << endl;\ncout << "current K: " << K << endl;\ncout << "current potential: " << distance << endl;
ecc0ced1	f24	p0	2024-09-22 19:44:59	functions.cpp	57	58	Debug usage\ncout << "current potential_sum with goal_arr: " << potential_sum << endl;
ecc0ced1	f24	p0	2024-09-22 19:44:59	functions.cpp	63	64	Debug usage\ncout << "current potential_sum with obstacle_arr: " << potential_sum << endl;
ecc0ced1	f24	p0	2024-09-22 19:44:59	main.cpp	20	20	Starts from zero.
ecc0ced1	f24	p0	2024-09-22 19:44:59	main.cpp	55	58	Debug usage\nfor (int i = 0; i < goal_arr.size; i++) {\ncout << "goals: (" <<  goal_arr.get(i).x << ", " << goal_arr.get(i).y << ")" << endl;\n}
ecc0ced1	f24	p0	2024-09-22 19:44:59	main.cpp	60	62	for (int i = 0; i < obstacle_arr.size; i++) {\ncout << "obstacles: (" << obstacle_arr.get(i).x << ", " << obstacle_arr.get(i).y << ")" << endl;\n}
ecc0ced1	f24	p0	2024-09-23 17:19:35	functions.cpp	7	7	Functions
ecc0ced1	f24	p0	2024-09-23 17:19:35	functions.cpp	14	20	Debug usage\ncout << "current start.x: " << start.x << endl;\ncout << "current start.y: " << start.y << endl;\ncout << "current end.x: " << end.x << endl;\ncout << "current end.y: " << end.y << endl;\ncout << "current K: " << K << endl;\ncout << "current potential: " << distance << endl;
ecc0ced1	f24	p0	2024-09-23 17:19:35	functions.cpp	57	58	Debug usage\ncout << "current potential_sum with goal_arr: " << potential_sum << endl;
ecc0ced1	f24	p0	2024-09-23 17:19:35	functions.cpp	63	64	Debug usage\ncout << "current potential_sum with obstacle_arr: " << potential_sum << endl;
ecc0ced1	f24	p0	2024-09-23 17:19:35	main.cpp	20	20	Starts from zero.
ecc0ced1	f24	p0	2024-09-23 17:19:35	main.cpp	55	58	Debug usage\nfor (int i = 0; i < goal_arr.size; i++) {\ncout << "goals: (" <<  goal_arr.get(i).x << ", " << goal_arr.get(i).y << ")" << endl;\n}
ecc0ced1	f24	p0	2024-09-23 17:19:35	main.cpp	60	62	for (int i = 0; i < obstacle_arr.size; i++) {\ncout << "obstacles: (" << obstacle_arr.get(i).x << ", " << obstacle_arr.get(i).y << ")" << endl;\n}
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	7	7	Class definition for Grid points
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	12	12	Private variables
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	18	18	Default to "R" (Regular point)
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	21	21	Constructor
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	24	24	Destructor
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	27	27	Function to update k value and update potential
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	37	37	Function to change type (Goal or Obsticle)
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	43	43	Update potential, if the type is "R", take the sum of all potentials
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	64	64	Getter for potential_x
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	70	70	Getter for potential_y
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	76	76	Getter for x
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	82	82	Getter for py
ef839edd	f24	p0	2024-09-23 01:19:01	Grid_point.hpp	88	88	Getter for type
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	5	5	Class definition for the x-y plot
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	10	10	Private variables
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	18	18	Constructor
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	29	29	Copy Constructor
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	33	33	chat.openai.com/chat
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	48	48	Assignment operator
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	52	52	chat.openai.com/chat
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	83	83	Destructor
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	94	94	Getter for N
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	100	100	Getter for M
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	106	106	Get grid point
ef839edd	f24	p0	2024-09-23 01:19:01	Grid.hpp	112	112	Update potential for all grid points
ef839edd	f24	p0	2024-09-23 01:19:01	project_0.cpp	6	6	Initialize Variables
ef839edd	f24	p0	2024-09-23 01:19:01	project_0.cpp	15	15	CREATE function
ef839edd	f24	p0	2024-09-23 01:19:01	project_0.cpp	22	22	POINT function
ef839edd	f24	p0	2024-09-23 01:19:01	project_0.cpp	61	61	MOVE function
ef839edd	f24	p0	2024-09-23 01:19:01	project_0.cpp	69	69	CLEAR function
ef839edd	f24	p0	2024-09-23 01:19:01	project_0.cpp	75	75	UPDATE function
ef839edd	f24	p0	2024-09-23 01:19:01	project_0.cpp	84	84	EXIT function
ef839edd	f24	p0	2024-09-23 01:19:01	project_0.cpp	92	92	Input variables
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	7	7	Class definition for Grid points
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	12	12	Private variables
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	18	18	Default to "R" (Regular point)
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	21	21	Constructor
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	24	24	Destructor
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	27	27	Function to update k value and update potential
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	37	37	Function to change type (Goal or Obsticle)
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	43	43	Update potential, if the type is "R", take the sum of all potentials
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	64	64	Getter for potential_x
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	70	70	Getter for potential_y
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	76	76	Getter for x
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	82	82	Getter for py
ef839edd	f24	p0	2024-09-23 01:20:50	Grid_point.hpp	88	88	Getter for type
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	5	5	Class definition for the x-y plot
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	10	10	Private variables
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	18	18	Constructor
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	29	29	Copy Constructor
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	33	33	chat.openai.com/chat
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	48	48	Assignment operator
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	52	52	chat.openai.com/chat
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	83	83	Destructor
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	94	94	Getter for N
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	100	100	Getter for M
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	106	106	Get grid point
ef839edd	f24	p0	2024-09-23 01:20:50	Grid.hpp	112	112	Update potential for all grid points
ef839edd	f24	p0	2024-09-23 01:20:50	project_0.cpp	6	6	Initialize Variables
ef839edd	f24	p0	2024-09-23 01:20:50	project_0.cpp	15	15	CREATE function
ef839edd	f24	p0	2024-09-23 01:20:50	project_0.cpp	22	22	POINT function
ef839edd	f24	p0	2024-09-23 01:20:50	project_0.cpp	61	61	MOVE function
ef839edd	f24	p0	2024-09-23 01:20:50	project_0.cpp	69	69	CLEAR function
ef839edd	f24	p0	2024-09-23 01:20:50	project_0.cpp	75	75	UPDATE function
ef839edd	f24	p0	2024-09-23 01:20:50	project_0.cpp	84	84	EXIT function
ef839edd	f24	p0	2024-09-23 01:20:50	project_0.cpp	92	92	Input variables
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	7	7	Class definition for Grid points
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	12	12	Private variables
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	18	18	Default to "R" (Regular point)
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	21	21	Constructor
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	24	24	Destructor
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	27	27	Function to update k value and update potential
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	37	37	Function to change type (Goal or Obsticle)
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	43	43	Update potential, if the type is "R", take the sum of all potentials
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	64	64	Getter for potential_x
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	70	70	Getter for potential_y
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	76	76	Getter for x
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	82	82	Getter for py
ef839edd	f24	p0	2024-09-23 01:22:18	Grid_point.hpp	88	88	Getter for type
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	5	5	Class definition for the x-y plot
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	10	10	Private variables
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	18	18	Constructor
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	29	29	Copy Constructor
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	33	33	chat.openai.com/chat
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	48	48	Assignment operator
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	52	52	chat.openai.com/chat
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	83	83	Destructor
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	94	94	Getter for N
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	100	100	Getter for M
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	106	106	Get grid point
ef839edd	f24	p0	2024-09-23 01:22:18	Grid.hpp	112	112	Update potential for all grid points
ef839edd	f24	p0	2024-09-23 01:22:18	project_0.cpp	6	6	Initialize Variables
ef839edd	f24	p0	2024-09-23 01:22:18	project_0.cpp	15	15	CREATE function
ef839edd	f24	p0	2024-09-23 01:22:18	project_0.cpp	22	22	POINT function
ef839edd	f24	p0	2024-09-23 01:22:18	project_0.cpp	61	61	MOVE function
ef839edd	f24	p0	2024-09-23 01:22:18	project_0.cpp	69	69	CLEAR function
ef839edd	f24	p0	2024-09-23 01:22:18	project_0.cpp	75	75	UPDATE function
ef839edd	f24	p0	2024-09-23 01:22:18	project_0.cpp	84	84	EXIT function
ef839edd	f24	p0	2024-09-23 01:22:18	project_0.cpp	92	92	Input variables
f2107128	f24	p0	2024-09-20 11:51:50	main.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-20 11:51:50	navigation.h	13	13	make sure to clear memory
f2107128	f24	p0	2024-09-20 11:51:50	navigation.h	18	18	reassign
f2107128	f24	p0	2024-09-20 11:51:50	navigation.h	24	24	check if x, y in array
f2107128	f24	p0	2024-09-20 11:51:50	navigation.h	30	30	update pf grid
f2107128	f24	p0	2024-09-20 11:51:50	navigation.h	36	36	update the grid
f2107128	f24	p0	2024-09-20 11:51:50	navigation.h	39	39	check if in bounds
f2107128	f24	p0	2024-09-20 11:51:50	navigation.h	50	50	check if map has been created
f2107128	f24	p0	2024-09-20 11:51:50	navigation.h	55	55	reset forces array and the grid
f2107128	f24	p0	2024-09-20 11:51:50	navigation.h	66	66	recalculate values
f2107128	f24	p0	2024-09-20 11:51:50	potentialfield.h	40	40	if a force already exists at a certain point, then overwrite
f2107128	f24	p0	2024-09-20 11:51:50	potentialfield.h	45	45	set value
f2107128	f24	p0	2024-09-20 11:51:50	potentialfield.h	47	47	exit function
f2107128	f24	p0	2024-09-20 11:51:50	potentialfield.h	60	60	check if force + position are in the same place
f2107128	f24	p0	2024-09-20 11:51:50	potentialfield.h	64	64	add force to result
f2107128	f24	p0	2024-09-20 11:51:50	test.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-20 11:51:50	test.cpp	84	84	temp
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	16	16	create temporary buffer
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	18	18	delete old buffer
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	21	21	copy old buffer to new buffer
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	26	26	free memory
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	29	29	update buffer
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	36	36	init default size
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	44	44	init specified size
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	52	52	delete buffer
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	58	58	Copy assignment operator (deep copy)
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	61	61	Handle self-assignment
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	65	65	free old memory
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	69	69	must create new array + copy it over
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	72	72	copy over data
f2107128	f24	p0	2024-09-20 11:51:50	vector.h	128	128	no need to clear up other data because it cannot be accessed anyways
f2107128	f24	p0	2024-09-20 11:53:57	main.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-20 11:53:57	navigation.h	13	13	make sure to clear memory
f2107128	f24	p0	2024-09-20 11:53:57	navigation.h	18	18	reassign
f2107128	f24	p0	2024-09-20 11:53:57	navigation.h	24	24	check if x, y in array
f2107128	f24	p0	2024-09-20 11:53:57	navigation.h	30	30	update pf grid
f2107128	f24	p0	2024-09-20 11:53:57	navigation.h	36	36	update the grid
f2107128	f24	p0	2024-09-20 11:53:57	navigation.h	39	39	check if in bounds
f2107128	f24	p0	2024-09-20 11:53:57	navigation.h	50	50	check if map has been created
f2107128	f24	p0	2024-09-20 11:53:57	navigation.h	55	55	reset forces array and the grid
f2107128	f24	p0	2024-09-20 11:53:57	navigation.h	66	66	recalculate values
f2107128	f24	p0	2024-09-20 11:53:57	potentialfield.h	40	40	if a force already exists at a certain point, then overwrite
f2107128	f24	p0	2024-09-20 11:53:57	potentialfield.h	45	45	set value
f2107128	f24	p0	2024-09-20 11:53:57	potentialfield.h	47	47	exit function
f2107128	f24	p0	2024-09-20 11:53:57	potentialfield.h	60	60	check if force + position are in the same place
f2107128	f24	p0	2024-09-20 11:53:57	potentialfield.h	64	64	add force to result
f2107128	f24	p0	2024-09-20 11:53:57	test.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-20 11:53:57	test.cpp	84	84	temp
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	16	16	create temporary buffer
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	18	18	delete old buffer
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	21	21	copy old buffer to new buffer
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	26	26	free memory
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	29	29	update buffer
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	36	36	init default size
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	44	44	init specified size
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	52	52	delete buffer
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	58	58	Copy assignment operator (deep copy)
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	61	61	Handle self-assignment
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	65	65	free old memory
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	69	69	must create new array + copy it over
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	72	72	copy over data
f2107128	f24	p0	2024-09-20 11:53:57	vector.h	128	128	no need to clear up other data because it cannot be accessed anyways
f2107128	f24	p0	2024-09-21 16:35:53	main.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-21 16:35:53	navigation.h	27	27	reassign
f2107128	f24	p0	2024-09-21 16:35:53	navigation.h	33	33	check if x, y in array
f2107128	f24	p0	2024-09-21 16:35:53	navigation.h	39	39	update pf grid
f2107128	f24	p0	2024-09-21 16:35:53	navigation.h	45	45	update the grid
f2107128	f24	p0	2024-09-21 16:35:53	navigation.h	48	48	check if in bounds
f2107128	f24	p0	2024-09-21 16:35:53	navigation.h	59	59	check if map has been created
f2107128	f24	p0	2024-09-21 16:35:53	navigation.h	64	64	reset forces array and the grid
f2107128	f24	p0	2024-09-21 16:35:53	navigation.h	75	75	recalculate values
f2107128	f24	p0	2024-09-21 16:35:53	potentialfield.h	40	40	if a force already exists at a certain point, then overwrite
f2107128	f24	p0	2024-09-21 16:35:53	potentialfield.h	45	45	set value
f2107128	f24	p0	2024-09-21 16:35:53	potentialfield.h	47	47	exit function
f2107128	f24	p0	2024-09-21 16:35:53	potentialfield.h	60	60	check if force + position are in the same place
f2107128	f24	p0	2024-09-21 16:35:53	potentialfield.h	64	64	add force to result
f2107128	f24	p0	2024-09-21 16:35:53	test.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-21 16:35:53	test.cpp	84	84	temp
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	16	16	create temporary buffer
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	18	18	delete old buffer
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	21	21	copy old buffer to new buffer
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	26	26	free memory
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	29	29	update buffer
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	36	36	init default size
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	44	44	init specified size
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	52	52	delete buffer
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	58	58	Copy assignment operator (deep copy)
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	61	61	Handle self-assignment
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	65	65	free old memory
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	68	68	must create new array + copy it over
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	71	71	copy over data
f2107128	f24	p0	2024-09-21 16:35:53	vector.h	128	128	no need to clear up other data because it cannot be accessed anyways
f2107128	f24	p0	2024-09-21 16:37:55	main.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-21 16:37:55	navigation.h	27	27	reassign
f2107128	f24	p0	2024-09-21 16:37:55	navigation.h	33	33	check if x, y in array
f2107128	f24	p0	2024-09-21 16:37:55	navigation.h	39	39	update pf grid
f2107128	f24	p0	2024-09-21 16:37:55	navigation.h	45	45	update the grid
f2107128	f24	p0	2024-09-21 16:37:55	navigation.h	48	48	check if in bounds
f2107128	f24	p0	2024-09-21 16:37:55	navigation.h	59	59	check if map has been created
f2107128	f24	p0	2024-09-21 16:37:55	navigation.h	64	64	reset forces array and the grid
f2107128	f24	p0	2024-09-21 16:37:55	navigation.h	75	75	recalculate values
f2107128	f24	p0	2024-09-21 16:37:55	potentialfield.h	40	40	if a force already exists at a certain point, then overwrite
f2107128	f24	p0	2024-09-21 16:37:55	potentialfield.h	45	45	set value
f2107128	f24	p0	2024-09-21 16:37:55	potentialfield.h	47	47	exit function
f2107128	f24	p0	2024-09-21 16:37:55	potentialfield.h	60	60	check if force + position are in the same place
f2107128	f24	p0	2024-09-21 16:37:55	potentialfield.h	64	64	add force to result
f2107128	f24	p0	2024-09-21 16:37:55	test.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-21 16:37:55	test.cpp	84	84	temp
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	16	16	create temporary buffer
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	18	18	delete old buffer
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	21	21	copy old buffer to new buffer
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	26	26	free memory
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	29	29	update buffer
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	36	36	init default size
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	44	44	init specified size
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	52	52	delete buffer
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	58	58	Copy assignment operator (deep copy)
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	61	61	Handle self-assignment
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	65	65	free old memory
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	68	68	must create new array + copy it over
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	71	71	copy over data
f2107128	f24	p0	2024-09-21 16:37:55	vector.h	128	128	no need to clear up other data because it cannot be accessed anyways
f2107128	f24	p0	2024-09-21 20:03:51	main.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-21 20:03:51	navigation.h	27	27	reassign
f2107128	f24	p0	2024-09-21 20:03:51	navigation.h	33	33	check if x, y in array
f2107128	f24	p0	2024-09-21 20:03:51	navigation.h	39	39	update pf grid
f2107128	f24	p0	2024-09-21 20:03:51	navigation.h	45	45	check if in bounds
f2107128	f24	p0	2024-09-21 20:03:51	navigation.h	56	56	check if map has been created
f2107128	f24	p0	2024-09-21 20:03:51	navigation.h	61	61	reset forces array and the grid
f2107128	f24	p0	2024-09-21 20:03:51	navigation.h	72	72	recalculate values
f2107128	f24	p0	2024-09-21 20:03:51	potentialfield.h	40	40	if a force already exists at a certain point, then overwrite
f2107128	f24	p0	2024-09-21 20:03:51	potentialfield.h	45	45	set value
f2107128	f24	p0	2024-09-21 20:03:51	potentialfield.h	47	47	exit function
f2107128	f24	p0	2024-09-21 20:03:51	potentialfield.h	60	60	check if force + position are in the same place
f2107128	f24	p0	2024-09-21 20:03:51	potentialfield.h	64	64	add force to result
f2107128	f24	p0	2024-09-21 20:03:51	test.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-21 20:03:51	test.cpp	84	84	temp
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	16	16	create temporary buffer
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	18	18	delete old buffer
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	21	21	copy old buffer to new buffer
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	26	26	free memory
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	29	29	update buffer
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	36	36	init default size
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	44	44	init specified size
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	52	52	delete buffer
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	58	58	Copy assignment operator (deep copy)
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	61	61	Handle self-assignment
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	65	65	free old memory
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	68	68	must create new array + copy it over
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	71	71	copy over data
f2107128	f24	p0	2024-09-21 20:03:51	vector.h	128	128	no need to clear up other data because it cannot be accessed anyways
f2107128	f24	p0	2024-09-23 09:23:42	main.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-23 09:23:42	navigation.h	27	27	reassign
f2107128	f24	p0	2024-09-23 09:23:42	navigation.h	33	33	check if x, y in array
f2107128	f24	p0	2024-09-23 09:23:42	navigation.h	39	39	update pf grid
f2107128	f24	p0	2024-09-23 09:23:42	navigation.h	45	45	check if in bounds
f2107128	f24	p0	2024-09-23 09:23:42	navigation.h	56	56	check if map has been created
f2107128	f24	p0	2024-09-23 09:23:42	navigation.h	61	61	reset forces array and the grid
f2107128	f24	p0	2024-09-23 09:23:42	navigation.h	72	72	recalculate values
f2107128	f24	p0	2024-09-23 09:23:42	potentialfield.h	40	40	if a force already exists at a certain point, then overwrite
f2107128	f24	p0	2024-09-23 09:23:42	potentialfield.h	45	45	set value
f2107128	f24	p0	2024-09-23 09:23:42	potentialfield.h	47	47	exit function
f2107128	f24	p0	2024-09-23 09:23:42	potentialfield.h	60	60	check if force + position are in the same place
f2107128	f24	p0	2024-09-23 09:23:42	potentialfield.h	64	64	add force to result
f2107128	f24	p0	2024-09-23 09:23:42	test.cpp	25	25	create a  board
f2107128	f24	p0	2024-09-23 09:23:42	test.cpp	84	84	temp
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	16	16	create temporary buffer
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	18	18	delete old buffer
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	21	21	copy old buffer to new buffer
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	26	26	free memory
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	29	29	update buffer
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	36	36	init default size
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	44	44	init specified size
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	52	52	delete buffer
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	58	58	Copy assignment operator (deep copy)
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	61	61	Handle self-assignment
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	65	65	free old memory
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	68	68	must create new array + copy it over
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	71	71	copy over data
f2107128	f24	p0	2024-09-23 09:23:42	vector.h	128	128	no need to clear up other data because it cannot be accessed anyways
f3db4a38	f24	p0	2024-09-14 20:25:39	main.cpp	20	20	Handle missing parameters
f3db4a38	f24	p0	2024-09-14 20:25:39	main.cpp	22	22	Clear the error flag and ignore the rest of the line
f3db4a38	f24	p0	2024-09-14 20:25:39	main.cpp	34	34	Handle missing parameters
f3db4a38	f24	p0	2024-09-14 20:25:39	main.cpp	47	47	Handle missing parameters
f3db4a38	f24	p0	2024-09-14 20:25:39	main.cpp	59	59	Handle missing parameter
f3db4a38	f24	p0	2024-09-14 20:25:39	main.cpp	69	69	Handle unknown command
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	27	27	Remove from goals if present
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	30	30	Shift elements down
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	39	39	Remove from obstacles if present
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	42	42	Shift elements down
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	54	54	Clean up if already initialized
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	72	72	Reset goals and obstacles
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	76	76	Reinitialize capacities if needed
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	90	90	std::cout << "success" << std::endl;
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	100	100	Remove from previous lists if necessary
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	103	103	Update celltype
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	107	107	Add to goals
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	109	109	Need to reallocate
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	127	127	Add to obstacles - create arrays to hold values
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	129	129	Need to reallocate
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	147	148	If type == 'E', we just removed from lists and set celltype; no need to add\nstd::cout << "success" << std::endl;
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	167	167	std::cout << "success" << std::endl;
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	173	173	std::cout << "failure" << std::endl;
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	176	176	because we recalculate on the fly we dont need to call any functions
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	178	178	std::cout << "success" << std::endl;
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	191	191	Compute potential due to goals
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	199	199	Potential is zero at the goal position
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	202	202	Negative for goals
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	208	208	Compute potential due to obstacles
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	216	216	Potential is zero at the obstacle position
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	219	219	Positive for obstacles
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.cpp	225	225	std::cout << px << " " << py << std::endl;
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.h	10	10	For storing goals
f3db4a38	f24	p0	2024-09-14 20:25:39	potential.h	16	16	For storing obstacles
f3db4a38	f24	p0	2024-09-14 21:19:33	main.cpp	20	20	Handle missing parameters
f3db4a38	f24	p0	2024-09-14 21:19:33	main.cpp	22	22	Clear the error flag and ignore the rest of the line
f3db4a38	f24	p0	2024-09-14 21:19:33	main.cpp	34	34	Handle missing parameters
f3db4a38	f24	p0	2024-09-14 21:19:33	main.cpp	47	47	Handle missing parameters
f3db4a38	f24	p0	2024-09-14 21:19:33	main.cpp	59	59	Handle missing parameter
f3db4a38	f24	p0	2024-09-14 21:19:33	main.cpp	69	69	Handle unknown command
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	27	27	Remove from goals if present
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	30	30	Shift elements down
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	39	39	Remove from obstacles if present
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	42	42	Shift elements down
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	54	54	Clean up if already initialized
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	72	72	Reset goals and obstacles
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	76	76	Reinitialize capacities if needed
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	90	90	std::cout << "success" << std::endl;
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	99	99	Remove from previous lists if necessary
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	102	102	Update celltype
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	106	106	Add to goals
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	108	108	Need to reallocate
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	126	126	Add to obstacles - create arrays to hold values
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	128	128	Need to reallocate
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	146	147	If type == 'E', we just removed from lists and set celltype; no need to add\nstd::cout << "success" << std::endl;
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	166	166	std::cout << "success" << std::endl;
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	172	172	std::cout << "failure" << std::endl;
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	175	175	because we recalculate on the fly we dont need to call any functions
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	177	177	std::cout << "success" << std::endl;
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	189	189	Compute potential due to goals
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	197	197	Potential is zero at the goal position
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	200	200	Negative for goals
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	206	206	Compute potential due to obstacles
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	214	214	Potential is zero at the obstacle position
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	217	217	Positive for obstacles
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.cpp	223	223	std::cout << px << " " << py << std::endl;
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.h	10	10	For storing goals
f3db4a38	f24	p0	2024-09-14 21:19:33	potential.h	16	16	For storing obstacles
f3db4a38	f24	p0	2024-09-21 22:40:38	main.cpp	20	20	Handle missing parameters
f3db4a38	f24	p0	2024-09-21 22:40:38	main.cpp	22	22	Clear the error flag and ignore the rest of the line
f3db4a38	f24	p0	2024-09-21 22:40:38	main.cpp	34	34	Handle missing parameters
f3db4a38	f24	p0	2024-09-21 22:40:38	main.cpp	47	47	Handle missing parameters
f3db4a38	f24	p0	2024-09-21 22:40:38	main.cpp	59	59	Handle missing parameter
f3db4a38	f24	p0	2024-09-21 22:40:38	main.cpp	69	69	Handle unknown command
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	8	8	allocated initial memory for goals and obstacles
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	16	16	delete 2d celltype array
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	23	23	delete goal and obstacle arrays
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	31	31	Remove from goals if present
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	34	34	Shift elements down to fill gap from ^
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	43	43	Remove from obstacles if present
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	46	46	Shift elements down
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	58	58	Clean up if already initialized
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	65	65	initializes new field
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	77	77	Reset goals and obstacles
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	80	80	Reinitialize capacities if needed
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	98	98	Remove from previous lists if necessary
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	101	101	Update celltype
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	104	104	Add to goals
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	106	106	Need to reallocate
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	124	124	Add to obstacles - create arrays to hold values
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	126	126	Need to reallocate
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	128	128	recreates obstacle array with new capacitry
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	131	131	copies over old values
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	134	134	deletes old instances
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	136	136	sets new
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	140	141	stores x coord of  new obstacle\nstores y coord of new obstacle
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	144	144	If type == 'E', we just removed from lists and set celltype; no need to add
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	147	147	clears field, self explanatory
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	167	167	because we recalculate on the fly we dont need to call any functions
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	176	176	Compute potential due to goals
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	179	179	iterative through both 1D array and calculates the potential based off goal position
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	184	184	Potential is zero at the goal position
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	186	186	Negative for goals
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	190	190	Compute potential due to obstacles
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	196	196	Potential is zero at the obstacle position
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.cpp	198	198	Positive for obstacles
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.h	10	10	For storing goals
f3db4a38	f24	p0	2024-09-21 22:40:38	potential.h	16	16	For storing obstacles
f3db4a38	f24	p0	2024-09-22 20:21:04	main.cpp	20	20	Handle missing parameters
f3db4a38	f24	p0	2024-09-22 20:21:04	main.cpp	22	22	Clear the error flag and ignore the rest of the line
f3db4a38	f24	p0	2024-09-22 20:21:04	main.cpp	44	44	Handle missing parameters
f3db4a38	f24	p0	2024-09-22 20:21:04	main.cpp	56	56	Handle missing parameter
f3db4a38	f24	p0	2024-09-22 20:21:04	main.cpp	66	66	Handle unknown command
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	8	8	allocated initial memory for goals and obstacles
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	16	16	delete 2d celltype array
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	23	23	delete goal and obstacle arrays
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	31	31	Remove from goals if present
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	34	34	Shift elements down to fill gap from ^
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	43	43	Remove from obstacles if present
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	46	46	Shift elements down
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	58	58	Clean up if already initialized
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	65	65	initializes new field
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	77	77	Reset goals and obstacles
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	80	80	Reinitialize capacities if needed
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	98	98	Remove from previous lists if necessary
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	101	101	Update celltype
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	104	104	Add to goals
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	106	106	Need to reallocate
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	124	124	Add to obstacles - create arrays to hold values
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	126	126	Need to reallocate
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	128	128	recreates obstacle array with new capacitry
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	131	131	copies over old values
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	134	134	deletes old instances
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	136	136	sets new
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	140	141	stores x coord of  new obstacle\nstores y coord of new obstacle
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	144	144	If type == 'E', we just removed from lists and set celltype; no need to add
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	147	147	clears field, self explanatory
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	167	167	because we recalculate on the fly we dont need to call any functions
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	176	176	Compute potential due to goals
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	179	179	iterative through both 1D array and calculates the potential based off goal position
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	184	184	Potential is zero at the goal position
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	186	186	Negative for goals
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	190	190	Compute potential due to obstacles
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	196	196	Potential is zero at the obstacle position
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.cpp	198	198	Positive for obstacles
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.h	8	8	double pointer as its a 2d array * points to array of pointers in row , second represents the actual char data in each row
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.h	10	10	For storing goals
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.h	13	13	1D array for goals
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.h	16	16	For storing obstacles
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.h	19	19	1D array for obstacles
f3db4a38	f24	p0	2024-09-22 20:21:04	potential.h	22	22	removes duplicate points from 1D arrays
f9a1ef1b	f24	p0	2024-09-22 03:21:19	cell.h	19	19	if adding an obstacle/goal, store next point here to create a linked list
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	7	7	if a map already exists
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	14	14	initialize all potentials to zero
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	24	24	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	28	28	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	34	34	if an obstacle/goal already exists
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	36	37	do not add a new point to the linked list\nif current type is opposite to new type
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	39	39	computing a point twice with the opposite type will negate the current type
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	45	45	there is no change to the potential fields
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	50	50	add a new point to the linked list
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	59	59	map->ComputePoint(point);
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	68	68	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	72	72	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	97	97	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 03:21:19	command.cpp	108	109	ComputeAll() takes O(n*m*p) time where p is the number of points\nA O(n*m) time complexity can be made here by only multiplying each (Px, Py) by k_new / k_old
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	12	13	initialize all cells of pArray\niterate on y-axis
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	15	15	iterate on x-axis
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	22	23	for (i)\nfor (j)
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	35	35	out of bounds
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	41	41	compute Px and Py for a point and add to all cells
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	44	44	if point does not exist or is not a goal/obstacle
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	52	52	add potential from point to all cells
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	55	55	if cell is not at current point
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	62	63	Since py == px, a constant time optimization can be made here\nFormula rewritten for clarity
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.cpp	77	77	traverse linked list and calculate goals/obstacles
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.h	14	15	all cells, including empty cells\nfirst and newest obstacle/goal in linked list
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.h	21	21	public member visible to command.cpp; can take out-of-bounds input
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.h	24	25	private member that does not check bounds\nTODO can this be replaced with m_pArray + i?
f9a1ef1b	f24	p0	2024-09-22 03:21:19	map.h	27	27	getters/setters
f9a1ef1b	f24	p0	2024-09-22 11:06:21	cell.h	19	19	if adding an obstacle/goal, store next point here to create a linked list
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	7	7	if a map already exists
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	14	14	initialize all potentials to zero
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	24	24	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	28	28	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	34	34	if an obstacle/goal already exists
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	36	37	do not add a new point to the linked list\nif current type is opposite to new type
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	39	39	computing a point twice with the opposite type will negate the current type
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	45	45	there is no change to the potential fields
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	50	50	add a new point to the linked list
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	59	59	map->ComputePoint(point);
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	68	68	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	72	72	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	97	97	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 11:06:21	command.cpp	108	109	ComputeAll() takes O(n*m*p) time where p is the number of points\nA O(n*m) time complexity can be made here by only multiplying each (Px, Py) by k_new / k_old
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.cpp	12	13	initialize all cells of pArray\niterate on y-axis
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.cpp	15	15	iterate on x-axis
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.cpp	22	23	for (i)\nfor (j)
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.cpp	35	35	out of bounds
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.cpp	41	41	compute Px and Py for a point and add to all cells
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.cpp	44	44	if point does not exist or is not a goal/obstacle
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.cpp	52	52	compute potential for all cells except goal/obstacle point
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.cpp	60	61	Since py == px, a constant time optimization can be made here\nFormula rewritten for clarity
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.cpp	74	74	traverse linked list and calculate goals/obstacles
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.h	14	15	all cells, including empty cells\nfirst and newest obstacle/goal in linked list
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.h	21	21	public member visible to command.cpp; can handle out-of-bounds input
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.h	24	25	private member that does not check bounds\nTODO can this be replaced with m_pArray + i?
f9a1ef1b	f24	p0	2024-09-22 11:06:21	map.h	27	27	getters/setters
f9a1ef1b	f24	p0	2024-09-22 11:06:47	cell.h	19	19	if adding an obstacle/goal, store next point here to create a linked list
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	7	7	if a map already exists
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	14	14	initialize all potentials to zero
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	24	24	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	28	28	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	34	34	if an obstacle/goal already exists
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	36	37	do not add a new point to the linked list\nif current type is opposite to new type
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	39	39	computing a point twice with the opposite type will negate the current type
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	45	45	there is no change to the potential fields
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	50	50	add a new point to the linked list
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	59	59	map->ComputePoint(point);
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	68	68	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	72	72	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	97	97	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 11:06:47	command.cpp	108	109	ComputeAll() takes O(n*m*p) time where p is the number of points\nA O(n*m) time complexity can be made here by only multiplying each (Px, Py) by k_new / k_old
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.cpp	12	13	initialize all cells of pArray\niterate on y-axis
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.cpp	15	15	iterate on x-axis
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.cpp	22	23	for (i)\nfor (j)
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.cpp	35	35	out of bounds
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.cpp	41	41	compute Px and Py for a point and add to all cells
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.cpp	44	44	if point does not exist or is not a goal/obstacle
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.cpp	52	52	compute potential for all cells except goal/obstacle point
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.cpp	60	61	Since py == px, a constant time optimization can be made here\nFormula rewritten for clarity
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.cpp	74	74	traverse linked list and calculate goals/obstacles
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.h	14	15	all cells, including empty cells\nfirst and newest obstacle/goal in linked list
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.h	21	21	public member visible to command.cpp; can handle out-of-bounds input
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.h	24	25	private member that does not check bounds\nTODO can this be replaced with m_pArray + i?
f9a1ef1b	f24	p0	2024-09-22 11:06:47	map.h	27	27	getters/setters
f9a1ef1b	f24	p0	2024-09-22 11:12:44	cell.h	19	19	if adding an obstacle/goal, store next point here to create a linked list
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	7	7	if a map already exists
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	14	14	initialize all potentials to zero
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	24	24	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	28	28	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	34	34	if an obstacle/goal already exists
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	36	37	do not add a new point to the linked list\nif current type is opposite to new type
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	39	39	computing a point twice with the opposite type will negate the current type
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	45	45	there is no change to the potential fields
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	50	50	add a new point to the linked list
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	59	59	map->ComputePoint(point);
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	68	68	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	72	72	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	97	97	TODO error handling: is expected output "failure"?
f9a1ef1b	f24	p0	2024-09-22 11:12:44	command.cpp	108	109	ComputeAll() takes O(n*m*p) time where p is the number of points\nA O(n*m) time complexity can be made here by only multiplying each (Px, Py) by k_new / k_old
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.cpp	12	13	initialize all cells of pArray\niterate on y-axis
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.cpp	15	15	iterate on x-axis
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.cpp	22	23	for (i)\nfor (j)
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.cpp	35	35	out of bounds
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.cpp	41	41	compute Px and Py for a point and add to all cells
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.cpp	44	44	if point does not exist or is not a goal/obstacle
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.cpp	52	52	compute potential for all cells except goal/obstacle point
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.cpp	62	63	Since py == px, a constant time optimization can be made here\nFormula rewritten for clarity
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.cpp	77	77	traverse linked list and calculate goals/obstacles
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.h	14	15	all cells, including empty cells\nfirst and newest obstacle/goal in linked list
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.h	21	21	public member visible to command.cpp; can handle out-of-bounds input
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.h	24	25	private member that does not check bounds\nTODO can this be replaced with m_pArray + i?
f9a1ef1b	f24	p0	2024-09-22 11:12:44	map.h	27	27	getters/setters
f9a1ef1b	f24	p0	2024-09-23 22:55:14	cell.h	1	1	cell.h
f9a1ef1b	f24	p0	2024-09-23 22:55:14	command.cpp	1	1	command.cpp
f9a1ef1b	f24	p0	2024-09-23 22:55:14	command.cpp	8	8	if a map already exists
f9a1ef1b	f24	p0	2024-09-23 22:55:14	command.cpp	15	15	initialize all types and potentials to zero
f9a1ef1b	f24	p0	2024-09-23 22:55:14	command.cpp	29	29	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-23 22:55:14	command.cpp	34	34	if current cell is not a point, add a new point to the linked list
f9a1ef1b	f24	p0	2024-09-23 22:55:14	command.cpp	54	54	(x, y) out of bounds
f9a1ef1b	f24	p0	2024-09-23 22:55:14	command.cpp	89	90	ComputeAll() takes O(n*m*p) time where p is the number of points in the linked list\nShortcut: O(n*m) time complexity can be achieved here by only multiplying each (Px, Py) by k_new / k_old
f9a1ef1b	f24	p0	2024-09-23 22:55:14	command.h	1	1	command.h
f9a1ef1b	f24	p0	2024-09-23 22:55:14	main.cpp	1	1	main.cpp
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.cpp	1	1	map.cpp
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.cpp	12	13	initialize (x, y) position member variables in pArray\niterate on y-axis
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.cpp	15	15	iterate on x-axis
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.cpp	49	49	traverse linked list and calculate goals/obstacles
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.cpp	60	60	out of bounds
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.cpp	64	64	compute Px and Py for a point and add to all cells
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.cpp	67	67	if point does not exist or is not a goal/obstacle
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.cpp	75	75	compute potential for all cells except goal/obstacle point
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.cpp	85	85	Since py == px, a constant time optimization can be made here using cell->py = cell->px
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.h	1	1	map.h
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.h	14	15	array of cells\npointer to first obstacle/goal in pArray
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.h	20	20	public member visible to command.cpp that checks for out-of-bounds input
f9a1ef1b	f24	p0	2024-09-23 22:55:14	map.h	23	23	private member that does not check bounds
